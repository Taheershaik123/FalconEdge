var $x = (e, t) => () => (t || e((t = {
    exports: {}
}).exports, t),
t.exports);
import {C as qi, l as Rx, g as En, c as Hn, a as jm, B as Mn, i as Af, P as Px, b as c1, d as fo, e as kx, S as mf, m as u1, f as Cx} from "./hoisted-BMaoD6Tc.js";
var A6 = $x( ($6, ws) => {
    class Mx extends qi {
        get tabId() {
            return this.element.dataset.navId
        }
        get item() {
            return this._config.el
        }
        doSetup() {}
        async _activate() {
            await this._activateSelf(),
            this.item.tabHooks?.activate && await this.item.tabHooks.activate(this.activationConfig)
        }
        async _deactivate() {
            await this._deactivateSelf(),
            this.item.tabHooks?.deactivate && await this.item.tabHooks.deactivate(this.activationConfig)
        }
        _activateSelf() {}
        _deactivateSelf() {}
    }
    class Lx extends Mx {
        _activateSelf() {
            this._config.activateClass && this.item.classList.add(this._config.activateClass)
        }
        _deactivateSelf() {
            this._config.activateClass && this.item.classList.remove(this._config.activateClass)
        }
    }
    var ta = {};
    Object.defineProperty(ta, "__esModule", {
        value: !0
    });
    ta.createManualPromise = ta.chainPromises = cu = ta.OptAwait = void 0;
    async function Dx(e, t) {
        return e && (t ? await e() : e())
    }
    var cu = ta.OptAwait = Dx;
    async function Ux(...e) {
        const t = (n, r) => n.then(r);
        return e.reduce(t, Promise.resolve())
    }
    ta.chainPromises = Ux;
    function Bx() {
        let e, t;
        const n = new Promise( (r, s) => {
            e = r,
            t = s
        }
        );
        return {
            get promise() {
                return n
            },
            get resolve() {
                return e
            },
            get reject() {
                return t
            }
        }
    }
    ta.createManualPromise = Bx;
    class Fx extends qi {
        _tabs = [];
        _activateCallback = null;
        _chainActivation = !1;
        get item() {
            return this._config.el
        }
        get tabs() {
            return this._tabs
        }
        setActivateCallback(t) {
            return this._activateCallback = t,
            this
        }
        setActivationChain(t) {
            return this._chainActivation = t,
            this
        }
        registerTab(t) {
            this._tabs.push(t)
        }
        _requestActivate() {
            this._activateCallback && this._activateCallback(this)
        }
        async _activate() {
            for (let t = 0; t < this._tabs.length; ++t) {
                const n = this._tabs[t];
                await cu( () => n.activate(this.activationConfig), this._chainActivation)
            }
            this._activateSelf(),
            this.item.linkHooks?.activate && this.item.linkHooks.activate(this.activationConfig)
        }
        async _deactivate() {
            for (let t = 0; t < this._tabs.length; ++t) {
                const n = this._tabs[t];
                await cu( () => n.deactivate(this.activationConfig), this._chainActivation)
            }
            this._deactivateSelf(),
            this.item.linkHooks?.deactivate && this.item.linkHooks.deactivate(this.activationConfig)
        }
    }
    class jx extends Fx {
        get activeClass() {
            return this._config.activeClass || "active"
        }
        get hoverEnabled() {
            return this._config.hoverEnabled || !1
        }
        get clickEnabled() {
            return this._config.clickEnabled == null ? !0 : !!this._config.clickEnabled
        }
        get targetId() {
            return this.item.dataset.navTarget
        }
        doSetup() {
            this.clickEnabled && this.item.addEventListener("click", this._onClick.bind(this)),
            this.hoverEnabled && this.item.addEventListener("mouseover", this._onHover.bind(this)),
            this.item.classList.contains(this.activeClass) && this.activate()
        }
        _onClick(t) {
            t.preventDefault(),
            this._requestActivate()
        }
        _onHover(t) {
            t.preventDefault(),
            this._requestActivate()
        }
        _activateSelf() {
            this.item.classList.add(this.activeClass)
        }
        _deactivateSelf() {
            this.item.classList.remove(this.activeClass)
        }
    }
    const dp = () => {}
    ;
    class qx extends qi {
        _prevButton;
        _nextButton;
        syncActivate;
        _tabs;
        _links;
        _async;
        _currentActiveLink;
        _isSwitching;
        _currentActiveIndex;
        constructor(t) {
            super(t),
            this.syncActivate = t.syncActivate,
            this._async = !this.syncActivate,
            this._tabs = t.tabItems || t.tabs.map(n => new Lx({
                el: n,
                activateClass: t.tabActiveClass || "active"
            })),
            this._links = t.linkItems || (t.links || []).map(n => new jx({
                el: n,
                activateClass: t.linkActiveClass,
                clicksEnabled: t.clicksEnabled,
                hoversEnabled: t.hoversEnabled
            })),
            this._currentActiveLink = null,
            this._currentActiveIndex = -1,
            this._isSwitching = !1
        }
        async doSetup() {
            await Promise.all(this._tabs.map(t => t.setup())),
            await Promise.all(this._links.map(async (t, n) => {
                const r = t.targetId;
                this._tabs.forEach(s => {
                    r === s.tabId && t.registerTab(s)
                }
                ),
                t.tabs.length === 0 && Rx.error("Could not find tab for targetID =", r),
                await t.setActivateCallback(s => this.setActiveLink(s)).setActivationChain(this.syncActivate).setup(),
                t.isActive && (this._currentActiveLink ? t.deactivate() : (this._currentActiveLink = t,
                this._currentActiveIndex = n))
            }
            ))
        }
        get currentIndex() {
            return this._currentActiveIndex
        }
        get currentLink() {
            return this._currentActiveLink
        }
        setActiveIndex = t => this.setActiveLink(this._links[t]);
        setActiveLink = async t => {
            if (t === this._currentActiveLink || this._isSwitching)
                return null;
            this._isSwitching = !0;
            const n = this._currentActiveLink
              , r = t
              , s = this._links.indexOf(t)
              , o = this._links.indexOf(n)
              , c = Math.sign(s - o)
              , l = {
                before: () => (this._config.onWillChange || dp)(n, r, c),
                inside: () => (this._config.onChanging || dp)(n, r, c),
                after: () => (this._config.onChanged || dp)(n, r, c)
            };
            this._currentActiveLink = r,
            this._currentActiveIndex = s;
            try {
                l.before(),
                await cu( () => n?.deactivate({
                    direction: c
                }), !this._async),
                l.inside(),
                await cu( () => r.activate({
                    direction: c
                }), !this._async),
                l.after()
            } finally {
                this._isSwitching = !1
            }
        }
        ;
        next(t=!0) {
            let n = this._currentActiveIndex + 1;
            n >= this._links.length && (n = t ? 0 : this._links.length - 1),
            this.setActiveIndex(n)
        }
        prev(t=!0) {
            let n = this._currentActiveIndex - 1;
            n < 0 && (n = t ? this._links.length - 1 : 0),
            this.setActiveIndex(n)
        }
        addNextButton(t, n=!0) {
            return this._nextButton = t,
            this._nextButton && this._nextButton.addEventListener("click", r => {
                r.preventDefault(),
                this.next(n)
            }
            ),
            this
        }
        addPrevButton(t, n=!0) {
            return this._prevButton = t,
            this._prevButton && this._prevButton.addEventListener("click", r => {
                r.preventDefault(),
                this.prev(n)
            }
            ),
            this
        }
    } 
    var Hx = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig
      , Yx = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig
      , Vx = Math.PI / 180
      , Kl = Math.sin
      , Jl = Math.cos
      , Kc = Math.abs
      , Ac = Math.sqrt
      , Wx = function(t) {
        return typeof t == "number"
    }
      , k_ = 1e5
      , as = function(t) {
        return Math.round(t * k_) / k_ || 0
    };
    function zx(e, t, n, r, s, o, c) {
        for (var l = e.length, f, d, h, y, I; --l > -1; )
            for (f = e[l],
            d = f.length,
            h = 0; h < d; h += 2)
                y = f[h],
                I = f[h + 1],
                f[h] = y * t + I * r + o,
                f[h + 1] = y * n + I * s + c;
        return e._dirty = 1,
        e
    }
    function Gx(e, t, n, r, s, o, c, l, f) {
        if (!(e === l && t === f)) {
            n = Kc(n),
            r = Kc(r);
            var d = s % 360 * Vx
              , h = Jl(d)
              , y = Kl(d)
              , I = Math.PI
              , $ = I * 2
              , O = (e - l) / 2
              , A = (t - f) / 2
              , N = h * O + y * A
              , m = -y * O + h * A
              , g = N * N
              , M = m * m
              , G = g / (n * n) + M / (r * r);
            G > 1 && (n = Ac(G) * n,
            r = Ac(G) * r);
            var U = n * n
              , D = r * r
              , K = (U * D - U * M - D * g) / (U * M + D * g);
            K < 0 && (K = 0);
            var _ = (o === c ? -1 : 1) * Ac(K)
              , T = _ * (n * m / r)
              , S = _ * -(r * N / n)
              , q = (e + l) / 2
              , C = (t + f) / 2
              , F = q + (h * T - y * S)
              , X = C + (y * T + h * S)
              , v = (N - T) / n
              , x = (m - S) / r
              , Y = (-N - T) / n
              , W = (-m - S) / r
              , te = v * v + x * x
              , J = (x < 0 ? -1 : 1) * Math.acos(v / Ac(te))
              , H = (v * W - x * Y < 0 ? -1 : 1) * Math.acos((v * Y + x * W) / Ac(te * (Y * Y + W * W)));
            isNaN(H) && (H = I),
            !c && H > 0 ? H -= $ : c && H < 0 && (H += $),
            J %= $,
            H %= $;
            var ae = Math.ceil(Kc(H) / ($ / 4)), Q = [], P = H / ae, j = 4 / 3 * Kl(P / 2) / (1 + Jl(P / 2)), se = h * n, ye = y * n, we = y * -r, De = h * r, Re;
            for (Re = 0; Re < ae; Re++)
                s = J + Re * P,
                N = Jl(s),
                m = Kl(s),
                v = Jl(s += P),
                x = Kl(s),
                Q.push(N - j * m, m + j * N, v + j * x, x - j * v, v, x);
            for (Re = 0; Re < Q.length; Re += 2)
                N = Q[Re],
                m = Q[Re + 1],
                Q[Re] = N * se + m * we + F,
                Q[Re + 1] = N * ye + m * De + X;
            return Q[Re - 2] = l,
            Q[Re - 1] = f,
            Q
        }
    }
    function Zx(e) {
        var t = (e + "").replace(Yx, function(T) {
            var S = +T;
            return S < 1e-4 && S > -1e-4 ? 0 : S
        }).match(Hx) || [], n = [], r = 0, s = 0, o = 2 / 3, c = t.length, l = 0, f = "ERROR: malformed path: " + e, d, h, y, I, $, O, A, N, m, g, M, G, U, D, K, _ = function(S, q, C, F) {
            g = (C - S) / 3,
            M = (F - q) / 3,
            A.push(S + g, q + M, C - g, F - M, C, F)
        };
        if (!e || !isNaN(t[0]) || isNaN(t[1]))
            return console.log(f),
            n;
        for (d = 0; d < c; d++)
            if (U = $,
            isNaN(t[d]) ? ($ = t[d].toUpperCase(),
            O = $ !== t[d]) : d--,
            y = +t[d + 1],
            I = +t[d + 2],
            O && (y += r,
            I += s),
            d || (N = y,
            m = I),
            $ === "M")
                A && (A.length < 8 ? n.length -= 1 : l += A.length),
                r = N = y,
                s = m = I,
                A = [y, I],
                n.push(A),
                d += 2,
                $ = "L";
            else if ($ === "C")
                A || (A = [0, 0]),
                O || (r = s = 0),
                A.push(y, I, r + t[d + 3] * 1, s + t[d + 4] * 1, r += t[d + 5] * 1, s += t[d + 6] * 1),
                d += 6;
            else if ($ === "S")
                g = r,
                M = s,
                (U === "C" || U === "S") && (g += r - A[A.length - 4],
                M += s - A[A.length - 3]),
                O || (r = s = 0),
                A.push(g, M, y, I, r += t[d + 3] * 1, s += t[d + 4] * 1),
                d += 4;
            else if ($ === "Q")
                g = r + (y - r) * o,
                M = s + (I - s) * o,
                O || (r = s = 0),
                r += t[d + 3] * 1,
                s += t[d + 4] * 1,
                A.push(g, M, r + (y - r) * o, s + (I - s) * o, r, s),
                d += 4;
            else if ($ === "T")
                g = r - A[A.length - 4],
                M = s - A[A.length - 3],
                A.push(r + g, s + M, y + (r + g * 1.5 - y) * o, I + (s + M * 1.5 - I) * o, r = y, s = I),
                d += 2;
            else if ($ === "H")
                _(r, s, r = y, s),
                d += 1;
            else if ($ === "V")
                _(r, s, r, s = y + (O ? s - r : 0)),
                d += 1;
            else if ($ === "L" || $ === "Z")
                $ === "Z" && (y = N,
                I = m,
                A.closed = !0),
                ($ === "L" || Kc(r - y) > .5 || Kc(s - I) > .5) && (_(r, s, y, I),
                $ === "L" && (d += 2)),
                r = y,
                s = I;
            else if ($ === "A") {
                if (D = t[d + 4],
                K = t[d + 5],
                g = t[d + 6],
                M = t[d + 7],
                h = 7,
                D.length > 1 && (D.length < 3 ? (M = g,
                g = K,
                h--) : (M = K,
                g = D.substr(2),
                h -= 2),
                K = D.charAt(1),
                D = D.charAt(0)),
                G = Gx(r, s, +t[d + 1], +t[d + 2], +t[d + 3], +D, +K, (O ? r : 0) + g * 1, (O ? s : 0) + M * 1),
                d += h,
                G)
                    for (h = 0; h < G.length; h++)
                        A.push(G[h]);
                r = A[A.length - 2],
                s = A[A.length - 1]
            } else
                console.log(f);
        return d = A.length,
        d < 6 ? (n.pop(),
        d = 0) : A[0] === A[d - 2] && A[1] === A[d - 1] && (A.closed = !0),
        n.totalPoints = l + d,
        n
    }
    function Kx(e) {
        Wx(e[0]) && (e = [e]);
        var t = "", n = e.length, r, s, o, c;
        for (s = 0; s < n; s++) {
            for (c = e[s],
            t += "M" + as(c[0]) + "," + as(c[1]) + " C",
            r = c.length,
            o = 2; o < r; o++)
                t += as(c[o++]) + "," + as(c[o++]) + " " + as(c[o++]) + "," + as(c[o++]) + " " + as(c[o++]) + "," + as(c[o]) + " ";
            c.closed && (t += "z")
        }
        return t
    }
    /*!
 * CustomEase 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
    var kn, l1, f1 = function() {
        return kn || typeof window < "u" && (kn = window.gsap) && kn.registerPlugin && kn
    }, C_ = function() {
        kn = f1(),
        kn ? (kn.registerEase("_CE", Hi.create),
        l1 = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
    }, Jx = 1e20, Xl = function(t) {
        return ~~(t * 1e3 + (t < 0 ? -.5 : .5)) / 1e3
    }, Xx = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, Qx = /[cLlsSaAhHvVtTqQ]/g, e$ = function(t) {
        var n = t.length, r = Jx, s;
        for (s = 1; s < n; s += 6)
            +t[s] < r && (r = +t[s]);
        return r
    }, t$ = function(t, n, r) {
        !r && r !== 0 && (r = Math.max(+t[t.length - 1], +t[1]));
        var s = +t[0] * -1, o = -r, c = t.length, l = 1 / (+t[c - 2] + s), f = -n || (Math.abs(+t[c - 1] - +t[1]) < .01 * (+t[c - 2] - +t[0]) ? e$(t) + o : +t[c - 1] + o), d;
        for (f ? f = 1 / f : f = -l,
        d = 0; d < c; d += 2)
            t[d] = (+t[d] + s) * l,
            t[d + 1] = (+t[d + 1] + o) * f
    }, n$ = function e(t, n, r, s, o, c, l, f, d, h, y) {
        var I = (t + r) / 2, $ = (n + s) / 2, O = (r + o) / 2, A = (s + c) / 2, N = (o + l) / 2, m = (c + f) / 2, g = (I + O) / 2, M = ($ + A) / 2, G = (O + N) / 2, U = (A + m) / 2, D = (g + G) / 2, K = (M + U) / 2, _ = l - t, T = f - n, S = Math.abs((r - l) * T - (s - f) * _), q = Math.abs((o - l) * T - (c - f) * _), C;
        return h || (h = [{
            x: t,
            y: n
        }, {
            x: l,
            y: f
        }],
        y = 1),
        h.splice(y || h.length - 1, 0, {
            x: D,
            y: K
        }),
        (S + q) * (S + q) > d * (_ * _ + T * T) && (C = h.length,
        e(t, n, I, $, g, M, D, K, d, h, y),
        e(D, K, G, U, N, m, l, f, d, h, y + 1 + (h.length - C))),
        h
    }, Hi = function() {
        function e(n, r, s) {
            l1 || C_(),
            this.id = n,
            this.setData(r, s)
        }
        var t = e.prototype;
        return t.setData = function(r, s) {
            s = s || {},
            r = r || "0,0,1,1";
            var o = r.match(Xx), c = 1, l = [], f = [], d = s.precision || 1, h = d <= 1, y, I, $, O, A, N, m, g, M;
            if (this.data = r,
            (Qx.test(r) || ~r.indexOf("M") && r.indexOf("C") < 0) && (o = Zx(r)[0]),
            y = o.length,
            y === 4)
                o.unshift(0, 0),
                o.push(1, 1),
                y = 8;
            else if ((y - 2) % 6)
                throw "Invalid CustomEase";
            for ((+o[0] != 0 || +o[y - 2] != 1) && t$(o, s.height, s.originY),
            this.segment = o,
            O = 2; O < y; O += 6)
                I = {
                    x: +o[O - 2],
                    y: +o[O - 1]
                },
                $ = {
                    x: +o[O + 4],
                    y: +o[O + 5]
                },
                l.push(I, $),
                n$(I.x, I.y, +o[O], +o[O + 1], +o[O + 2], +o[O + 3], $.x, $.y, 1 / (d * 2e5), l, l.length - 1);
            for (y = l.length,
            O = 0; O < y; O++)
                m = l[O],
                g = l[O - 1] || m,
                (m.x > g.x || g.y !== m.y && g.x === m.x || m === g) && m.x <= 1 ? (g.cx = m.x - g.x,
                g.cy = m.y - g.y,
                g.n = m,
                g.nx = m.x,
                h && O > 1 && Math.abs(g.cy / g.cx - l[O - 2].cy / l[O - 2].cx) > 2 && (h = 0),
                g.cx < c && (g.cx ? c = g.cx : (g.cx = .001,
                O === y - 1 && (g.x -= .001,
                c = Math.min(c, .001),
                h = 0)))) : (l.splice(O--, 1),
                y--);
            if (y = 1 / c + 1 | 0,
            A = 1 / y,
            N = 0,
            m = l[0],
            h) {
                for (O = 0; O < y; O++)
                    M = O * A,
                    m.nx < M && (m = l[++N]),
                    I = m.y + (M - m.x) / m.cx * m.cy,
                    f[O] = {
                        x: M,
                        cx: A,
                        y: I,
                        cy: 0,
                        nx: 9
                    },
                    O && (f[O - 1].cy = I - f[O - 1].y);
                N = l[l.length - 1],
                f[y - 1].cy = N.y - I,
                f[y - 1].cx = N.x - f[f.length - 1].x
            } else {
                for (O = 0; O < y; O++)
                    m.nx < O * A && (m = l[++N]),
                    f[O] = m;
                N < l.length - 1 && (f[O - 1] = l[l.length - 2])
            }
            return this.ease = function(G) {
                var U = f[G * y | 0] || f[y - 1];
                return U.nx < G && (U = U.n),
                U.y + (G - U.x) / U.cx * U.cy
            }
            ,
            this.ease.custom = this,
            this.id && kn && kn.registerEase(this.id, this.ease),
            this
        }
        ,
        t.getSVGData = function(r) {
            return e.getSVGData(this, r)
        }
        ,
        e.create = function(r, s, o) {
            return new e(r,s,o).ease
        }
        ,
        e.register = function(r) {
            kn = r,
            C_()
        }
        ,
        e.get = function(r) {
            return kn.parseEase(r)
        }
        ,
        e.getSVGData = function(r, s) {
            s = s || {};
            var o = s.width || 100, c = s.height || 100, l = s.x || 0, f = (s.y || 0) + c, d = kn.utils.toArray(s.path)[0], h, y, I, $, O, A, N, m, g, M;
            if (s.invert && (c = -c,
            f = 0),
            typeof r == "string" && (r = kn.parseEase(r)),
            r.custom && (r = r.custom),
            r instanceof e)
                h = Kx(zx([r.segment], o, 0, 0, -c, l, f));
            else {
                for (h = [l, f],
                N = Math.max(5, (s.precision || 1) * 200),
                $ = 1 / N,
                N += 2,
                m = 5 / N,
                g = Xl(l + $ * o),
                M = Xl(f + r($) * -c),
                y = (M - f) / (g - l),
                I = 2; I < N; I++)
                    O = Xl(l + I * $ * o),
                    A = Xl(f + r(I * $) * -c),
                    (Math.abs((A - M) / (O - g) - y) > m || I === N - 1) && (h.push(g, M),
                    y = (A - M) / (O - g)),
                    g = O,
                    M = A;
                h = "M" + h.join(",")
            }
            return d && d.setAttribute("d", h),
            h
        }
        ,
        e
    }();
    Hi.version = "3.12.7";
    Hi.headless = !0;
    f1() && kn.registerPlugin(Hi);
    En.registerPlugin(Hi);
    Hi.create("customEase", "M0,0 C0.17,0.17 0.22,1 1,1 ");
    Hi.create("custom43", "M0,0 C0.17,0.17 0.43,1 1,1 ");
    const r$ = Hi.create("customOut", "M0,0 C0.57,0 0.83,0.83 1,1 ")
      , i$ = Hi.create("customIn", "M0,0 C0.17,0.17 0.43,1 1,1");
    var qm = {
        exports: {}
    }
      , yd = {
        exports: {}
    };
    const s$ = Object.getPrototypeOf({});
    function Hm(e) {
        function t(m) {
            return m !== "constructor" && m !== "prototype" && m !== "__proto__"
        }
        function n(m) {
            let g = 0;
            const M = m.length
              , G = new Array(M);
            for (g = 0; g < M; ++g)
                G[g] = $(m[g]);
            return G
        }
        function r(m) {
            const g = {};
            if (f && Object.getPrototypeOf(m) !== s$)
                return f(m);
            const M = l(m);
            let G, U, D;
            for (G = 0,
            U = M.length; G < U; ++G)
                t(D = M[G]) && (g[D] = $(m[D]));
            return g
        }
        function s(m, g) {
            const M = m.length
              , G = g.length;
            let U = 0;
            const D = new Array(M + G);
            for (U = 0; U < M; ++U)
                D[U] = $(m[U]);
            for (U = 0; U < G; ++U)
                D[U + M] = $(g[U]);
            return D
        }
        const o = Object.prototype.propertyIsEnumerable;
        function c(m) {
            const g = Object.keys(m)
              , M = Object.getOwnPropertySymbols(m);
            for (let G = 0, U = M.length; G < U; ++G)
                o.call(m, M[G]) && g.push(M[G]);
            return g
        }
        const l = e && e.symbols ? c : Object.keys
          , f = typeof e?.cloneProtoObject == "function" ? e.cloneProtoObject : void 0;
        function d(m) {
            return typeof m == "object" && m !== null && !(m instanceof RegExp) && !(m instanceof Date)
        }
        function h(m) {
            return typeof m != "object" || m === null
        }
        const y = typeof Buffer < "u" ? m => typeof m != "object" || m === null || m instanceof RegExp || m instanceof Date || m instanceof Buffer : m => typeof m != "object" || m === null || m instanceof RegExp || m instanceof Date
          , I = e && typeof e.mergeArray == "function" ? e.mergeArray({
            clone: $,
            deepmerge: A,
            getKeys: l,
            isMergeableObject: d
        }) : s;
        function $(m) {
            return d(m) ? Array.isArray(m) ? n(m) : r(m) : m
        }
        function O(m, g) {
            const M = {}
              , G = l(m)
              , U = l(g);
            let D, K, _;
            for (D = 0,
            K = G.length; D < K; ++D)
                t(_ = G[D]) && U.indexOf(_) === -1 && (M[_] = $(m[_]));
            for (D = 0,
            K = U.length; D < K; ++D)
                t(_ = U[D]) && (_ in m && (G.indexOf(_) !== -1 && (M[_] = A(m[_], g[_])),
                !0) || (M[_] = $(g[_])));
            return M
        }
        function A(m, g) {
            const M = Array.isArray(g)
              , G = Array.isArray(m);
            return h(g) ? g : y(m) ? $(g) : M && G ? I(m, g) : M !== G ? $(g) : O(m, g)
        }
        function N() {
            switch (arguments.length) {
            case 0:
                return {};
            case 1:
                return $(arguments[0]);
            case 2:
                return A(arguments[0], arguments[1])
            }
            let m;
            for (let g = 0, M = arguments.length; g < M; ++g)
                m = A(m, arguments[g]);
            return m
        }
        return e && e.all ? N : A
    }
    yd.exports = Hm;
    yd.exports.default = Hm;
    yd.exports.deepmerge = Hm;
    var a$ = yd.exports;
    const o$ = a$
      , d1 = e => e && e.isFluentSchema
      , c$ = e => e.allOf || e.anyOf || e.oneOf || e.not;
    let Ym = class extends Error {
        constructor(t) {
            super(t),
            this.name = "FluentSchemaError"
        }
    }
    ;
    const Vm = e => {
        if (!e)
            return;
        const [t] = [...e].reverse();
        return t
    }
      , h1 = e => e.filter( (t, n, r) => r.indexOf(t) === n).length === e.length
      , u$ = e => typeof e == "boolean"
      , l$ = (e, t) => Object.entries(e).reduce( (n, [r,s]) => t.includes(r) ? n : {
        ...n,
        [r]: s
    }, {})
      , f$ = e => e.reduce( (t, n) => {
        const {name: r, ...s} = n;
        return {
            ...t,
            [r]: s
        }
    }
    , {})
      , d$ = e => {
        const {clone: t, isMergeableObject: n, deepmerge: r} = e;
        return (s, o) => {
            const c = s.slice();
            return o.forEach( (l, f) => {
                const d = s.find(h => h.name === l.name);
                if (c[f] === void 0)
                    c[f] = t(l);
                else if (n(d)) {
                    const h = s.findIndex(y => y.name === l.name);
                    c[h] = r(d, l)
                } else
                    s.indexOf(l) === -1 && c.push(l)
            }
            ),
            c
        }
    }
      , h$ = o$({
        mergeArray: d$
    })
      , p$ = e => e && Object.entries(e).map( ([t,n]) => ({
        name: t,
        ...n
    }))
      , p1 = Symbol("required")
      , m$ = Symbol.for("fluent-schema-object")
      , g$ = "relative-json-pointer"
      , y$ = "json-pointer"
      , _$ = "uuid"
      , v$ = "regex"
      , w$ = "ipv6"
      , b$ = "ipv4"
      , E$ = "hostname"
      , S$ = "email"
      , T$ = "url"
      , A$ = "uri-template"
      , O$ = "uri-reference"
      , I$ = "uri"
      , N$ = "time"
      , x$ = "date"
      , $$ = "date-time"
      , R$ = {
        RELATIVE_JSON_POINTER: g$,
        JSON_POINTER: y$,
        UUID: _$,
        REGEX: v$,
        IPV6: w$,
        IPV4: b$,
        HOSTNAME: E$,
        EMAIL: S$,
        URL: T$,
        URI_TEMPLATE: A$,
        URI_REFERENCE: O$,
        URI: I$,
        TIME: N$,
        DATE: x$,
        DATE_TIME: $$
    }
      , P$ = "string"
      , k$ = "number"
      , C$ = "boolean"
      , M$ = "integer"
      , L$ = "object"
      , D$ = "array"
      , U$ = "null"
      , B$ = {
        STRING: P$,
        NUMBER: k$,
        BOOLEAN: C$,
        INTEGER: M$,
        OBJECT: L$,
        ARRAY: D$,
        NULL: U$
    }
      , F$ = ({schema: e, generateIds: t, parentId: n}) => {
        const r = Object.entries(e.properties || {});
        return r.length === 0 ? e : {
            ...e,
            properties: r.reduce( (s, [o,c]) => {
                const l = c.$id || (t ? `#properties/${o}` : void 0);
                return {
                    ...s,
                    [o]: {
                        ...c,
                        $id: t && n ? `${n}/${l.replace("#", "")}` : l
                    }
                }
            }
            , {})
        }
    }
      , j$ = ({attributes: {name: e, required: t, ...n}, schema: r}) => {
        const {schemaRequired: s, attributeRequired: o} = (t || []).reduce( (d, h) => h === p1 ? {
            ...d,
            schemaRequired: [...d.schemaRequired, e]
        } : {
            ...d,
            attributeRequired: [...d.attributeRequired, h]
        }, {
            schemaRequired: [],
            attributeRequired: []
        })
          , c = [...r.required, ...s];
        if (!h1(c))
            throw new Ym("'required' has repeated keys, check your calls to .required()");
        const l = {
            ...r,
            required: c
        }
          , f = {
            ...n,
            required: o
        };
        return [l, f]
    }
      , q$ = ({schema: e, ...t}, n) => {
        const [r,s] = n
          , o = Vm(e.properties);
        if (o) {
            const {name: c, ...l} = o;
            return t.factory({
                schema: e,
                ...t
            }).prop(c, {
                [r]: s,
                ...l
            })
        }
        return t.factory({
            schema: {
                ...e,
                [r]: s
            },
            ...t
        })
    }
      , H$ = ({schema: e, ...t}, n) => {
        const r = Vm(e.properties);
        if (r) {
            const {name: s, ...o} = r;
            return t.factory({
                schema: e,
                ...t
            }).prop(s, {
                ...n,
                ...o
            })
        }
        return t.factory({
            schema: {
                ...e,
                ...n
            },
            ...t
        })
    }
      , Y$ = ({prop: e, schemas: t, schema: n, options: r}) => {
        if (!(Array.isArray(t) && t.every(o => d1(o))))
            throw new Ym(`'${e}' must be a an array of FluentSchema rather than a '${typeof t}'`);
        const s = t.map(o => {
            const {$schema: c, ...l} = o.valueOf({
                isRoot: !1
            });
            return l
        }
        );
        return r.factory({
            schema: {
                ...n,
                [e]: s
            },
            ...r
        })
    }
    ;
    var Yi = {
        isFluentSchema: d1,
        hasCombiningKeywords: c$,
        FluentSchemaError: Ym,
        last: Vm,
        isUniq: h1,
        isBoolean: u$,
        flat: f$,
        toArray: p$,
        omit: l$,
        REQUIRED: p1,
        patchIdsWithParentId: F$,
        appendRequired: j$,
        setRaw: H$,
        setAttribute: q$,
        setComposeType: Y$,
        combineDeepmerge: h$,
        FORMATS: R$,
        TYPES: B$,
        FLUENT_SCHEMA: m$
    };
    const {flat: M_, omit: js, isFluentSchema: qa, last: V$, isBoolean: W$, isUniq: z$, patchIdsWithParentId: Ha, REQUIRED: G$, setAttribute: nr, setRaw: Z$, setComposeType: hp, FluentSchemaError: rr, FLUENT_SCHEMA: K$} = Yi
      , J$ = {
        properties: [],
        required: []
    }
      , Of = ({schema: e=J$, ...t}={
        generateIds: !1,
        factory: Of
    }) => ({
        [K$]: !0,
        isFluentSchema: !0,
        isFluentJSONSchema: !0,
        id: n => {
            if (!n)
                throw new rr("id should not be an empty fragment <#> or an empty string <> (e.g. #myId)");
            return nr({
                schema: e,
                ...t
            }, ["$id", n, "any"])
        }
        ,
        title: n => nr({
            schema: e,
            ...t
        }, ["title", n, "any"]),
        description: n => nr({
            schema: e,
            ...t
        }, ["description", n, "any"]),
        examples: n => {
            if (!Array.isArray(n))
                throw new rr("'examples' must be an array e.g. ['1', 'one', 'foo']");
            return nr({
                schema: e,
                ...t
            }, ["examples", n, "any"])
        }
        ,
        ref: n => nr({
            schema: e,
            ...t
        }, ["$ref", n, "any"]),
        enum: n => {
            if (!Array.isArray(n))
                throw new rr("'enums' must be an array with at least an element e.g. ['1', 'one', 'foo']");
            return nr({
                schema: e,
                ...t
            }, ["enum", n, "any"])
        }
        ,
        const: n => nr({
            schema: e,
            ...t
        }, ["const", n, "any"]),
        default: n => nr({
            schema: e,
            ...t
        }, ["default", n, "any"]),
        readOnly: n => {
            const r = n !== void 0 ? n : !0;
            return nr({
                schema: e,
                ...t
            }, ["readOnly", r, "boolean"])
        }
        ,
        writeOnly: n => {
            const r = n !== void 0 ? n : !0;
            return nr({
                schema: e,
                ...t
            }, ["writeOnly", r, "boolean"])
        }
        ,
        deprecated: n => {
            if (n && !W$(n))
                throw new rr("'deprecated' must be a boolean value");
            const r = n !== void 0 ? n : !0;
            return nr({
                schema: e,
                ...t
            }, ["deprecated", r, "boolean"])
        }
        ,
        required: n => {
            const r = V$(e.properties)
              , s = Array.isArray(n) ? [...e.required, ...n] : r ? [...e.required, r.name] : [G$];
            if (!z$(s))
                throw new rr("'required' has repeated keys, check your calls to .required()");
            return t.factory({
                schema: {
                    ...e,
                    required: s
                },
                ...t
            })
        }
        ,
        not: n => {
            if (!qa(n))
                throw new rr("'not' must be a BaseSchema");
            const r = js(n.valueOf(), ["$schema", "definitions"]);
            return Of({
                schema: {
                    ...e,
                    not: Ha({
                        schema: r,
                        ...t,
                        parentId: "#not"
                    })
                },
                ...t
            })
        }
        ,
        anyOf: n => hp({
            prop: "anyOf",
            schemas: n,
            schema: e,
            options: t
        }),
        allOf: n => hp({
            prop: "allOf",
            schemas: n,
            schema: e,
            options: t
        }),
        oneOf: n => hp({
            prop: "oneOf",
            schemas: n,
            schema: e,
            options: t
        }),
        as: n => nr({
            schema: e,
            ...t
        }, ["type", n]),
        ifThen: (n, r) => {
            if (!qa(n))
                throw new rr("'ifClause' must be a BaseSchema");
            if (!qa(r))
                throw new rr("'thenClause' must be a BaseSchema");
            const s = js(n.valueOf(), ["$schema", "definitions", "type"])
              , o = js(r.valueOf(), ["$schema", "definitions", "type"]);
            return t.factory({
                schema: {
                    ...e,
                    if: Ha({
                        schema: s,
                        ...t,
                        parentId: "#if"
                    }),
                    then: Ha({
                        schema: o,
                        ...t,
                        parentId: "#then"
                    })
                },
                ...t
            })
        }
        ,
        ifThenElse: (n, r, s) => {
            if (!qa(n))
                throw new rr("'ifClause' must be a BaseSchema");
            if (!qa(r))
                throw new rr("'thenClause' must be a BaseSchema");
            if (!qa(s))
                throw new rr("'elseClause' must be a BaseSchema or a false boolean value");
            const o = js(n.valueOf(), ["$schema", "definitions", "type"])
              , c = js(r.valueOf(), ["$schema", "definitions", "type"])
              , l = js(s.valueOf(), ["$schema", "definitions", "type"]);
            return t.factory({
                schema: {
                    ...e,
                    if: Ha({
                        schema: o,
                        ...t,
                        parentId: "#if"
                    }),
                    then: Ha({
                        schema: c,
                        ...t,
                        parentId: "#then"
                    }),
                    else: Ha({
                        schema: l,
                        ...t,
                        parentId: "#else"
                    })
                },
                ...t
            })
        }
        ,
        raw: n => Z$({
            schema: e,
            ...t
        }, n),
        _getState: () => e,
        valueOf: ({isRoot: n}={
            isRoot: !0
        }) => {
            const {properties: r, definitions: s, required: o, $schema: c, ...l} = e;
            if (n && o && !o.every(f => typeof f == "string"))
                throw new rr("'required' has called on root-level schema, check your calls to .required()");
            return Object.assign(c ? {
                $schema: c
            } : {}, Object.keys(s || []).length > 0 ? {
                definitions: M_(s)
            } : void 0, {
                ...js(l, ["if", "then", "else"])
            }, Object.keys(r || []).length > 0 ? {
                properties: M_(r)
            } : void 0, o && o.length > 0 ? {
                required: o
            } : void 0, e.if ? {
                if: e.if
            } : void 0, e.then ? {
                then: e.then
            } : void 0, e.else ? {
                else: e.else
            } : void 0)
        }
    });
    var Is = {
        BaseSchema: Of,
        default: Of
    };
    const {BaseSchema: X$} = Is
      , {setAttribute: Q$, FLUENT_SCHEMA: eR} = Yi
      , tR = {
        type: "null"
    }
      , Zp = ({schema: e=tR, ...t}={}) => {
        t = {
            generateIds: !1,
            factory: Zp,
            ...t
        };
        const {valueOf: n, raw: r} = X$({
            ...t,
            schema: e
        });
        return {
            valueOf: n,
            raw: r,
            [eR]: !0,
            isFluentSchema: !0,
            null: () => Q$({
                schema: e,
                ...t
            }, ["type", "null"])
        }
    }
    ;
    var m1 = {
        NullSchema: Zp,
        default: Zp
    };
    const {BaseSchema: L_} = Is
      , nR = {
        type: "boolean"
    }
      , D_ = ({schema: e=nR, ...t}={}) => (t = {
        generateIds: !1,
        factory: L_,
        ...t
    },
    {
        ...L_({
            ...t,
            schema: e
        })
    });
    var Wm = {
        BooleanSchema: D_,
        default: D_
    };
    const {BaseSchema: rR} = Is
      , {FORMATS: Kp, setAttribute: Ya, FluentSchemaError: Va} = Yi
      , iR = {
        type: "string",
        required: []
    }
      , Jp = ({schema: e, ...t}={
        schema: iR,
        generateIds: !1,
        factory: Jp
    }) => ({
        ...rR({
            ...t,
            schema: e
        }),
        minLength: n => {
            if (!Number.isInteger(n))
                throw new Va("'minLength' must be an Integer");
            return Ya({
                schema: e,
                ...t
            }, ["minLength", n, "string"])
        }
        ,
        maxLength: n => {
            if (!Number.isInteger(n))
                throw new Va("'maxLength' must be an Integer");
            return Ya({
                schema: e,
                ...t
            }, ["maxLength", n, "string"])
        }
        ,
        format: n => {
            if (!Object.values(Kp).includes(n))
                throw new Va(`'format' must be one of ${Object.values(Kp).join(", ")}`);
            return Ya({
                schema: e,
                ...t
            }, ["format", n, "string"])
        }
        ,
        pattern: n => {
            if (typeof n != "string" && !(n instanceof RegExp))
                throw new Va("'pattern' must be a string or a RegEx (e.g. /.*/)");
            if (n instanceof RegExp) {
                const r = new RegExp(n).flags;
                n = n.toString().substr(1).replace(new RegExp(`/${r}$`), "")
            }
            return Ya({
                schema: e,
                ...t
            }, ["pattern", n, "string"])
        }
        ,
        contentEncoding: n => {
            if (typeof n != "string")
                throw new Va("'contentEncoding' must be a string");
            return Ya({
                schema: e,
                ...t
            }, ["contentEncoding", n, "string"])
        }
        ,
        contentMediaType: n => {
            if (typeof n != "string")
                throw new Va("'contentMediaType' must be a string");
            return Ya({
                schema: e,
                ...t
            }, ["contentMediaType", n, "string"])
        }
    });
    var zm = {
        StringSchema: Jp,
        FORMATS: Kp,
        default: Jp
    };
    const {BaseSchema: sR} = Is
      , {setAttribute: Oc, FluentSchemaError: Vr} = Yi
      , aR = {
        type: "number"
    }
      , Xp = ({schema: e, ...t}={
        schema: aR,
        generateIds: !1,
        factory: Xp
    }) => ({
        ...sR({
            ...t,
            schema: e
        }),
        minimum: n => {
            if (typeof n != "number")
                throw new Vr("'minimum' must be a Number");
            if (e.type === "integer" && !Number.isInteger(n))
                throw new Vr("'minimum' must be an Integer");
            return Oc({
                schema: e,
                ...t
            }, ["minimum", n, "number"])
        }
        ,
        exclusiveMinimum: n => {
            if (typeof n != "number")
                throw new Vr("'exclusiveMinimum' must be a Number");
            if (e.type === "integer" && !Number.isInteger(n))
                throw new Vr("'exclusiveMinimum' must be an Integer");
            return Oc({
                schema: e,
                ...t
            }, ["exclusiveMinimum", n, "number"])
        }
        ,
        maximum: n => {
            if (typeof n != "number")
                throw new Vr("'maximum' must be a Number");
            if (e.type === "integer" && !Number.isInteger(n))
                throw new Vr("'maximum' must be an Integer");
            return Oc({
                schema: e,
                ...t
            }, ["maximum", n, "number"])
        }
        ,
        exclusiveMaximum: n => {
            if (typeof n != "number")
                throw new Vr("'exclusiveMaximum' must be a Number");
            if (e.type === "integer" && !Number.isInteger(n))
                throw new Vr("'exclusiveMaximum' must be an Integer");
            return Oc({
                schema: e,
                ...t
            }, ["exclusiveMaximum", n, "number"])
        }
        ,
        multipleOf: n => {
            if (typeof n != "number")
                throw new Vr("'multipleOf' must be a Number");
            if (e.type === "integer" && !Number.isInteger(n))
                throw new Vr("'multipleOf' must be an Integer");
            return Oc({
                schema: e,
                ...t
            }, ["multipleOf", n, "number"])
        }
    });
    var _d = {
        NumberSchema: Xp,
        default: Xp
    };
    const {NumberSchema: oR} = _d
      , cR = {
        type: "integer"
    }
      , Qp = ({schema: e, ...t}={
        schema: cR,
        generateIds: !1,
        factory: Qp
    }) => ({
        ...oR({
            ...t,
            schema: e
        })
    });
    var Gm = {
        IntegerSchema: Qp,
        default: Qp
    };
    const {BaseSchema: uR} = Is
      , {omit: Wa, setAttribute: Ei, isFluentSchema: za, hasCombiningKeywords: lR, patchIdsWithParentId: fR, appendRequired: dR, FluentSchemaError: ir, combineDeepmerge: hR} = Yi
      , pR = {
        type: "object",
        definitions: [],
        properties: [],
        required: []
    }
      , hs = ({schema: e=pR, ...t}={}) => (t = {
        generateIds: !1,
        factory: hs,
        ...t
    },
    {
        ...uR({
            ...t,
            schema: e
        }),
        id: n => {
            if (!n)
                throw new ir("id should not be an empty fragment <#> or an empty string <> (e.g. #myId)");
            return t.factory({
                schema: {
                    ...e,
                    $id: n
                },
                ...t
            })
        }
        ,
        additionalProperties: n => {
            if (typeof n == "boolean")
                return Ei({
                    schema: e,
                    ...t
                }, ["additionalProperties", n, "object"]);
            if (za(n)) {
                const {$schema: r, ...s} = n.valueOf({
                    isRoot: !1
                });
                return Ei({
                    schema: e,
                    ...t
                }, ["additionalProperties", {
                    ...s
                }, "array"])
            }
            throw new ir("'additionalProperties' must be a boolean or a S")
        }
        ,
        maxProperties: n => {
            if (!Number.isInteger(n))
                throw new ir("'maxProperties' must be a Integer");
            return Ei({
                schema: e,
                ...t
            }, ["maxProperties", n, "object"])
        }
        ,
        minProperties: n => {
            if (!Number.isInteger(n))
                throw new ir("'minProperties' must be a Integer");
            return Ei({
                schema: e,
                ...t
            }, ["minProperties", n, "object"])
        }
        ,
        patternProperties: n => {
            const r = Object.entries(n).reduce( (s, [o,c]) => {
                if (!za(c))
                    throw new ir("'patternProperties' invalid options. Provide a valid map e.g. { '^fo.*$': S.string() }");
                return {
                    ...s,
                    [o]: Wa(c.valueOf({
                        isRoot: !1
                    }), ["$schema"])
                }
            }
            , {});
            return Ei({
                schema: e,
                ...t
            }, ["patternProperties", r, "object"])
        }
        ,
        dependencies: n => {
            const r = Object.entries(n).reduce( (s, [o,c]) => {
                if (!za(c) && !Array.isArray(c))
                    throw new ir("'dependencies' invalid options. Provide a valid map e.g. { 'foo': ['bar'] } or { 'foo': S.string() }");
                return {
                    ...s,
                    [o]: Array.isArray(c) ? c : Wa(c.valueOf({
                        isRoot: !1
                    }), ["$schema", "type", "definitions"])
                }
            }
            , {});
            return Ei({
                schema: e,
                ...t
            }, ["dependencies", r, "object"])
        }
        ,
        dependentRequired: n => {
            const r = Object.entries(n).reduce( (s, [o,c]) => {
                if (!Array.isArray(c))
                    throw new ir("'dependentRequired' invalid options. Provide a valid array e.g. { 'foo': ['bar'] }");
                return {
                    ...s,
                    [o]: c
                }
            }
            , {});
            return Ei({
                schema: e,
                ...t
            }, ["dependentRequired", r, "object"])
        }
        ,
        dependentSchemas: n => {
            const r = Object.entries(n).reduce( (s, [o,c]) => {
                if (!za(c))
                    throw new ir("'dependentSchemas' invalid options. Provide a valid schema e.g. { 'foo': S.string() }");
                return {
                    ...s,
                    [o]: Wa(c.valueOf({
                        isRoot: !1
                    }), ["$schema", "type", "definitions"])
                }
            }
            , {});
            return Ei({
                schema: e,
                ...t
            }, ["dependentSchemas", r, "object"])
        }
        ,
        propertyNames: n => {
            if (!za(n))
                throw new ir("'propertyNames' must be a S");
            return Ei({
                schema: e,
                ...t
            }, ["propertyNames", Wa(n.valueOf({
                isRoot: !1
            }), ["$schema"]), "object"])
        }
        ,
        prop: (n, r={}) => {
            if (Array.isArray(r) || typeof r != "object")
                throw new ir(`'${n}' doesn't support value '${JSON.stringify(r)}'. Pass a FluentSchema object`);
            const s = r.def ? "definitions" : "properties";
            let o = r.valueOf({
                isRoot: !1
            });
            const {$ref: c, $id: l, required: f, ...d} = o
              , h = l || (t.generateIds ? `#${s}/${n}` : void 0);
            if (za(r)) {
                o = fR({
                    schema: o,
                    parentId: h,
                    ...t
                });
                const [I,$] = dR({
                    schema: e,
                    attributes: {
                        ...o,
                        name: n
                    }
                });
                e = I,
                o = $
            }
            const y = lR(o) ? void 0 : o.type;
            return o = Object.entries({
                ...o,
                $id: h,
                type: y
            }).reduce( (I, [$,O]) => $ === "$schema" || $ === "def" || O === void 0 || Array.isArray(O) && O.length === 0 && $ !== "default" ? I : {
                ...I,
                [$]: O
            }, {}),
            hs({
                schema: {
                    ...e,
                    [s]: [...e[s], c ? {
                        name: n,
                        $ref: c,
                        ...d
                    } : {
                        name: n,
                        ...o
                    }]
                },
                ...t
            })
        }
        ,
        extend: n => {
            if (!n)
                throw new ir("Schema can't be null or undefined");
            if (!n.isFluentSchema)
                throw new ir("Schema isn't FluentSchema type");
            const r = n._getState()
              , s = hR(r, e)
              , {valueOf: o, isFluentSchema: c, FLUENT_SCHEMA: l, _getState: f, extend: d} = hs({
                schema: s,
                ...t
            });
            return {
                valueOf: o,
                isFluentSchema: c,
                FLUENT_SCHEMA: l,
                _getState: f,
                extend: d
            }
        }
        ,
        only: n => hs({
            schema: {
                ...Wa(e, ["$id", "properties"]),
                properties: e.properties.filter( ({name: r}) => n.includes(r)),
                required: e.required.filter(r => n.includes(r))
            },
            ...t
        }),
        without: n => hs({
            schema: {
                ...Wa(e, ["$id", "properties"]),
                properties: e.properties.filter( ({name: r}) => !n.includes(r)),
                required: e.required.filter(r => !n.includes(r))
            },
            ...t
        }),
        definition: (n, r={}) => hs({
            schema: e,
            ...t
        }).prop(n, {
            ...r.valueOf({
                isRoot: !1
            }),
            def: !0
        })
    });
    var Zm = {
        ObjectSchema: hs,
        default: hs
    };
    const {BaseSchema: mR} = Is
      , {setAttribute: os, isFluentSchema: Ql, FluentSchemaError: Ga} = Yi
      , gR = {
        type: "array",
        definitions: [],
        properties: [],
        required: []
    }
      , em = ({schema: e=gR, ...t}={}) => (t = {
        generateIds: !1,
        factory: em,
        ...t
    },
    {
        ...mR({
            ...t,
            schema: e
        }),
        items: n => {
            if (!Ql(n) && !(Array.isArray(n) && n.filter(o => Ql(o)).length > 0))
                throw new Ga("'items' must be a S or an array of S");
            if (Array.isArray(n)) {
                const o = n.map(c => {
                    const {$schema: l, ...f} = c.valueOf();
                    return f
                }
                );
                return os({
                    schema: e,
                    ...t
                }, ["items", o, "array"])
            }
            const {$schema: r, ...s} = n.valueOf();
            return os({
                schema: e,
                ...t
            }, ["items", {
                ...s
            }, "array"])
        }
        ,
        additionalItems: n => {
            if (typeof n != "boolean" && !Ql(n))
                throw new Ga("'additionalItems' must be a boolean or a S");
            if (n === !1)
                return os({
                    schema: e,
                    ...t
                }, ["additionalItems", !1, "array"]);
            const {$schema: r, ...s} = n.valueOf();
            return os({
                schema: e,
                ...t
            }, ["additionalItems", {
                ...s
            }, "array"])
        }
        ,
        contains: n => {
            if (!Ql(n))
                throw new Ga("'contains' must be a S");
            const {$schema: r, definitions: s, properties: o, required: c, ...l} = n.valueOf();
            return os({
                schema: e,
                ...t
            }, ["contains", {
                ...l
            }, "array"])
        }
        ,
        uniqueItems: n => {
            if (typeof n != "boolean")
                throw new Ga("'uniqueItems' must be a boolean");
            return os({
                schema: e,
                ...t
            }, ["uniqueItems", n, "array"])
        }
        ,
        minItems: n => {
            if (!Number.isInteger(n))
                throw new Ga("'minItems' must be a integer");
            return os({
                schema: e,
                ...t
            }, ["minItems", n, "array"])
        }
        ,
        maxItems: n => {
            if (!Number.isInteger(n))
                throw new Ga("'maxItems' must be a integer");
            return os({
                schema: e,
                ...t
            }, ["maxItems", n, "array"])
        }
    });
    var Km = {
        ArraySchema: em,
        default: em
    };
    const {NullSchema: yR} = m1
      , {BooleanSchema: _R} = Wm
      , {StringSchema: vR} = zm
      , {NumberSchema: wR} = _d
      , {IntegerSchema: bR} = Gm
      , {ObjectSchema: ER} = Zm
      , {ArraySchema: SR} = Km
      , {TYPES: qs, FLUENT_SCHEMA: TR} = Yi
      , AR = {
        type: [],
        definitions: [],
        properties: [],
        required: []
    }
      , Zr = ({schema: e=AR, ...t}={}) => (t = {
        generateIds: !1,
        factory: Zr,
        ...t
    },
    {
        [TR]: !0,
        ...e.type.includes(qs.STRING) ? vR({
            ...t,
            schema: e,
            factory: Zr
        }) : {},
        ...e.type.includes(qs.NUMBER) ? wR({
            ...t,
            schema: e,
            factory: Zr
        }) : {},
        ...e.type.includes(qs.BOOLEAN) ? _R({
            ...t,
            schema: e,
            factory: Zr
        }) : {},
        ...e.type.includes(qs.INTEGER) ? bR({
            ...t,
            schema: e,
            factory: Zr
        }) : {},
        ...e.type.includes(qs.OBJECT) ? ER({
            ...t,
            schema: e,
            factory: Zr
        }) : {},
        ...e.type.includes(qs.ARRAY) ? SR({
            ...t,
            schema: e,
            factory: Zr
        }) : {},
        ...e.type.includes(qs.NULL) ? yR({
            ...t,
            schema: e,
            factory: Zr
        }) : {}
    });
    var OR = {
        MixedSchema: Zr,
        default: Zr
    };
    const {BaseSchema: U_} = Is
      , {BooleanSchema: B_} = Wm
      , {StringSchema: F_} = zm
      , {NumberSchema: pp} = _d
      , {IntegerSchema: IR} = Gm
      , {ObjectSchema: j_} = Zm
      , {ArraySchema: q_} = Km
      , {toArray: H_, FluentSchemaError: NR} = Yi
      , Y_ = (e={}) => {
        if (typeof e != "object")
            throw new NR("A fragment must be a JSON object");
        const {type: t, definitions: n, properties: r, required: s, ...o} = e;
        switch (e.type) {
        case "string":
            {
                const c = {
                    type: t,
                    ...o
                };
                return F_({
                    schema: c,
                    factory: F_
                })
            }
        case "integer":
            {
                const c = {
                    type: t,
                    ...o
                };
                return IR({
                    schema: c,
                    factory: pp
                })
            }
        case "number":
            {
                const c = {
                    type: t,
                    ...o
                };
                return pp({
                    schema: c,
                    factory: pp
                })
            }
        case "boolean":
            {
                const c = {
                    type: t,
                    ...o
                };
                return B_({
                    schema: c,
                    factory: B_
                })
            }
        case "object":
            {
                const c = {
                    type: t,
                    definitions: H_(n) || [],
                    properties: H_(r) || [],
                    required: s || [],
                    ...o
                };
                return j_({
                    schema: c,
                    factory: j_
                })
            }
        case "array":
            {
                const c = {
                    type: t,
                    ...o
                };
                return q_({
                    schema: c,
                    factory: q_
                })
            }
        default:
            {
                const c = {
                    ...o
                };
                return U_({
                    schema: c,
                    factory: U_
                })
            }
        }
    }
    ;
    var xR = {
        RawSchema: Y_,
        default: Y_
    };
    const {FORMATS: $R, TYPES: tm, FluentSchemaError: g1} = Yi
      , {BaseSchema: nm} = Is
      , {NullSchema: V_} = m1
      , {BooleanSchema: W_} = Wm
      , {StringSchema: z_} = zm
      , {NumberSchema: G_} = _d
      , {IntegerSchema: Z_} = Gm
      , {ObjectSchema: K_} = Zm
      , {ArraySchema: J_} = Km
      , {MixedSchema: X_} = OR
      , {RawSchema: RR} = xR
      , PR = {
        $schema: "http://json-schema.org/draft-07/schema#",
        definitions: [],
        properties: [],
        required: []
    }
      , Wr = ({schema: e=PR, ...t}={
        generateIds: !1,
        factory: nm
    }) => ({
        ...nm({
            ...t,
            schema: e
        }),
        string: () => z_({
            ...t,
            schema: e,
            factory: z_
        }).as("string"),
        number: () => G_({
            ...t,
            schema: e,
            factory: G_
        }).as("number"),
        integer: () => Z_({
            ...t,
            schema: e,
            factory: Z_
        }).as("integer"),
        boolean: () => W_({
            ...t,
            schema: e,
            factory: W_
        }).as("boolean"),
        array: () => J_({
            ...t,
            schema: e,
            factory: J_
        }).as("array"),
        object: n => K_({
            ...t,
            schema: n || e,
            factory: K_
        }).as("object"),
        null: () => V_({
            ...t,
            schema: e,
            factory: V_
        }).null(),
        mixed: n => {
            if (!Array.isArray(n) || Array.isArray(n) && n.filter(r => !Object.values(tm).includes(r)).length > 0)
                throw new g1(`Invalid 'types'. It must be an array of types. Valid types are ${Object.values(tm).join(" | ")}`);
            return X_({
                ...t,
                schema: {
                    ...e,
                    type: n
                },
                factory: X_
            })
        }
        ,
        raw: n => RR(n)
    })
      , Jm = {
        ...nm(),
        FORMATS: $R,
        TYPES: tm,
        FluentSchemaError: g1,
        withOptions: Wr,
        string: () => Wr().string(),
        mixed: e => Wr().mixed(e),
        object: () => Wr().object(),
        array: () => Wr().array(),
        boolean: () => Wr().boolean(),
        integer: () => Wr().integer(),
        number: () => Wr().number(),
        null: () => Wr().null(),
        raw: e => Wr().raw(e)
    };
    qm.exports = Jm;
    qm.exports.default = Jm;
    qm.exports.S = Jm;
    function uu() {
        return uu = Object.assign || function(t) {
            for (var n = 1; n < arguments.length; n++) {
                var r = arguments[n];
                for (var s in r)
                    Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
            }
            return t
        }
        ,
        uu.apply(this, arguments)
    }
    class Cu {
        async _create(t, n) {
            return this.axios.request({
                url: t,
                method: "POST",
                data: un(n)
            }).then(r => r.data)
        }
        async _search(t, n) {
            return this.axios.request({
                url: t,
                method: "GET",
                responseType: "json",
                params: n ? new URLSearchParams(ze(n)) : void 0
            }).then(r => r.data)
        }
        async _searchAll(t, n={}) {
            let r = 0
              , s = this.limit
              , o = [];
            do {
                const c = await this._search(t, uu({}, n, {
                    limit: this.limit,
                    offset: r
                }));
                r += this.limit,
                s = c.totalCount,
                o = [...o, ...c.data]
            } while (r <= s);
            return {
                data: o,
                totalCount: s
            }
        }
        async _list(t, n) {
            return this._search(t, n).then(r => r.data)
        }
        async _listAll(t, n) {
            return this._searchAll(t, n).then(r => r.data)
        }
        async _findOne(t, n) {
            return this.axios.request({
                url: t,
                method: "GET",
                params: n ? new URLSearchParams(ze(n)) : void 0
            }).then(r => {
                const s = r.data;
                return s.data ? s.data[0] : void 0
            }
            )
        }
        async _readOne(t, n) {
            return this.axios.request({
                url: t,
                method: "GET",
                params: new URLSearchParams(ze(n))
            }).then(r => {
                const {data: s} = r.data;
                if (!s.length)
                    throw Error("Not found");
                return s[0]
            }
            )
        }
        constructor(t) {
            this.defaultLimit = 50,
            this.limit = 200,
            this.axios = t
        }
    }
    var kR = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i
      , mp = Math.ceil
      , or = Math.floor
      , xn = "[BigNumber Error] "
      , Q_ = xn + "Number primitive has more than 15 significant digits: "
      , Sr = 1e14
      , Ke = 14
      , gp = 9007199254740991
      , yp = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13]
      , cs = 1e7
      , tn = 1e9;
    function y1(e) {
        var t, n, r, s = g.prototype = {
            constructor: g,
            toString: null,
            valueOf: null
        }, o = new g(1), c = 20, l = 4, f = -7, d = 21, h = -1e7, y = 1e7, I = !1, $ = 1, O = 0, A = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "",
            suffix: ""
        }, N = "0123456789abcdefghijklmnopqrstuvwxyz", m = !0;
        function g(_, T) {
            var S, q, C, F, X, v, x, Y, W = this;
            if (!(W instanceof g))
                return new g(_,T);
            if (T == null) {
                if (_ && _._isBigNumber === !0) {
                    W.s = _.s,
                    !_.c || _.e > y ? W.c = W.e = null : _.e < h ? W.c = [W.e = 0] : (W.e = _.e,
                    W.c = _.c.slice());
                    return
                }
                if ((v = typeof _ == "number") && _ * 0 == 0) {
                    if (W.s = 1 / _ < 0 ? (_ = -_,
                    -1) : 1,
                    _ === ~~_) {
                        for (F = 0,
                        X = _; X >= 10; X /= 10,
                        F++)
                            ;
                        F > y ? W.c = W.e = null : (W.e = F,
                        W.c = [_]);
                        return
                    }
                    Y = String(_)
                } else {
                    if (!kR.test(Y = String(_)))
                        return r(W, Y, v);
                    W.s = Y.charCodeAt(0) == 45 ? (Y = Y.slice(1),
                    -1) : 1
                }
                (F = Y.indexOf(".")) > -1 && (Y = Y.replace(".", "")),
                (X = Y.search(/e/i)) > 0 ? (F < 0 && (F = X),
                F += +Y.slice(X + 1),
                Y = Y.substring(0, X)) : F < 0 && (F = Y.length)
            } else {
                if (Mt(T, 2, N.length, "Base"),
                T == 10 && m)
                    return W = new g(_),
                    D(W, c + W.e + 1, l);
                if (Y = String(_),
                v = typeof _ == "number") {
                    if (_ * 0 != 0)
                        return r(W, Y, v, T);
                    if (W.s = 1 / _ < 0 ? (Y = Y.slice(1),
                    -1) : 1,
                    g.DEBUG && Y.replace(/^0\.0*|\./, "").length > 15)
                        throw Error(Q_ + _)
                } else
                    W.s = Y.charCodeAt(0) === 45 ? (Y = Y.slice(1),
                    -1) : 1;
                for (S = N.slice(0, T),
                F = X = 0,
                x = Y.length; X < x; X++)
                    if (S.indexOf(q = Y.charAt(X)) < 0) {
                        if (q == ".") {
                            if (X > F) {
                                F = x;
                                continue
                            }
                        } else if (!C && (Y == Y.toUpperCase() && (Y = Y.toLowerCase()) || Y == Y.toLowerCase() && (Y = Y.toUpperCase()))) {
                            C = !0,
                            X = -1,
                            F = 0;
                            continue
                        }
                        return r(W, String(_), v, T)
                    }
                v = !1,
                Y = n(Y, T, 10, W.s),
                (F = Y.indexOf(".")) > -1 ? Y = Y.replace(".", "") : F = Y.length
            }
            for (X = 0; Y.charCodeAt(X) === 48; X++)
                ;
            for (x = Y.length; Y.charCodeAt(--x) === 48; )
                ;
            if (Y = Y.slice(X, ++x)) {
                if (x -= X,
                v && g.DEBUG && x > 15 && (_ > gp || _ !== or(_)))
                    throw Error(Q_ + W.s * _);
                if ((F = F - X - 1) > y)
                    W.c = W.e = null;
                else if (F < h)
                    W.c = [W.e = 0];
                else {
                    if (W.e = F,
                    W.c = [],
                    X = (F + 1) % Ke,
                    F < 0 && (X += Ke),
                    X < x) {
                        for (X && W.c.push(+Y.slice(0, X)),
                        x -= Ke; X < x; )
                            W.c.push(+Y.slice(X, X += Ke));
                        X = Ke - (Y = Y.slice(X)).length
                    } else
                        X -= x;
                    for (; X--; Y += "0")
                        ;
                    W.c.push(+Y)
                }
            } else
                W.c = [W.e = 0]
        }
        g.clone = y1,
        g.ROUND_UP = 0,
        g.ROUND_DOWN = 1,
        g.ROUND_CEIL = 2,
        g.ROUND_FLOOR = 3,
        g.ROUND_HALF_UP = 4,
        g.ROUND_HALF_DOWN = 5,
        g.ROUND_HALF_EVEN = 6,
        g.ROUND_HALF_CEIL = 7,
        g.ROUND_HALF_FLOOR = 8,
        g.EUCLID = 9,
        g.config = g.set = function(_) {
            var T, S;
            if (_ != null)
                if (typeof _ == "object") {
                    if (_.hasOwnProperty(T = "DECIMAL_PLACES") && (S = _[T],
                    Mt(S, 0, tn, T),
                    c = S),
                    _.hasOwnProperty(T = "ROUNDING_MODE") && (S = _[T],
                    Mt(S, 0, 8, T),
                    l = S),
                    _.hasOwnProperty(T = "EXPONENTIAL_AT") && (S = _[T],
                    S && S.pop ? (Mt(S[0], -tn, 0, T),
                    Mt(S[1], 0, tn, T),
                    f = S[0],
                    d = S[1]) : (Mt(S, -tn, tn, T),
                    f = -(d = S < 0 ? -S : S))),
                    _.hasOwnProperty(T = "RANGE"))
                        if (S = _[T],
                        S && S.pop)
                            Mt(S[0], -tn, -1, T),
                            Mt(S[1], 1, tn, T),
                            h = S[0],
                            y = S[1];
                        else if (Mt(S, -tn, tn, T),
                        S)
                            h = -(y = S < 0 ? -S : S);
                        else
                            throw Error(xn + T + " cannot be zero: " + S);
                    if (_.hasOwnProperty(T = "CRYPTO"))
                        if (S = _[T],
                        S === !!S)
                            if (S)
                                if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                                    I = S;
                                else
                                    throw I = !S,
                                    Error(xn + "crypto unavailable");
                            else
                                I = S;
                        else
                            throw Error(xn + T + " not true or false: " + S);
                    if (_.hasOwnProperty(T = "MODULO_MODE") && (S = _[T],
                    Mt(S, 0, 9, T),
                    $ = S),
                    _.hasOwnProperty(T = "POW_PRECISION") && (S = _[T],
                    Mt(S, 0, tn, T),
                    O = S),
                    _.hasOwnProperty(T = "FORMAT"))
                        if (S = _[T],
                        typeof S == "object")
                            A = S;
                        else
                            throw Error(xn + T + " not an object: " + S);
                    if (_.hasOwnProperty(T = "ALPHABET"))
                        if (S = _[T],
                        typeof S == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(S))
                            m = S.slice(0, 10) == "0123456789",
                            N = S;
                        else
                            throw Error(xn + T + " invalid: " + S)
                } else
                    throw Error(xn + "Object expected: " + _);
            return {
                DECIMAL_PLACES: c,
                ROUNDING_MODE: l,
                EXPONENTIAL_AT: [f, d],
                RANGE: [h, y],
                CRYPTO: I,
                MODULO_MODE: $,
                POW_PRECISION: O,
                FORMAT: A,
                ALPHABET: N
            }
        }
        ,
        g.isBigNumber = function(_) {
            if (!_ || _._isBigNumber !== !0)
                return !1;
            if (!g.DEBUG)
                return !0;
            var T, S, q = _.c, C = _.e, F = _.s;
            e: if ({}.toString.call(q) == "[object Array]") {
                if ((F === 1 || F === -1) && C >= -tn && C <= tn && C === or(C)) {
                    if (q[0] === 0) {
                        if (C === 0 && q.length === 1)
                            return !0;
                        break e
                    }
                    if (T = (C + 1) % Ke,
                    T < 1 && (T += Ke),
                    String(q[0]).length == T) {
                        for (T = 0; T < q.length; T++)
                            if (S = q[T],
                            S < 0 || S >= Sr || S !== or(S))
                                break e;
                        if (S !== 0)
                            return !0
                    }
                }
            } else if (q === null && C === null && (F === null || F === 1 || F === -1))
                return !0;
            throw Error(xn + "Invalid BigNumber: " + _)
        }
        ,
        g.maximum = g.max = function() {
            return G(arguments, -1)
        }
        ,
        g.minimum = g.min = function() {
            return G(arguments, 1)
        }
        ,
        g.random = function() {
            var _ = 9007199254740992
              , T = Math.random() * _ & 2097151 ? function() {
                return or(Math.random() * _)
            }
            : function() {
                return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
            }
            ;
            return function(S) {
                var q, C, F, X, v, x = 0, Y = [], W = new g(o);
                if (S == null ? S = c : Mt(S, 0, tn),
                X = mp(S / Ke),
                I)
                    if (crypto.getRandomValues) {
                        for (q = crypto.getRandomValues(new Uint32Array(X *= 2)); x < X; )
                            v = q[x] * 131072 + (q[x + 1] >>> 11),
                            v >= 9e15 ? (C = crypto.getRandomValues(new Uint32Array(2)),
                            q[x] = C[0],
                            q[x + 1] = C[1]) : (Y.push(v % 1e14),
                            x += 2);
                        x = X / 2
                    } else if (crypto.randomBytes) {
                        for (q = crypto.randomBytes(X *= 7); x < X; )
                            v = (q[x] & 31) * 281474976710656 + q[x + 1] * 1099511627776 + q[x + 2] * 4294967296 + q[x + 3] * 16777216 + (q[x + 4] << 16) + (q[x + 5] << 8) + q[x + 6],
                            v >= 9e15 ? crypto.randomBytes(7).copy(q, x) : (Y.push(v % 1e14),
                            x += 7);
                        x = X / 7
                    } else
                        throw I = !1,
                        Error(xn + "crypto unavailable");
                if (!I)
                    for (; x < X; )
                        v = T(),
                        v < 9e15 && (Y[x++] = v % 1e14);
                for (X = Y[--x],
                S %= Ke,
                X && S && (v = yp[Ke - S],
                Y[x] = or(X / v) * v); Y[x] === 0; Y.pop(),
                x--)
                    ;
                if (x < 0)
                    Y = [F = 0];
                else {
                    for (F = -1; Y[0] === 0; Y.splice(0, 1),
                    F -= Ke)
                        ;
                    for (x = 1,
                    v = Y[0]; v >= 10; v /= 10,
                    x++)
                        ;
                    x < Ke && (F -= Ke - x)
                }
                return W.e = F,
                W.c = Y,
                W
            }
        }(),
        g.sum = function() {
            for (var _ = 1, T = arguments, S = new g(T[0]); _ < T.length; )
                S = S.plus(T[_++]);
            return S
        }
        ,
        n = function() {
            var _ = "0123456789";
            function T(S, q, C, F) {
                for (var X, v = [0], x, Y = 0, W = S.length; Y < W; ) {
                    for (x = v.length; x--; v[x] *= q)
                        ;
                    for (v[0] += F.indexOf(S.charAt(Y++)),
                    X = 0; X < v.length; X++)
                        v[X] > C - 1 && (v[X + 1] == null && (v[X + 1] = 0),
                        v[X + 1] += v[X] / C | 0,
                        v[X] %= C)
                }
                return v.reverse()
            }
            return function(S, q, C, F, X) {
                var v, x, Y, W, te, J, H, ae, Q = S.indexOf("."), P = c, j = l;
                for (Q >= 0 && (W = O,
                O = 0,
                S = S.replace(".", ""),
                ae = new g(q),
                J = ae.pow(S.length - Q),
                O = W,
                ae.c = T(Si(sr(J.c), J.e, "0"), 10, C, _),
                ae.e = ae.c.length),
                H = T(S, q, C, X ? (v = N,
                _) : (v = _,
                N)),
                Y = W = H.length; H[--W] == 0; H.pop())
                    ;
                if (!H[0])
                    return v.charAt(0);
                if (Q < 0 ? --Y : (J.c = H,
                J.e = Y,
                J.s = F,
                J = t(J, ae, P, j, C),
                H = J.c,
                te = J.r,
                Y = J.e),
                x = Y + P + 1,
                Q = H[x],
                W = C / 2,
                te = te || x < 0 || H[x + 1] != null,
                te = j < 4 ? (Q != null || te) && (j == 0 || j == (J.s < 0 ? 3 : 2)) : Q > W || Q == W && (j == 4 || te || j == 6 && H[x - 1] & 1 || j == (J.s < 0 ? 8 : 7)),
                x < 1 || !H[0])
                    S = te ? Si(v.charAt(1), -P, v.charAt(0)) : v.charAt(0);
                else {
                    if (H.length = x,
                    te)
                        for (--C; ++H[--x] > C; )
                            H[x] = 0,
                            x || (++Y,
                            H = [1].concat(H));
                    for (W = H.length; !H[--W]; )
                        ;
                    for (Q = 0,
                    S = ""; Q <= W; S += v.charAt(H[Q++]))
                        ;
                    S = Si(S, Y, v.charAt(0))
                }
                return S
            }
        }(),
        t = function() {
            function _(q, C, F) {
                var X, v, x, Y, W = 0, te = q.length, J = C % cs, H = C / cs | 0;
                for (q = q.slice(); te--; )
                    x = q[te] % cs,
                    Y = q[te] / cs | 0,
                    X = H * x + Y * J,
                    v = J * x + X % cs * cs + W,
                    W = (v / F | 0) + (X / cs | 0) + H * Y,
                    q[te] = v % F;
                return W && (q = [W].concat(q)),
                q
            }
            function T(q, C, F, X) {
                var v, x;
                if (F != X)
                    x = F > X ? 1 : -1;
                else
                    for (v = x = 0; v < F; v++)
                        if (q[v] != C[v]) {
                            x = q[v] > C[v] ? 1 : -1;
                            break
                        }
                return x
            }
            function S(q, C, F, X) {
                for (var v = 0; F--; )
                    q[F] -= v,
                    v = q[F] < C[F] ? 1 : 0,
                    q[F] = v * X + q[F] - C[F];
                for (; !q[0] && q.length > 1; q.splice(0, 1))
                    ;
            }
            return function(q, C, F, X, v) {
                var x, Y, W, te, J, H, ae, Q, P, j, se, ye, we, De, Re, tt, vt, bt = q.s == C.s ? 1 : -1, st = q.c, ct = C.c;
                if (!st || !st[0] || !ct || !ct[0])
                    return new g(!q.s || !C.s || (st ? ct && st[0] == ct[0] : !ct) ? NaN : st && st[0] == 0 || !ct ? bt * 0 : bt / 0);
                for (Q = new g(bt),
                P = Q.c = [],
                Y = q.e - C.e,
                bt = F + Y + 1,
                v || (v = Sr,
                Y = cr(q.e / Ke) - cr(C.e / Ke),
                bt = bt / Ke | 0),
                W = 0; ct[W] == (st[W] || 0); W++)
                    ;
                if (ct[W] > (st[W] || 0) && Y--,
                bt < 0)
                    P.push(1),
                    te = !0;
                else {
                    for (De = st.length,
                    tt = ct.length,
                    W = 0,
                    bt += 2,
                    J = or(v / (ct[0] + 1)),
                    J > 1 && (ct = _(ct, J, v),
                    st = _(st, J, v),
                    tt = ct.length,
                    De = st.length),
                    we = tt,
                    j = st.slice(0, tt),
                    se = j.length; se < tt; j[se++] = 0)
                        ;
                    vt = ct.slice(),
                    vt = [0].concat(vt),
                    Re = ct[0],
                    ct[1] >= v / 2 && Re++;
                    do {
                        if (J = 0,
                        x = T(ct, j, tt, se),
                        x < 0) {
                            if (ye = j[0],
                            tt != se && (ye = ye * v + (j[1] || 0)),
                            J = or(ye / Re),
                            J > 1)
                                for (J >= v && (J = v - 1),
                                H = _(ct, J, v),
                                ae = H.length,
                                se = j.length; T(H, j, ae, se) == 1; )
                                    J--,
                                    S(H, tt < ae ? vt : ct, ae, v),
                                    ae = H.length,
                                    x = 1;
                            else
                                J == 0 && (x = J = 1),
                                H = ct.slice(),
                                ae = H.length;
                            if (ae < se && (H = [0].concat(H)),
                            S(j, H, se, v),
                            se = j.length,
                            x == -1)
                                for (; T(ct, j, tt, se) < 1; )
                                    J++,
                                    S(j, tt < se ? vt : ct, se, v),
                                    se = j.length
                        } else
                            x === 0 && (J++,
                            j = [0]);
                        P[W++] = J,
                        j[0] ? j[se++] = st[we] || 0 : (j = [st[we]],
                        se = 1)
                    } while ((we++ < De || j[0] != null) && bt--);
                    te = j[0] != null,
                    P[0] || P.splice(0, 1)
                }
                if (v == Sr) {
                    for (W = 1,
                    bt = P[0]; bt >= 10; bt /= 10,
                    W++)
                        ;
                    D(Q, F + (Q.e = W + Y * Ke - 1) + 1, X, te)
                } else
                    Q.e = Y,
                    Q.r = +te;
                return Q
            }
        }();
        function M(_, T, S, q) {
            var C, F, X, v, x;
            if (S == null ? S = l : Mt(S, 0, 8),
            !_.c)
                return _.toString();
            if (C = _.c[0],
            X = _.e,
            T == null)
                x = sr(_.c),
                x = q == 1 || q == 2 && (X <= f || X >= d) ? tf(x, X) : Si(x, X, "0");
            else if (_ = D(new g(_), T, S),
            F = _.e,
            x = sr(_.c),
            v = x.length,
            q == 1 || q == 2 && (T <= F || F <= f)) {
                for (; v < T; x += "0",
                v++)
                    ;
                x = tf(x, F)
            } else if (T -= X,
            x = Si(x, F, "0"),
            F + 1 > v) {
                if (--T > 0)
                    for (x += "."; T--; x += "0")
                        ;
            } else if (T += F - v,
            T > 0)
                for (F + 1 == v && (x += "."); T--; x += "0")
                    ;
            return _.s < 0 && C ? "-" + x : x
        }
        function G(_, T) {
            for (var S, q, C = 1, F = new g(_[0]); C < _.length; C++)
                q = new g(_[C]),
                (!q.s || (S = Hs(F, q)) === T || S === 0 && F.s === T) && (F = q);
            return F
        }
        function U(_, T, S) {
            for (var q = 1, C = T.length; !T[--C]; T.pop())
                ;
            for (C = T[0]; C >= 10; C /= 10,
            q++)
                ;
            return (S = q + S * Ke - 1) > y ? _.c = _.e = null : S < h ? _.c = [_.e = 0] : (_.e = S,
            _.c = T),
            _
        }
        r = function() {
            var _ = /^(-?)0([xbo])(?=\w[\w.]*$)/i
              , T = /^([^.]+)\.$/
              , S = /^\.([^.]+)$/
              , q = /^-?(Infinity|NaN)$/
              , C = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(F, X, v, x) {
                var Y, W = v ? X : X.replace(C, "");
                if (q.test(W))
                    F.s = isNaN(W) ? null : W < 0 ? -1 : 1;
                else {
                    if (!v && (W = W.replace(_, function(te, J, H) {
                        return Y = (H = H.toLowerCase()) == "x" ? 16 : H == "b" ? 2 : 8,
                        !x || x == Y ? J : te
                    }),
                    x && (Y = x,
                    W = W.replace(T, "$1").replace(S, "0.$1")),
                    X != W))
                        return new g(W,Y);
                    if (g.DEBUG)
                        throw Error(xn + "Not a" + (x ? " base " + x : "") + " number: " + X);
                    F.s = null
                }
                F.c = F.e = null
            }
        }();
        function D(_, T, S, q) {
            var C, F, X, v, x, Y, W, te = _.c, J = yp;
            if (te) {
                e: {
                    for (C = 1,
                    v = te[0]; v >= 10; v /= 10,
                    C++)
                        ;
                    if (F = T - C,
                    F < 0)
                        F += Ke,
                        X = T,
                        x = te[Y = 0],
                        W = or(x / J[C - X - 1] % 10);
                    else if (Y = mp((F + 1) / Ke),
                    Y >= te.length)
                        if (q) {
                            for (; te.length <= Y; te.push(0))
                                ;
                            x = W = 0,
                            C = 1,
                            F %= Ke,
                            X = F - Ke + 1
                        } else
                            break e;
                    else {
                        for (x = v = te[Y],
                        C = 1; v >= 10; v /= 10,
                        C++)
                            ;
                        F %= Ke,
                        X = F - Ke + C,
                        W = X < 0 ? 0 : or(x / J[C - X - 1] % 10)
                    }
                    if (q = q || T < 0 || te[Y + 1] != null || (X < 0 ? x : x % J[C - X - 1]),
                    q = S < 4 ? (W || q) && (S == 0 || S == (_.s < 0 ? 3 : 2)) : W > 5 || W == 5 && (S == 4 || q || S == 6 && (F > 0 ? X > 0 ? x / J[C - X] : 0 : te[Y - 1]) % 10 & 1 || S == (_.s < 0 ? 8 : 7)),
                    T < 1 || !te[0])
                        return te.length = 0,
                        q ? (T -= _.e + 1,
                        te[0] = J[(Ke - T % Ke) % Ke],
                        _.e = -T || 0) : te[0] = _.e = 0,
                        _;
                    if (F == 0 ? (te.length = Y,
                    v = 1,
                    Y--) : (te.length = Y + 1,
                    v = J[Ke - F],
                    te[Y] = X > 0 ? or(x / J[C - X] % J[X]) * v : 0),
                    q)
                        for (; ; )
                            if (Y == 0) {
                                for (F = 1,
                                X = te[0]; X >= 10; X /= 10,
                                F++)
                                    ;
                                for (X = te[0] += v,
                                v = 1; X >= 10; X /= 10,
                                v++)
                                    ;
                                F != v && (_.e++,
                                te[0] == Sr && (te[0] = 1));
                                break
                            } else {
                                if (te[Y] += v,
                                te[Y] != Sr)
                                    break;
                                te[Y--] = 0,
                                v = 1
                            }
                    for (F = te.length; te[--F] === 0; te.pop())
                        ;
                }
                _.e > y ? _.c = _.e = null : _.e < h && (_.c = [_.e = 0])
            }
            return _
        }
        function K(_) {
            var T, S = _.e;
            return S === null ? _.toString() : (T = sr(_.c),
            T = S <= f || S >= d ? tf(T, S) : Si(T, S, "0"),
            _.s < 0 ? "-" + T : T)
        }
        return s.absoluteValue = s.abs = function() {
            var _ = new g(this);
            return _.s < 0 && (_.s = 1),
            _
        }
        ,
        s.comparedTo = function(_, T) {
            return Hs(this, new g(_,T))
        }
        ,
        s.decimalPlaces = s.dp = function(_, T) {
            var S, q, C, F = this;
            if (_ != null)
                return Mt(_, 0, tn),
                T == null ? T = l : Mt(T, 0, 8),
                D(new g(F), _ + F.e + 1, T);
            if (!(S = F.c))
                return null;
            if (q = ((C = S.length - 1) - cr(this.e / Ke)) * Ke,
            C = S[C])
                for (; C % 10 == 0; C /= 10,
                q--)
                    ;
            return q < 0 && (q = 0),
            q
        }
        ,
        s.dividedBy = s.div = function(_, T) {
            return t(this, new g(_,T), c, l)
        }
        ,
        s.dividedToIntegerBy = s.idiv = function(_, T) {
            return t(this, new g(_,T), 0, 1)
        }
        ,
        s.exponentiatedBy = s.pow = function(_, T) {
            var S, q, C, F, X, v, x, Y, W, te = this;
            if (_ = new g(_),
            _.c && !_.isInteger())
                throw Error(xn + "Exponent not an integer: " + K(_));
            if (T != null && (T = new g(T)),
            v = _.e > 14,
            !te.c || !te.c[0] || te.c[0] == 1 && !te.e && te.c.length == 1 || !_.c || !_.c[0])
                return W = new g(Math.pow(+K(te), v ? _.s * (2 - ef(_)) : +K(_))),
                T ? W.mod(T) : W;
            if (x = _.s < 0,
            T) {
                if (T.c ? !T.c[0] : !T.s)
                    return new g(NaN);
                q = !x && te.isInteger() && T.isInteger(),
                q && (te = te.mod(T))
            } else {
                if (_.e > 9 && (te.e > 0 || te.e < -1 || (te.e == 0 ? te.c[0] > 1 || v && te.c[1] >= 24e7 : te.c[0] < 8e13 || v && te.c[0] <= 9999975e7)))
                    return F = te.s < 0 && ef(_) ? -0 : 0,
                    te.e > -1 && (F = 1 / F),
                    new g(x ? 1 / F : F);
                O && (F = mp(O / Ke + 2))
            }
            for (v ? (S = new g(.5),
            x && (_.s = 1),
            Y = ef(_)) : (C = Math.abs(+K(_)),
            Y = C % 2),
            W = new g(o); ; ) {
                if (Y) {
                    if (W = W.times(te),
                    !W.c)
                        break;
                    F ? W.c.length > F && (W.c.length = F) : q && (W = W.mod(T))
                }
                if (C) {
                    if (C = or(C / 2),
                    C === 0)
                        break;
                    Y = C % 2
                } else if (_ = _.times(S),
                D(_, _.e + 1, 1),
                _.e > 14)
                    Y = ef(_);
                else {
                    if (C = +K(_),
                    C === 0)
                        break;
                    Y = C % 2
                }
                te = te.times(te),
                F ? te.c && te.c.length > F && (te.c.length = F) : q && (te = te.mod(T))
            }
            return q ? W : (x && (W = o.div(W)),
            T ? W.mod(T) : F ? D(W, O, l, X) : W)
        }
        ,
        s.integerValue = function(_) {
            var T = new g(this);
            return _ == null ? _ = l : Mt(_, 0, 8),
            D(T, T.e + 1, _)
        }
        ,
        s.isEqualTo = s.eq = function(_, T) {
            return Hs(this, new g(_,T)) === 0
        }
        ,
        s.isFinite = function() {
            return !!this.c
        }
        ,
        s.isGreaterThan = s.gt = function(_, T) {
            return Hs(this, new g(_,T)) > 0
        }
        ,
        s.isGreaterThanOrEqualTo = s.gte = function(_, T) {
            return (T = Hs(this, new g(_,T))) === 1 || T === 0
        }
        ,
        s.isInteger = function() {
            return !!this.c && cr(this.e / Ke) > this.c.length - 2
        }
        ,
        s.isLessThan = s.lt = function(_, T) {
            return Hs(this, new g(_,T)) < 0
        }
        ,
        s.isLessThanOrEqualTo = s.lte = function(_, T) {
            return (T = Hs(this, new g(_,T))) === -1 || T === 0
        }
        ,
        s.isNaN = function() {
            return !this.s
        }
        ,
        s.isNegative = function() {
            return this.s < 0
        }
        ,
        s.isPositive = function() {
            return this.s > 0
        }
        ,
        s.isZero = function() {
            return !!this.c && this.c[0] == 0
        }
        ,
        s.minus = function(_, T) {
            var S, q, C, F, X = this, v = X.s;
            if (_ = new g(_,T),
            T = _.s,
            !v || !T)
                return new g(NaN);
            if (v != T)
                return _.s = -T,
                X.plus(_);
            var x = X.e / Ke
              , Y = _.e / Ke
              , W = X.c
              , te = _.c;
            if (!x || !Y) {
                if (!W || !te)
                    return W ? (_.s = -T,
                    _) : new g(te ? X : NaN);
                if (!W[0] || !te[0])
                    return te[0] ? (_.s = -T,
                    _) : new g(W[0] ? X : l == 3 ? -0 : 0)
            }
            if (x = cr(x),
            Y = cr(Y),
            W = W.slice(),
            v = x - Y) {
                for ((F = v < 0) ? (v = -v,
                C = W) : (Y = x,
                C = te),
                C.reverse(),
                T = v; T--; C.push(0))
                    ;
                C.reverse()
            } else
                for (q = (F = (v = W.length) < (T = te.length)) ? v : T,
                v = T = 0; T < q; T++)
                    if (W[T] != te[T]) {
                        F = W[T] < te[T];
                        break
                    }
            if (F && (C = W,
            W = te,
            te = C,
            _.s = -_.s),
            T = (q = te.length) - (S = W.length),
            T > 0)
                for (; T--; W[S++] = 0)
                    ;
            for (T = Sr - 1; q > v; ) {
                if (W[--q] < te[q]) {
                    for (S = q; S && !W[--S]; W[S] = T)
                        ;
                    --W[S],
                    W[q] += Sr
                }
                W[q] -= te[q]
            }
            for (; W[0] == 0; W.splice(0, 1),
            --Y)
                ;
            return W[0] ? U(_, W, Y) : (_.s = l == 3 ? -1 : 1,
            _.c = [_.e = 0],
            _)
        }
        ,
        s.modulo = s.mod = function(_, T) {
            var S, q, C = this;
            return _ = new g(_,T),
            !C.c || !_.s || _.c && !_.c[0] ? new g(NaN) : !_.c || C.c && !C.c[0] ? new g(C) : ($ == 9 ? (q = _.s,
            _.s = 1,
            S = t(C, _, 0, 3),
            _.s = q,
            S.s *= q) : S = t(C, _, 0, $),
            _ = C.minus(S.times(_)),
            !_.c[0] && $ == 1 && (_.s = C.s),
            _)
        }
        ,
        s.multipliedBy = s.times = function(_, T) {
            var S, q, C, F, X, v, x, Y, W, te, J, H, ae, Q, P, j = this, se = j.c, ye = (_ = new g(_,T)).c;
            if (!se || !ye || !se[0] || !ye[0])
                return !j.s || !_.s || se && !se[0] && !ye || ye && !ye[0] && !se ? _.c = _.e = _.s = null : (_.s *= j.s,
                !se || !ye ? _.c = _.e = null : (_.c = [0],
                _.e = 0)),
                _;
            for (q = cr(j.e / Ke) + cr(_.e / Ke),
            _.s *= j.s,
            x = se.length,
            te = ye.length,
            x < te && (ae = se,
            se = ye,
            ye = ae,
            C = x,
            x = te,
            te = C),
            C = x + te,
            ae = []; C--; ae.push(0))
                ;
            for (Q = Sr,
            P = cs,
            C = te; --C >= 0; ) {
                for (S = 0,
                J = ye[C] % P,
                H = ye[C] / P | 0,
                X = x,
                F = C + X; F > C; )
                    Y = se[--X] % P,
                    W = se[X] / P | 0,
                    v = H * Y + W * J,
                    Y = J * Y + v % P * P + ae[F] + S,
                    S = (Y / Q | 0) + (v / P | 0) + H * W,
                    ae[F--] = Y % Q;
                ae[F] = S
            }
            return S ? ++q : ae.splice(0, 1),
            U(_, ae, q)
        }
        ,
        s.negated = function() {
            var _ = new g(this);
            return _.s = -_.s || null,
            _
        }
        ,
        s.plus = function(_, T) {
            var S, q = this, C = q.s;
            if (_ = new g(_,T),
            T = _.s,
            !C || !T)
                return new g(NaN);
            if (C != T)
                return _.s = -T,
                q.minus(_);
            var F = q.e / Ke
              , X = _.e / Ke
              , v = q.c
              , x = _.c;
            if (!F || !X) {
                if (!v || !x)
                    return new g(C / 0);
                if (!v[0] || !x[0])
                    return x[0] ? _ : new g(v[0] ? q : C * 0)
            }
            if (F = cr(F),
            X = cr(X),
            v = v.slice(),
            C = F - X) {
                for (C > 0 ? (X = F,
                S = x) : (C = -C,
                S = v),
                S.reverse(); C--; S.push(0))
                    ;
                S.reverse()
            }
            for (C = v.length,
            T = x.length,
            C - T < 0 && (S = x,
            x = v,
            v = S,
            T = C),
            C = 0; T; )
                C = (v[--T] = v[T] + x[T] + C) / Sr | 0,
                v[T] = Sr === v[T] ? 0 : v[T] % Sr;
            return C && (v = [C].concat(v),
            ++X),
            U(_, v, X)
        }
        ,
        s.precision = s.sd = function(_, T) {
            var S, q, C, F = this;
            if (_ != null && _ !== !!_)
                return Mt(_, 1, tn),
                T == null ? T = l : Mt(T, 0, 8),
                D(new g(F), _, T);
            if (!(S = F.c))
                return null;
            if (C = S.length - 1,
            q = C * Ke + 1,
            C = S[C]) {
                for (; C % 10 == 0; C /= 10,
                q--)
                    ;
                for (C = S[0]; C >= 10; C /= 10,
                q++)
                    ;
            }
            return _ && F.e + 1 > q && (q = F.e + 1),
            q
        }
        ,
        s.shiftedBy = function(_) {
            return Mt(_, -gp, gp),
            this.times("1e" + _)
        }
        ,
        s.squareRoot = s.sqrt = function() {
            var _, T, S, q, C, F = this, X = F.c, v = F.s, x = F.e, Y = c + 4, W = new g("0.5");
            if (v !== 1 || !X || !X[0])
                return new g(!v || v < 0 && (!X || X[0]) ? NaN : X ? F : 1 / 0);
            if (v = Math.sqrt(+K(F)),
            v == 0 || v == 1 / 0 ? (T = sr(X),
            (T.length + x) % 2 == 0 && (T += "0"),
            v = Math.sqrt(+T),
            x = cr((x + 1) / 2) - (x < 0 || x % 2),
            v == 1 / 0 ? T = "5e" + x : (T = v.toExponential(),
            T = T.slice(0, T.indexOf("e") + 1) + x),
            S = new g(T)) : S = new g(v + ""),
            S.c[0]) {
                for (x = S.e,
                v = x + Y,
                v < 3 && (v = 0); ; )
                    if (C = S,
                    S = W.times(C.plus(t(F, C, Y, 1))),
                    sr(C.c).slice(0, v) === (T = sr(S.c)).slice(0, v))
                        if (S.e < x && --v,
                        T = T.slice(v - 3, v + 1),
                        T == "9999" || !q && T == "4999") {
                            if (!q && (D(C, C.e + c + 2, 0),
                            C.times(C).eq(F))) {
                                S = C;
                                break
                            }
                            Y += 4,
                            v += 4,
                            q = 1
                        } else {
                            (!+T || !+T.slice(1) && T.charAt(0) == "5") && (D(S, S.e + c + 2, 1),
                            _ = !S.times(S).eq(F));
                            break
                        }
            }
            return D(S, S.e + c + 1, l, _)
        }
        ,
        s.toExponential = function(_, T) {
            return _ != null && (Mt(_, 0, tn),
            _++),
            M(this, _, T, 1)
        }
        ,
        s.toFixed = function(_, T) {
            return _ != null && (Mt(_, 0, tn),
            _ = _ + this.e + 1),
            M(this, _, T)
        }
        ,
        s.toFormat = function(_, T, S) {
            var q, C = this;
            if (S == null)
                _ != null && T && typeof T == "object" ? (S = T,
                T = null) : _ && typeof _ == "object" ? (S = _,
                _ = T = null) : S = A;
            else if (typeof S != "object")
                throw Error(xn + "Argument not an object: " + S);
            if (q = C.toFixed(_, T),
            C.c) {
                var F, X = q.split("."), v = +S.groupSize, x = +S.secondaryGroupSize, Y = S.groupSeparator || "", W = X[0], te = X[1], J = C.s < 0, H = J ? W.slice(1) : W, ae = H.length;
                if (x && (F = v,
                v = x,
                x = F,
                ae -= F),
                v > 0 && ae > 0) {
                    for (F = ae % v || v,
                    W = H.substr(0, F); F < ae; F += v)
                        W += Y + H.substr(F, v);
                    x > 0 && (W += Y + H.slice(F)),
                    J && (W = "-" + W)
                }
                q = te ? W + (S.decimalSeparator || "") + ((x = +S.fractionGroupSize) ? te.replace(new RegExp("\\d{" + x + "}\\B","g"), "$&" + (S.fractionGroupSeparator || "")) : te) : W
            }
            return (S.prefix || "") + q + (S.suffix || "")
        }
        ,
        s.toFraction = function(_) {
            var T, S, q, C, F, X, v, x, Y, W, te, J, H = this, ae = H.c;
            if (_ != null && (v = new g(_),
            !v.isInteger() && (v.c || v.s !== 1) || v.lt(o)))
                throw Error(xn + "Argument " + (v.isInteger() ? "out of range: " : "not an integer: ") + K(v));
            if (!ae)
                return new g(H);
            for (T = new g(o),
            Y = S = new g(o),
            q = x = new g(o),
            J = sr(ae),
            F = T.e = J.length - H.e - 1,
            T.c[0] = yp[(X = F % Ke) < 0 ? Ke + X : X],
            _ = !_ || v.comparedTo(T) > 0 ? F > 0 ? T : Y : v,
            X = y,
            y = 1 / 0,
            v = new g(J),
            x.c[0] = 0; W = t(v, T, 0, 1),
            C = S.plus(W.times(q)),
            C.comparedTo(_) != 1; )
                S = q,
                q = C,
                Y = x.plus(W.times(C = Y)),
                x = C,
                T = v.minus(W.times(C = T)),
                v = C;
            return C = t(_.minus(S), q, 0, 1),
            x = x.plus(C.times(Y)),
            S = S.plus(C.times(q)),
            x.s = Y.s = H.s,
            F = F * 2,
            te = t(Y, q, F, l).minus(H).abs().comparedTo(t(x, S, F, l).minus(H).abs()) < 1 ? [Y, q] : [x, S],
            y = X,
            te
        }
        ,
        s.toNumber = function() {
            return +K(this)
        }
        ,
        s.toPrecision = function(_, T) {
            return _ != null && Mt(_, 1, tn),
            M(this, _, T, 2)
        }
        ,
        s.toString = function(_) {
            var T, S = this, q = S.s, C = S.e;
            return C === null ? q ? (T = "Infinity",
            q < 0 && (T = "-" + T)) : T = "NaN" : (_ == null ? T = C <= f || C >= d ? tf(sr(S.c), C) : Si(sr(S.c), C, "0") : _ === 10 && m ? (S = D(new g(S), c + C + 1, l),
            T = Si(sr(S.c), S.e, "0")) : (Mt(_, 2, N.length, "Base"),
            T = n(Si(sr(S.c), C, "0"), 10, _, q, !0)),
            q < 0 && S.c[0] && (T = "-" + T)),
            T
        }
        ,
        s.valueOf = s.toJSON = function() {
            return K(this)
        }
        ,
        s._isBigNumber = !0,
        s[Symbol.toStringTag] = "BigNumber",
        s[Symbol.for("nodejs.util.inspect.custom")] = s.valueOf,
        e != null && g.set(e),
        g
    }
    function cr(e) {
        var t = e | 0;
        return e > 0 || e === t ? t : t - 1
    }
    function sr(e) {
        for (var t, n, r = 1, s = e.length, o = e[0] + ""; r < s; ) {
            for (t = e[r++] + "",
            n = Ke - t.length; n--; t = "0" + t)
                ;
            o += t
        }
        for (s = o.length; o.charCodeAt(--s) === 48; )
            ;
        return o.slice(0, s + 1 || 1)
    }
    function Hs(e, t) {
        var n, r, s = e.c, o = t.c, c = e.s, l = t.s, f = e.e, d = t.e;
        if (!c || !l)
            return null;
        if (n = s && !s[0],
        r = o && !o[0],
        n || r)
            return n ? r ? 0 : -l : c;
        if (c != l)
            return c;
        if (n = c < 0,
        r = f == d,
        !s || !o)
            return r ? 0 : !s ^ n ? 1 : -1;
        if (!r)
            return f > d ^ n ? 1 : -1;
        for (l = (f = s.length) < (d = o.length) ? f : d,
        c = 0; c < l; c++)
            if (s[c] != o[c])
                return s[c] > o[c] ^ n ? 1 : -1;
        return f == d ? 0 : f > d ^ n ? 1 : -1
    }
    function Mt(e, t, n, r) {
        if (e < t || e > n || e !== or(e))
            throw Error(xn + (r || "Argument") + (typeof e == "number" ? e < t || e > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e))
    }
    function ef(e) {
        var t = e.c.length - 1;
        return cr(e.e / Ke) == t && e.c[t] % 2 != 0
    }
    function tf(e, t) {
        return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t
    }
    function Si(e, t, n) {
        var r, s;
        if (t < 0) {
            for (s = n + "."; ++t; s += n)
                ;
            e = s + e
        } else if (r = e.length,
        ++t > r) {
            for (s = n,
            t -= r; --t; s += n)
                ;
            e += s
        } else
            t < r && (e = e.slice(0, t) + "." + e.slice(t));
        return e
    }
    y1();
    function ze(e) {
        return Object.keys(e).map(t => {
            if (Array.isArray(e[t])) {
                const n = e[t].map(r => encodeURIComponent(r)).join(",");
                return encodeURIComponent(t) + "=" + n
            } else if (["string", "number"].includes(typeof e[t]))
                return encodeURIComponent(t) + "=" + encodeURIComponent(e[t]);
            return ""
        }
        ).join("&")
    }
    //! moment.js
    //! version : 2.30.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var _1;
    function Ee() {
        return _1.apply(null, arguments)
    }
    function CR(e) {
        _1 = e
    }
    function Mr(e) {
        return e instanceof Array || Object.prototype.toString.call(e) === "[object Array]"
    }
    function na(e) {
        return e != null && Object.prototype.toString.call(e) === "[object Object]"
    }
    function mt(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    function Xm(e) {
        if (Object.getOwnPropertyNames)
            return Object.getOwnPropertyNames(e).length === 0;
        var t;
        for (t in e)
            if (mt(e, t))
                return !1;
        return !0
    }
    function $n(e) {
        return e === void 0
    }
    function Bi(e) {
        return typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]"
    }
    function Mu(e) {
        return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]"
    }
    function v1(e, t) {
        var n = [], r, s = e.length;
        for (r = 0; r < s; ++r)
            n.push(t(e[r], r));
        return n
    }
    function ys(e, t) {
        for (var n in t)
            mt(t, n) && (e[n] = t[n]);
        return mt(t, "toString") && (e.toString = t.toString),
        mt(t, "valueOf") && (e.valueOf = t.valueOf),
        e
    }
    function si(e, t, n, r) {
        return q1(e, t, n, r, !0).utc()
    }
    function MR() {
        return {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: !1,
            weekdayMismatch: !1
        }
    }
    function et(e) {
        return e._pf == null && (e._pf = MR()),
        e._pf
    }
    var rm;
    Array.prototype.some ? rm = Array.prototype.some : rm = function(e) {
        var t = Object(this), n = t.length >>> 0, r;
        for (r = 0; r < n; r++)
            if (r in t && e.call(this, t[r], r, t))
                return !0;
        return !1
    }
    ;
    function Qm(e) {
        var t = null
          , n = !1
          , r = e._d && !isNaN(e._d.getTime());
        if (r && (t = et(e),
        n = rm.call(t.parsedDateParts, function(s) {
            return s != null
        }),
        r = t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n),
        e._strict && (r = r && t.charsLeftOver === 0 && t.unusedTokens.length === 0 && t.bigHour === void 0)),
        Object.isFrozen == null || !Object.isFrozen(e))
            e._isValid = r;
        else
            return r;
        return e._isValid
    }
    function vd(e) {
        var t = si(NaN);
        return e != null ? ys(et(t), e) : et(t).userInvalidated = !0,
        t
    }
    var ev = Ee.momentProperties = []
      , _p = !1;
    function eg(e, t) {
        var n, r, s, o = ev.length;
        if ($n(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject),
        $n(t._i) || (e._i = t._i),
        $n(t._f) || (e._f = t._f),
        $n(t._l) || (e._l = t._l),
        $n(t._strict) || (e._strict = t._strict),
        $n(t._tzm) || (e._tzm = t._tzm),
        $n(t._isUTC) || (e._isUTC = t._isUTC),
        $n(t._offset) || (e._offset = t._offset),
        $n(t._pf) || (e._pf = et(t)),
        $n(t._locale) || (e._locale = t._locale),
        o > 0)
            for (n = 0; n < o; n++)
                r = ev[n],
                s = t[r],
                $n(s) || (e[r] = s);
        return e
    }
    function Lu(e) {
        eg(this, e),
        this._d = new Date(e._d != null ? e._d.getTime() : NaN),
        this.isValid() || (this._d = new Date(NaN)),
        _p === !1 && (_p = !0,
        Ee.updateOffset(this),
        _p = !1)
    }
    function Lr(e) {
        return e instanceof Lu || e != null && e._isAMomentObject != null
    }
    function w1(e) {
        Ee.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + e)
    }
    function hr(e, t) {
        var n = !0;
        return ys(function() {
            if (Ee.deprecationHandler != null && Ee.deprecationHandler(null, e),
            n) {
                var r = [], s, o, c, l = arguments.length;
                for (o = 0; o < l; o++) {
                    if (s = "",
                    typeof arguments[o] == "object") {
                        s += `
[` + o + "] ";
                        for (c in arguments[0])
                            mt(arguments[0], c) && (s += c + ": " + arguments[0][c] + ", ");
                        s = s.slice(0, -2)
                    } else
                        s = arguments[o];
                    r.push(s)
                }
                w1(e + `
Arguments: ` + Array.prototype.slice.call(r).join("") + `
` + new Error().stack),
                n = !1
            }
            return t.apply(this, arguments)
        }, t)
    }
    var tv = {};
    function b1(e, t) {
        Ee.deprecationHandler != null && Ee.deprecationHandler(e, t),
        tv[e] || (w1(t),
        tv[e] = !0)
    }
    Ee.suppressDeprecationWarnings = !1;
    Ee.deprecationHandler = null;
    function ai(e) {
        return typeof Function < "u" && e instanceof Function || Object.prototype.toString.call(e) === "[object Function]"
    }
    function LR(e) {
        var t, n;
        for (n in e)
            mt(e, n) && (t = e[n],
            ai(t) ? this[n] = t : this["_" + n] = t);
        this._config = e,
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
    }
    function im(e, t) {
        var n = ys({}, e), r;
        for (r in t)
            mt(t, r) && (na(e[r]) && na(t[r]) ? (n[r] = {},
            ys(n[r], e[r]),
            ys(n[r], t[r])) : t[r] != null ? n[r] = t[r] : delete n[r]);
        for (r in e)
            mt(e, r) && !mt(t, r) && na(e[r]) && (n[r] = ys({}, n[r]));
        return n
    }
    function tg(e) {
        e != null && this.set(e)
    }
    var sm;
    Object.keys ? sm = Object.keys : sm = function(e) {
        var t, n = [];
        for (t in e)
            mt(e, t) && n.push(t);
        return n
    }
    ;
    var DR = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    };
    function UR(e, t, n) {
        var r = this._calendar[e] || this._calendar.sameElse;
        return ai(r) ? r.call(t, n) : r
    }
    function ni(e, t, n) {
        var r = "" + Math.abs(e)
          , s = t - r.length
          , o = e >= 0;
        return (o ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, s)).toString().substr(1) + r
    }
    var ng = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g
      , nf = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g
      , vp = {}
      , ho = {};
    function Le(e, t, n, r) {
        var s = r;
        typeof r == "string" && (s = function() {
            return this[r]()
        }
        ),
        e && (ho[e] = s),
        t && (ho[t[0]] = function() {
            return ni(s.apply(this, arguments), t[1], t[2])
        }
        ),
        n && (ho[n] = function() {
            return this.localeData().ordinal(s.apply(this, arguments), e)
        }
        )
    }
    function BR(e) {
        return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "")
    }
    function FR(e) {
        var t = e.match(ng), n, r;
        for (n = 0,
        r = t.length; n < r; n++)
            ho[t[n]] ? t[n] = ho[t[n]] : t[n] = BR(t[n]);
        return function(s) {
            var o = "", c;
            for (c = 0; c < r; c++)
                o += ai(t[c]) ? t[c].call(s, e) : t[c];
            return o
        }
    }
    function gf(e, t) {
        return e.isValid() ? (t = E1(t, e.localeData()),
        vp[t] = vp[t] || FR(t),
        vp[t](e)) : e.localeData().invalidDate()
    }
    function E1(e, t) {
        var n = 5;
        function r(s) {
            return t.longDateFormat(s) || s
        }
        for (nf.lastIndex = 0; n >= 0 && nf.test(e); )
            e = e.replace(nf, r),
            nf.lastIndex = 0,
            n -= 1;
        return e
    }
    var jR = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function qR(e) {
        var t = this._longDateFormat[e]
          , n = this._longDateFormat[e.toUpperCase()];
        return t || !n ? t : (this._longDateFormat[e] = n.match(ng).map(function(r) {
            return r === "MMMM" || r === "MM" || r === "DD" || r === "dddd" ? r.slice(1) : r
        }).join(""),
        this._longDateFormat[e])
    }
    var HR = "Invalid date";
    function YR() {
        return this._invalidDate
    }
    var VR = "%d"
      , WR = /\d{1,2}/;
    function zR(e) {
        return this._ordinal.replace("%d", e)
    }
    var GR = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function ZR(e, t, n, r) {
        var s = this._relativeTime[n];
        return ai(s) ? s(e, t, n, r) : s.replace(/%d/i, e)
    }
    function KR(e, t) {
        var n = this._relativeTime[e > 0 ? "future" : "past"];
        return ai(n) ? n(t) : n.replace(/%s/i, t)
    }
    var nv = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
    };
    function pr(e) {
        return typeof e == "string" ? nv[e] || nv[e.toLowerCase()] : void 0
    }
    function rg(e) {
        var t = {}, n, r;
        for (r in e)
            mt(e, r) && (n = pr(r),
            n && (t[n] = e[r]));
        return t
    }
    var JR = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
    };
    function XR(e) {
        var t = [], n;
        for (n in e)
            mt(e, n) && t.push({
                unit: n,
                priority: JR[n]
            });
        return t.sort(function(r, s) {
            return r.priority - s.priority
        }),
        t
    }
    var S1 = /\d/, Vn = /\d\d/, T1 = /\d{3}/, ig = /\d{4}/, wd = /[+-]?\d{6}/, Pt = /\d\d?/, A1 = /\d\d\d\d?/, O1 = /\d\d\d\d\d\d?/, bd = /\d{1,3}/, sg = /\d{1,4}/, Ed = /[+-]?\d{1,6}/, No = /\d+/, Sd = /[+-]?\d+/, QR = /Z|[+-]\d\d:?\d\d/gi, Td = /Z|[+-]\d\d(?::?\d\d)?/gi, eP = /[+-]?\d+(\.\d{1,3})?/, Du = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, xo = /^[1-9]\d?/, ag = /^([1-9]\d|\d)/, If;
    If = {};
    function Ne(e, t, n) {
        If[e] = ai(t) ? t : function(r, s) {
            return r && n ? n : t
        }
    }
    function tP(e, t) {
        return mt(If, e) ? If[e](t._strict, t._locale) : new RegExp(nP(e))
    }
    function nP(e) {
        return Mi(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(t, n, r, s, o) {
            return n || r || s || o
        }))
    }
    function Mi(e) {
        return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
    }
    function fr(e) {
        return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
    }
    function ft(e) {
        var t = +e
          , n = 0;
        return t !== 0 && isFinite(t) && (n = fr(t)),
        n
    }
    var am = {};
    function Ot(e, t) {
        var n, r = t, s;
        for (typeof e == "string" && (e = [e]),
        Bi(t) && (r = function(o, c) {
            c[t] = ft(o)
        }
        ),
        s = e.length,
        n = 0; n < s; n++)
            am[e[n]] = r
    }
    function Uu(e, t) {
        Ot(e, function(n, r, s, o) {
            s._w = s._w || {},
            t(n, s._w, s, o)
        })
    }
    function rP(e, t, n) {
        t != null && mt(am, e) && am[e](t, n._a, n, e)
    }
    function Ad(e) {
        return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0
    }
    var mn = 0
      , Pi = 1
      , Kr = 2
      , Jt = 3
      , Rr = 4
      , ki = 5
      , Qs = 6
      , iP = 7
      , sP = 8;
    Le("Y", 0, 0, function() {
        var e = this.year();
        return e <= 9999 ? ni(e, 4) : "+" + e
    });
    Le(0, ["YY", 2], 0, function() {
        return this.year() % 100
    });
    Le(0, ["YYYY", 4], 0, "year");
    Le(0, ["YYYYY", 5], 0, "year");
    Le(0, ["YYYYYY", 6, !0], 0, "year");
    Ne("Y", Sd);
    Ne("YY", Pt, Vn);
    Ne("YYYY", sg, ig);
    Ne("YYYYY", Ed, wd);
    Ne("YYYYYY", Ed, wd);
    Ot(["YYYYY", "YYYYYY"], mn);
    Ot("YYYY", function(e, t) {
        t[mn] = e.length === 2 ? Ee.parseTwoDigitYear(e) : ft(e)
    });
    Ot("YY", function(e, t) {
        t[mn] = Ee.parseTwoDigitYear(e)
    });
    Ot("Y", function(e, t) {
        t[mn] = parseInt(e, 10)
    });
    function Jc(e) {
        return Ad(e) ? 366 : 365
    }
    Ee.parseTwoDigitYear = function(e) {
        return ft(e) + (ft(e) > 68 ? 1900 : 2e3)
    }
    ;
    var I1 = $o("FullYear", !0);
    function aP() {
        return Ad(this.year())
    }
    function $o(e, t) {
        return function(n) {
            return n != null ? (N1(this, e, n),
            Ee.updateOffset(this, t),
            this) : lu(this, e)
        }
    }
    function lu(e, t) {
        if (!e.isValid())
            return NaN;
        var n = e._d
          , r = e._isUTC;
        switch (t) {
        case "Milliseconds":
            return r ? n.getUTCMilliseconds() : n.getMilliseconds();
        case "Seconds":
            return r ? n.getUTCSeconds() : n.getSeconds();
        case "Minutes":
            return r ? n.getUTCMinutes() : n.getMinutes();
        case "Hours":
            return r ? n.getUTCHours() : n.getHours();
        case "Date":
            return r ? n.getUTCDate() : n.getDate();
        case "Day":
            return r ? n.getUTCDay() : n.getDay();
        case "Month":
            return r ? n.getUTCMonth() : n.getMonth();
        case "FullYear":
            return r ? n.getUTCFullYear() : n.getFullYear();
        default:
            return NaN
        }
    }
    function N1(e, t, n) {
        var r, s, o, c, l;
        if (!(!e.isValid() || isNaN(n))) {
            switch (r = e._d,
            s = e._isUTC,
            t) {
            case "Milliseconds":
                return void (s ? r.setUTCMilliseconds(n) : r.setMilliseconds(n));
            case "Seconds":
                return void (s ? r.setUTCSeconds(n) : r.setSeconds(n));
            case "Minutes":
                return void (s ? r.setUTCMinutes(n) : r.setMinutes(n));
            case "Hours":
                return void (s ? r.setUTCHours(n) : r.setHours(n));
            case "Date":
                return void (s ? r.setUTCDate(n) : r.setDate(n));
            case "FullYear":
                break;
            default:
                return
            }
            o = n,
            c = e.month(),
            l = e.date(),
            l = l === 29 && c === 1 && !Ad(o) ? 28 : l,
            s ? r.setUTCFullYear(o, c, l) : r.setFullYear(o, c, l)
        }
    }
    function oP(e) {
        return e = pr(e),
        ai(this[e]) ? this[e]() : this
    }
    function cP(e, t) {
        if (typeof e == "object") {
            e = rg(e);
            var n = XR(e), r, s = n.length;
            for (r = 0; r < s; r++)
                this[n[r].unit](e[n[r].unit])
        } else if (e = pr(e),
        ai(this[e]))
            return this[e](t);
        return this
    }
    function uP(e, t) {
        return (e % t + t) % t
    }
    var Vt;
    Array.prototype.indexOf ? Vt = Array.prototype.indexOf : Vt = function(e) {
        var t;
        for (t = 0; t < this.length; ++t)
            if (this[t] === e)
                return t;
        return -1
    }
    ;
    function og(e, t) {
        if (isNaN(e) || isNaN(t))
            return NaN;
        var n = uP(t, 12);
        return e += (t - n) / 12,
        n === 1 ? Ad(e) ? 29 : 28 : 31 - n % 7 % 2
    }
    Le("M", ["MM", 2], "Mo", function() {
        return this.month() + 1
    });
    Le("MMM", 0, 0, function(e) {
        return this.localeData().monthsShort(this, e)
    });
    Le("MMMM", 0, 0, function(e) {
        return this.localeData().months(this, e)
    });
    Ne("M", Pt, xo);
    Ne("MM", Pt, Vn);
    Ne("MMM", function(e, t) {
        return t.monthsShortRegex(e)
    });
    Ne("MMMM", function(e, t) {
        return t.monthsRegex(e)
    });
    Ot(["M", "MM"], function(e, t) {
        t[Pi] = ft(e) - 1
    });
    Ot(["MMM", "MMMM"], function(e, t, n, r) {
        var s = n._locale.monthsParse(e, r, n._strict);
        s != null ? t[Pi] = s : et(n).invalidMonth = e
    });
    var lP = "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
      , x1 = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_")
      , $1 = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/
      , fP = Du
      , dP = Du;
    function hP(e, t) {
        return e ? Mr(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || $1).test(t) ? "format" : "standalone"][e.month()] : Mr(this._months) ? this._months : this._months.standalone
    }
    function pP(e, t) {
        return e ? Mr(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[$1.test(t) ? "format" : "standalone"][e.month()] : Mr(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
    }
    function mP(e, t, n) {
        var r, s, o, c = e.toLocaleLowerCase();
        if (!this._monthsParse)
            for (this._monthsParse = [],
            this._longMonthsParse = [],
            this._shortMonthsParse = [],
            r = 0; r < 12; ++r)
                o = si([2e3, r]),
                this._shortMonthsParse[r] = this.monthsShort(o, "").toLocaleLowerCase(),
                this._longMonthsParse[r] = this.months(o, "").toLocaleLowerCase();
        return n ? t === "MMM" ? (s = Vt.call(this._shortMonthsParse, c),
        s !== -1 ? s : null) : (s = Vt.call(this._longMonthsParse, c),
        s !== -1 ? s : null) : t === "MMM" ? (s = Vt.call(this._shortMonthsParse, c),
        s !== -1 ? s : (s = Vt.call(this._longMonthsParse, c),
        s !== -1 ? s : null)) : (s = Vt.call(this._longMonthsParse, c),
        s !== -1 ? s : (s = Vt.call(this._shortMonthsParse, c),
        s !== -1 ? s : null))
    }
    function gP(e, t, n) {
        var r, s, o;
        if (this._monthsParseExact)
            return mP.call(this, e, t, n);
        for (this._monthsParse || (this._monthsParse = [],
        this._longMonthsParse = [],
        this._shortMonthsParse = []),
        r = 0; r < 12; r++) {
            if (s = si([2e3, r]),
            n && !this._longMonthsParse[r] && (this._longMonthsParse[r] = new RegExp("^" + this.months(s, "").replace(".", "") + "$","i"),
            this._shortMonthsParse[r] = new RegExp("^" + this.monthsShort(s, "").replace(".", "") + "$","i")),
            !n && !this._monthsParse[r] && (o = "^" + this.months(s, "") + "|^" + this.monthsShort(s, ""),
            this._monthsParse[r] = new RegExp(o.replace(".", ""),"i")),
            n && t === "MMMM" && this._longMonthsParse[r].test(e))
                return r;
            if (n && t === "MMM" && this._shortMonthsParse[r].test(e))
                return r;
            if (!n && this._monthsParse[r].test(e))
                return r
        }
    }
    function R1(e, t) {
        if (!e.isValid())
            return e;
        if (typeof t == "string") {
            if (/^\d+$/.test(t))
                t = ft(t);
            else if (t = e.localeData().monthsParse(t),
            !Bi(t))
                return e
        }
        var n = t
          , r = e.date();
        return r = r < 29 ? r : Math.min(r, og(e.year(), n)),
        e._isUTC ? e._d.setUTCMonth(n, r) : e._d.setMonth(n, r),
        e
    }
    function P1(e) {
        return e != null ? (R1(this, e),
        Ee.updateOffset(this, !0),
        this) : lu(this, "Month")
    }
    function yP() {
        return og(this.year(), this.month())
    }
    function _P(e) {
        return this._monthsParseExact ? (mt(this, "_monthsRegex") || k1.call(this),
        e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (mt(this, "_monthsShortRegex") || (this._monthsShortRegex = fP),
        this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
    }
    function vP(e) {
        return this._monthsParseExact ? (mt(this, "_monthsRegex") || k1.call(this),
        e ? this._monthsStrictRegex : this._monthsRegex) : (mt(this, "_monthsRegex") || (this._monthsRegex = dP),
        this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
    }
    function k1() {
        function e(f, d) {
            return d.length - f.length
        }
        var t = [], n = [], r = [], s, o, c, l;
        for (s = 0; s < 12; s++)
            o = si([2e3, s]),
            c = Mi(this.monthsShort(o, "")),
            l = Mi(this.months(o, "")),
            t.push(c),
            n.push(l),
            r.push(l),
            r.push(c);
        t.sort(e),
        n.sort(e),
        r.sort(e),
        this._monthsRegex = new RegExp("^(" + r.join("|") + ")","i"),
        this._monthsShortRegex = this._monthsRegex,
        this._monthsStrictRegex = new RegExp("^(" + n.join("|") + ")","i"),
        this._monthsShortStrictRegex = new RegExp("^(" + t.join("|") + ")","i")
    }
    function wP(e, t, n, r, s, o, c) {
        var l;
        return e < 100 && e >= 0 ? (l = new Date(e + 400,t,n,r,s,o,c),
        isFinite(l.getFullYear()) && l.setFullYear(e)) : l = new Date(e,t,n,r,s,o,c),
        l
    }
    function fu(e) {
        var t, n;
        return e < 100 && e >= 0 ? (n = Array.prototype.slice.call(arguments),
        n[0] = e + 400,
        t = new Date(Date.UTC.apply(null, n)),
        isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)),
        t
    }
    function Nf(e, t, n) {
        var r = 7 + t - n
          , s = (7 + fu(e, 0, r).getUTCDay() - t) % 7;
        return -s + r - 1
    }
    function C1(e, t, n, r, s) {
        var o = (7 + n - r) % 7, c = Nf(e, r, s), l = 1 + 7 * (t - 1) + o + c, f, d;
        return l <= 0 ? (f = e - 1,
        d = Jc(f) + l) : l > Jc(e) ? (f = e + 1,
        d = l - Jc(e)) : (f = e,
        d = l),
        {
            year: f,
            dayOfYear: d
        }
    }
    function du(e, t, n) {
        var r = Nf(e.year(), t, n), s = Math.floor((e.dayOfYear() - r - 1) / 7) + 1, o, c;
        return s < 1 ? (c = e.year() - 1,
        o = s + Li(c, t, n)) : s > Li(e.year(), t, n) ? (o = s - Li(e.year(), t, n),
        c = e.year() + 1) : (c = e.year(),
        o = s),
        {
            week: o,
            year: c
        }
    }
    function Li(e, t, n) {
        var r = Nf(e, t, n)
          , s = Nf(e + 1, t, n);
        return (Jc(e) - r + s) / 7
    }
    Le("w", ["ww", 2], "wo", "week");
    Le("W", ["WW", 2], "Wo", "isoWeek");
    Ne("w", Pt, xo);
    Ne("ww", Pt, Vn);
    Ne("W", Pt, xo);
    Ne("WW", Pt, Vn);
    Uu(["w", "ww", "W", "WW"], function(e, t, n, r) {
        t[r.substr(0, 1)] = ft(e)
    });
    function bP(e) {
        return du(e, this._week.dow, this._week.doy).week
    }
    var EP = {
        dow: 0,
        doy: 6
    };
    function SP() {
        return this._week.dow
    }
    function TP() {
        return this._week.doy
    }
    function AP(e) {
        var t = this.localeData().week(this);
        return e == null ? t : this.add((e - t) * 7, "d")
    }
    function OP(e) {
        var t = du(this, 1, 4).week;
        return e == null ? t : this.add((e - t) * 7, "d")
    }
    Le("d", 0, "do", "day");
    Le("dd", 0, 0, function(e) {
        return this.localeData().weekdaysMin(this, e)
    });
    Le("ddd", 0, 0, function(e) {
        return this.localeData().weekdaysShort(this, e)
    });
    Le("dddd", 0, 0, function(e) {
        return this.localeData().weekdays(this, e)
    });
    Le("e", 0, 0, "weekday");
    Le("E", 0, 0, "isoWeekday");
    Ne("d", Pt);
    Ne("e", Pt);
    Ne("E", Pt);
    Ne("dd", function(e, t) {
        return t.weekdaysMinRegex(e)
    });
    Ne("ddd", function(e, t) {
        return t.weekdaysShortRegex(e)
    });
    Ne("dddd", function(e, t) {
        return t.weekdaysRegex(e)
    });
    Uu(["dd", "ddd", "dddd"], function(e, t, n, r) {
        var s = n._locale.weekdaysParse(e, r, n._strict);
        s != null ? t.d = s : et(n).invalidWeekday = e
    });
    Uu(["d", "e", "E"], function(e, t, n, r) {
        t[r] = ft(e)
    });
    function IP(e, t) {
        return typeof e != "string" ? e : isNaN(e) ? (e = t.weekdaysParse(e),
        typeof e == "number" ? e : null) : parseInt(e, 10)
    }
    function NP(e, t) {
        return typeof e == "string" ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
    }
    function cg(e, t) {
        return e.slice(t, 7).concat(e.slice(0, t))
    }
    var xP = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_")
      , M1 = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_")
      , $P = "Su_Mo_Tu_We_Th_Fr_Sa".split("_")
      , RP = Du
      , PP = Du
      , kP = Du;
    function CP(e, t) {
        var n = Mr(this._weekdays) ? this._weekdays : this._weekdays[e && e !== !0 && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
        return e === !0 ? cg(n, this._week.dow) : e ? n[e.day()] : n
    }
    function MP(e) {
        return e === !0 ? cg(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort
    }
    function LP(e) {
        return e === !0 ? cg(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin
    }
    function DP(e, t, n) {
        var r, s, o, c = e.toLocaleLowerCase();
        if (!this._weekdaysParse)
            for (this._weekdaysParse = [],
            this._shortWeekdaysParse = [],
            this._minWeekdaysParse = [],
            r = 0; r < 7; ++r)
                o = si([2e3, 1]).day(r),
                this._minWeekdaysParse[r] = this.weekdaysMin(o, "").toLocaleLowerCase(),
                this._shortWeekdaysParse[r] = this.weekdaysShort(o, "").toLocaleLowerCase(),
                this._weekdaysParse[r] = this.weekdays(o, "").toLocaleLowerCase();
        return n ? t === "dddd" ? (s = Vt.call(this._weekdaysParse, c),
        s !== -1 ? s : null) : t === "ddd" ? (s = Vt.call(this._shortWeekdaysParse, c),
        s !== -1 ? s : null) : (s = Vt.call(this._minWeekdaysParse, c),
        s !== -1 ? s : null) : t === "dddd" ? (s = Vt.call(this._weekdaysParse, c),
        s !== -1 || (s = Vt.call(this._shortWeekdaysParse, c),
        s !== -1) ? s : (s = Vt.call(this._minWeekdaysParse, c),
        s !== -1 ? s : null)) : t === "ddd" ? (s = Vt.call(this._shortWeekdaysParse, c),
        s !== -1 || (s = Vt.call(this._weekdaysParse, c),
        s !== -1) ? s : (s = Vt.call(this._minWeekdaysParse, c),
        s !== -1 ? s : null)) : (s = Vt.call(this._minWeekdaysParse, c),
        s !== -1 || (s = Vt.call(this._weekdaysParse, c),
        s !== -1) ? s : (s = Vt.call(this._shortWeekdaysParse, c),
        s !== -1 ? s : null))
    }
    function UP(e, t, n) {
        var r, s, o;
        if (this._weekdaysParseExact)
            return DP.call(this, e, t, n);
        for (this._weekdaysParse || (this._weekdaysParse = [],
        this._minWeekdaysParse = [],
        this._shortWeekdaysParse = [],
        this._fullWeekdaysParse = []),
        r = 0; r < 7; r++) {
            if (s = si([2e3, 1]).day(r),
            n && !this._fullWeekdaysParse[r] && (this._fullWeekdaysParse[r] = new RegExp("^" + this.weekdays(s, "").replace(".", "\\.?") + "$","i"),
            this._shortWeekdaysParse[r] = new RegExp("^" + this.weekdaysShort(s, "").replace(".", "\\.?") + "$","i"),
            this._minWeekdaysParse[r] = new RegExp("^" + this.weekdaysMin(s, "").replace(".", "\\.?") + "$","i")),
            this._weekdaysParse[r] || (o = "^" + this.weekdays(s, "") + "|^" + this.weekdaysShort(s, "") + "|^" + this.weekdaysMin(s, ""),
            this._weekdaysParse[r] = new RegExp(o.replace(".", ""),"i")),
            n && t === "dddd" && this._fullWeekdaysParse[r].test(e))
                return r;
            if (n && t === "ddd" && this._shortWeekdaysParse[r].test(e))
                return r;
            if (n && t === "dd" && this._minWeekdaysParse[r].test(e))
                return r;
            if (!n && this._weekdaysParse[r].test(e))
                return r
        }
    }
    function BP(e) {
        if (!this.isValid())
            return e != null ? this : NaN;
        var t = lu(this, "Day");
        return e != null ? (e = IP(e, this.localeData()),
        this.add(e - t, "d")) : t
    }
    function FP(e) {
        if (!this.isValid())
            return e != null ? this : NaN;
        var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return e == null ? t : this.add(e - t, "d")
    }
    function jP(e) {
        if (!this.isValid())
            return e != null ? this : NaN;
        if (e != null) {
            var t = NP(e, this.localeData());
            return this.day(this.day() % 7 ? t : t - 7)
        } else
            return this.day() || 7
    }
    function qP(e) {
        return this._weekdaysParseExact ? (mt(this, "_weekdaysRegex") || ug.call(this),
        e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (mt(this, "_weekdaysRegex") || (this._weekdaysRegex = RP),
        this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
    }
    function HP(e) {
        return this._weekdaysParseExact ? (mt(this, "_weekdaysRegex") || ug.call(this),
        e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (mt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = PP),
        this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
    }
    function YP(e) {
        return this._weekdaysParseExact ? (mt(this, "_weekdaysRegex") || ug.call(this),
        e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (mt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = kP),
        this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
    }
    function ug() {
        function e(h, y) {
            return y.length - h.length
        }
        var t = [], n = [], r = [], s = [], o, c, l, f, d;
        for (o = 0; o < 7; o++)
            c = si([2e3, 1]).day(o),
            l = Mi(this.weekdaysMin(c, "")),
            f = Mi(this.weekdaysShort(c, "")),
            d = Mi(this.weekdays(c, "")),
            t.push(l),
            n.push(f),
            r.push(d),
            s.push(l),
            s.push(f),
            s.push(d);
        t.sort(e),
        n.sort(e),
        r.sort(e),
        s.sort(e),
        this._weekdaysRegex = new RegExp("^(" + s.join("|") + ")","i"),
        this._weekdaysShortRegex = this._weekdaysRegex,
        this._weekdaysMinRegex = this._weekdaysRegex,
        this._weekdaysStrictRegex = new RegExp("^(" + r.join("|") + ")","i"),
        this._weekdaysShortStrictRegex = new RegExp("^(" + n.join("|") + ")","i"),
        this._weekdaysMinStrictRegex = new RegExp("^(" + t.join("|") + ")","i")
    }
    function lg() {
        return this.hours() % 12 || 12
    }
    function VP() {
        return this.hours() || 24
    }
    Le("H", ["HH", 2], 0, "hour");
    Le("h", ["hh", 2], 0, lg);
    Le("k", ["kk", 2], 0, VP);
    Le("hmm", 0, 0, function() {
        return "" + lg.apply(this) + ni(this.minutes(), 2)
    });
    Le("hmmss", 0, 0, function() {
        return "" + lg.apply(this) + ni(this.minutes(), 2) + ni(this.seconds(), 2)
    });
    Le("Hmm", 0, 0, function() {
        return "" + this.hours() + ni(this.minutes(), 2)
    });
    Le("Hmmss", 0, 0, function() {
        return "" + this.hours() + ni(this.minutes(), 2) + ni(this.seconds(), 2)
    });
    function L1(e, t) {
        Le(e, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), t)
        })
    }
    L1("a", !0);
    L1("A", !1);
    function D1(e, t) {
        return t._meridiemParse
    }
    Ne("a", D1);
    Ne("A", D1);
    Ne("H", Pt, ag);
    Ne("h", Pt, xo);
    Ne("k", Pt, xo);
    Ne("HH", Pt, Vn);
    Ne("hh", Pt, Vn);
    Ne("kk", Pt, Vn);
    Ne("hmm", A1);
    Ne("hmmss", O1);
    Ne("Hmm", A1);
    Ne("Hmmss", O1);
    Ot(["H", "HH"], Jt);
    Ot(["k", "kk"], function(e, t, n) {
        var r = ft(e);
        t[Jt] = r === 24 ? 0 : r
    });
    Ot(["a", "A"], function(e, t, n) {
        n._isPm = n._locale.isPM(e),
        n._meridiem = e
    });
    Ot(["h", "hh"], function(e, t, n) {
        t[Jt] = ft(e),
        et(n).bigHour = !0
    });
    Ot("hmm", function(e, t, n) {
        var r = e.length - 2;
        t[Jt] = ft(e.substr(0, r)),
        t[Rr] = ft(e.substr(r)),
        et(n).bigHour = !0
    });
    Ot("hmmss", function(e, t, n) {
        var r = e.length - 4
          , s = e.length - 2;
        t[Jt] = ft(e.substr(0, r)),
        t[Rr] = ft(e.substr(r, 2)),
        t[ki] = ft(e.substr(s)),
        et(n).bigHour = !0
    });
    Ot("Hmm", function(e, t, n) {
        var r = e.length - 2;
        t[Jt] = ft(e.substr(0, r)),
        t[Rr] = ft(e.substr(r))
    });
    Ot("Hmmss", function(e, t, n) {
        var r = e.length - 4
          , s = e.length - 2;
        t[Jt] = ft(e.substr(0, r)),
        t[Rr] = ft(e.substr(r, 2)),
        t[ki] = ft(e.substr(s))
    });
    function WP(e) {
        return (e + "").toLowerCase().charAt(0) === "p"
    }
    var zP = /[ap]\.?m?\.?/i
      , GP = $o("Hours", !0);
    function ZP(e, t, n) {
        return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
    }
    var U1 = {
        calendar: DR,
        longDateFormat: jR,
        invalidDate: HR,
        ordinal: VR,
        dayOfMonthOrdinalParse: WR,
        relativeTime: GR,
        months: lP,
        monthsShort: x1,
        week: EP,
        weekdays: xP,
        weekdaysMin: $P,
        weekdaysShort: M1,
        meridiemParse: zP
    }, kt = {}, Ic = {}, hu;
    function KP(e, t) {
        var n, r = Math.min(e.length, t.length);
        for (n = 0; n < r; n += 1)
            if (e[n] !== t[n])
                return n;
        return r
    }
    function rv(e) {
        return e && e.toLowerCase().replace("_", "-")
    }
    function JP(e) {
        for (var t = 0, n, r, s, o; t < e.length; ) {
            for (o = rv(e[t]).split("-"),
            n = o.length,
            r = rv(e[t + 1]),
            r = r ? r.split("-") : null; n > 0; ) {
                if (s = Od(o.slice(0, n).join("-")),
                s)
                    return s;
                if (r && r.length >= n && KP(o, r) >= n - 1)
                    break;
                n--
            }
            t++
        }
        return hu
    }
    function XP(e) {
        return !!(e && e.match("^[^/\\\\]*$"))
    }
    function Od(e) {
        var t = null, n;
        if (kt[e] === void 0 && typeof ws < "u" && ws && ws.exports && XP(e))
            try {
                t = hu._abbr,
                n = require,
                n("./locale/" + e),
                bs(t)
            } catch {
                kt[e] = null
            }
        return kt[e]
    }
    function bs(e, t) {
        var n;
        return e && ($n(t) ? n = Vi(e) : n = fg(e, t),
        n ? hu = n : typeof console < "u" && console.warn && console.warn("Locale " + e + " not found. Did you forget to load it?")),
        hu._abbr
    }
    function fg(e, t) {
        if (t !== null) {
            var n, r = U1;
            if (t.abbr = e,
            kt[e] != null)
                b1("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),
                r = kt[e]._config;
            else if (t.parentLocale != null)
                if (kt[t.parentLocale] != null)
                    r = kt[t.parentLocale]._config;
                else if (n = Od(t.parentLocale),
                n != null)
                    r = n._config;
                else
                    return Ic[t.parentLocale] || (Ic[t.parentLocale] = []),
                    Ic[t.parentLocale].push({
                        name: e,
                        config: t
                    }),
                    null;
            return kt[e] = new tg(im(r, t)),
            Ic[e] && Ic[e].forEach(function(s) {
                fg(s.name, s.config)
            }),
            bs(e),
            kt[e]
        } else
            return delete kt[e],
            null
    }
    function QP(e, t) {
        if (t != null) {
            var n, r, s = U1;
            kt[e] != null && kt[e].parentLocale != null ? kt[e].set(im(kt[e]._config, t)) : (r = Od(e),
            r != null && (s = r._config),
            t = im(s, t),
            r == null && (t.abbr = e),
            n = new tg(t),
            n.parentLocale = kt[e],
            kt[e] = n),
            bs(e)
        } else
            kt[e] != null && (kt[e].parentLocale != null ? (kt[e] = kt[e].parentLocale,
            e === bs() && bs(e)) : kt[e] != null && delete kt[e]);
        return kt[e]
    }
    function Vi(e) {
        var t;
        if (e && e._locale && e._locale._abbr && (e = e._locale._abbr),
        !e)
            return hu;
        if (!Mr(e)) {
            if (t = Od(e),
            t)
                return t;
            e = [e]
        }
        return JP(e)
    }
    function ek() {
        return sm(kt)
    }
    function dg(e) {
        var t, n = e._a;
        return n && et(e).overflow === -2 && (t = n[Pi] < 0 || n[Pi] > 11 ? Pi : n[Kr] < 1 || n[Kr] > og(n[mn], n[Pi]) ? Kr : n[Jt] < 0 || n[Jt] > 24 || n[Jt] === 24 && (n[Rr] !== 0 || n[ki] !== 0 || n[Qs] !== 0) ? Jt : n[Rr] < 0 || n[Rr] > 59 ? Rr : n[ki] < 0 || n[ki] > 59 ? ki : n[Qs] < 0 || n[Qs] > 999 ? Qs : -1,
        et(e)._overflowDayOfYear && (t < mn || t > Kr) && (t = Kr),
        et(e)._overflowWeeks && t === -1 && (t = iP),
        et(e)._overflowWeekday && t === -1 && (t = sP),
        et(e).overflow = t),
        e
    }
    var tk = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/
      , nk = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/
      , rk = /Z|[+-]\d\d(?::?\d\d)?/
      , rf = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]]
      , wp = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]]
      , ik = /^\/?Date\((-?\d+)/i
      , sk = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/
      , ak = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };
    function B1(e) {
        var t, n, r = e._i, s = tk.exec(r) || nk.exec(r), o, c, l, f, d = rf.length, h = wp.length;
        if (s) {
            for (et(e).iso = !0,
            t = 0,
            n = d; t < n; t++)
                if (rf[t][1].exec(s[1])) {
                    c = rf[t][0],
                    o = rf[t][2] !== !1;
                    break
                }
            if (c == null) {
                e._isValid = !1;
                return
            }
            if (s[3]) {
                for (t = 0,
                n = h; t < n; t++)
                    if (wp[t][1].exec(s[3])) {
                        l = (s[2] || " ") + wp[t][0];
                        break
                    }
                if (l == null) {
                    e._isValid = !1;
                    return
                }
            }
            if (!o && l != null) {
                e._isValid = !1;
                return
            }
            if (s[4])
                if (rk.exec(s[4]))
                    f = "Z";
                else {
                    e._isValid = !1;
                    return
                }
            e._f = c + (l || "") + (f || ""),
            pg(e)
        } else
            e._isValid = !1
    }
    function ok(e, t, n, r, s, o) {
        var c = [ck(e), x1.indexOf(t), parseInt(n, 10), parseInt(r, 10), parseInt(s, 10)];
        return o && c.push(parseInt(o, 10)),
        c
    }
    function ck(e) {
        var t = parseInt(e, 10);
        return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t
    }
    function uk(e) {
        return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    }
    function lk(e, t, n) {
        if (e) {
            var r = M1.indexOf(e)
              , s = new Date(t[0],t[1],t[2]).getDay();
            if (r !== s)
                return et(n).weekdayMismatch = !0,
                n._isValid = !1,
                !1
        }
        return !0
    }
    function fk(e, t, n) {
        if (e)
            return ak[e];
        if (t)
            return 0;
        var r = parseInt(n, 10)
          , s = r % 100
          , o = (r - s) / 100;
        return o * 60 + s
    }
    function F1(e) {
        var t = sk.exec(uk(e._i)), n;
        if (t) {
            if (n = ok(t[4], t[3], t[2], t[5], t[6], t[7]),
            !lk(t[1], n, e))
                return;
            e._a = n,
            e._tzm = fk(t[8], t[9], t[10]),
            e._d = fu.apply(null, e._a),
            e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm),
            et(e).rfc2822 = !0
        } else
            e._isValid = !1
    }
    function dk(e) {
        var t = ik.exec(e._i);
        if (t !== null) {
            e._d = new Date(+t[1]);
            return
        }
        if (B1(e),
        e._isValid === !1)
            delete e._isValid;
        else
            return;
        if (F1(e),
        e._isValid === !1)
            delete e._isValid;
        else
            return;
        e._strict ? e._isValid = !1 : Ee.createFromInputFallback(e)
    }
    Ee.createFromInputFallback = hr("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e) {
        e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
    });
    function to(e, t, n) {
        return e ?? t ?? n
    }
    function hk(e) {
        var t = new Date(Ee.now());
        return e._useUTC ? [t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()] : [t.getFullYear(), t.getMonth(), t.getDate()]
    }
    function hg(e) {
        var t, n, r = [], s, o, c;
        if (!e._d) {
            for (s = hk(e),
            e._w && e._a[Kr] == null && e._a[Pi] == null && pk(e),
            e._dayOfYear != null && (c = to(e._a[mn], s[mn]),
            (e._dayOfYear > Jc(c) || e._dayOfYear === 0) && (et(e)._overflowDayOfYear = !0),
            n = fu(c, 0, e._dayOfYear),
            e._a[Pi] = n.getUTCMonth(),
            e._a[Kr] = n.getUTCDate()),
            t = 0; t < 3 && e._a[t] == null; ++t)
                e._a[t] = r[t] = s[t];
            for (; t < 7; t++)
                e._a[t] = r[t] = e._a[t] == null ? t === 2 ? 1 : 0 : e._a[t];
            e._a[Jt] === 24 && e._a[Rr] === 0 && e._a[ki] === 0 && e._a[Qs] === 0 && (e._nextDay = !0,
            e._a[Jt] = 0),
            e._d = (e._useUTC ? fu : wP).apply(null, r),
            o = e._useUTC ? e._d.getUTCDay() : e._d.getDay(),
            e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm),
            e._nextDay && (e._a[Jt] = 24),
            e._w && typeof e._w.d < "u" && e._w.d !== o && (et(e).weekdayMismatch = !0)
        }
    }
    function pk(e) {
        var t, n, r, s, o, c, l, f, d;
        t = e._w,
        t.GG != null || t.W != null || t.E != null ? (o = 1,
        c = 4,
        n = to(t.GG, e._a[mn], du(Rt(), 1, 4).year),
        r = to(t.W, 1),
        s = to(t.E, 1),
        (s < 1 || s > 7) && (f = !0)) : (o = e._locale._week.dow,
        c = e._locale._week.doy,
        d = du(Rt(), o, c),
        n = to(t.gg, e._a[mn], d.year),
        r = to(t.w, d.week),
        t.d != null ? (s = t.d,
        (s < 0 || s > 6) && (f = !0)) : t.e != null ? (s = t.e + o,
        (t.e < 0 || t.e > 6) && (f = !0)) : s = o),
        r < 1 || r > Li(n, o, c) ? et(e)._overflowWeeks = !0 : f != null ? et(e)._overflowWeekday = !0 : (l = C1(n, r, s, o, c),
        e._a[mn] = l.year,
        e._dayOfYear = l.dayOfYear)
    }
    Ee.ISO_8601 = function() {}
    ;
    Ee.RFC_2822 = function() {}
    ;
    function pg(e) {
        if (e._f === Ee.ISO_8601) {
            B1(e);
            return
        }
        if (e._f === Ee.RFC_2822) {
            F1(e);
            return
        }
        e._a = [],
        et(e).empty = !0;
        var t = "" + e._i, n, r, s, o, c, l = t.length, f = 0, d, h;
        for (s = E1(e._f, e._locale).match(ng) || [],
        h = s.length,
        n = 0; n < h; n++)
            o = s[n],
            r = (t.match(tP(o, e)) || [])[0],
            r && (c = t.substr(0, t.indexOf(r)),
            c.length > 0 && et(e).unusedInput.push(c),
            t = t.slice(t.indexOf(r) + r.length),
            f += r.length),
            ho[o] ? (r ? et(e).empty = !1 : et(e).unusedTokens.push(o),
            rP(o, r, e)) : e._strict && !r && et(e).unusedTokens.push(o);
        et(e).charsLeftOver = l - f,
        t.length > 0 && et(e).unusedInput.push(t),
        e._a[Jt] <= 12 && et(e).bigHour === !0 && e._a[Jt] > 0 && (et(e).bigHour = void 0),
        et(e).parsedDateParts = e._a.slice(0),
        et(e).meridiem = e._meridiem,
        e._a[Jt] = mk(e._locale, e._a[Jt], e._meridiem),
        d = et(e).era,
        d !== null && (e._a[mn] = e._locale.erasConvertYear(d, e._a[mn])),
        hg(e),
        dg(e)
    }
    function mk(e, t, n) {
        var r;
        return n == null ? t : e.meridiemHour != null ? e.meridiemHour(t, n) : (e.isPM != null && (r = e.isPM(n),
        r && t < 12 && (t += 12),
        !r && t === 12 && (t = 0)),
        t)
    }
    function gk(e) {
        var t, n, r, s, o, c, l = !1, f = e._f.length;
        if (f === 0) {
            et(e).invalidFormat = !0,
            e._d = new Date(NaN);
            return
        }
        for (s = 0; s < f; s++)
            o = 0,
            c = !1,
            t = eg({}, e),
            e._useUTC != null && (t._useUTC = e._useUTC),
            t._f = e._f[s],
            pg(t),
            Qm(t) && (c = !0),
            o += et(t).charsLeftOver,
            o += et(t).unusedTokens.length * 10,
            et(t).score = o,
            l ? o < r && (r = o,
            n = t) : (r == null || o < r || c) && (r = o,
            n = t,
            c && (l = !0));
        ys(e, n || t)
    }
    function yk(e) {
        if (!e._d) {
            var t = rg(e._i)
              , n = t.day === void 0 ? t.date : t.day;
            e._a = v1([t.year, t.month, n, t.hour, t.minute, t.second, t.millisecond], function(r) {
                return r && parseInt(r, 10)
            }),
            hg(e)
        }
    }
    function _k(e) {
        var t = new Lu(dg(j1(e)));
        return t._nextDay && (t.add(1, "d"),
        t._nextDay = void 0),
        t
    }
    function j1(e) {
        var t = e._i
          , n = e._f;
        return e._locale = e._locale || Vi(e._l),
        t === null || n === void 0 && t === "" ? vd({
            nullInput: !0
        }) : (typeof t == "string" && (e._i = t = e._locale.preparse(t)),
        Lr(t) ? new Lu(dg(t)) : (Mu(t) ? e._d = t : Mr(n) ? gk(e) : n ? pg(e) : vk(e),
        Qm(e) || (e._d = null),
        e))
    }
    function vk(e) {
        var t = e._i;
        $n(t) ? e._d = new Date(Ee.now()) : Mu(t) ? e._d = new Date(t.valueOf()) : typeof t == "string" ? dk(e) : Mr(t) ? (e._a = v1(t.slice(0), function(n) {
            return parseInt(n, 10)
        }),
        hg(e)) : na(t) ? yk(e) : Bi(t) ? e._d = new Date(t) : Ee.createFromInputFallback(e)
    }
    function q1(e, t, n, r, s) {
        var o = {};
        return (t === !0 || t === !1) && (r = t,
        t = void 0),
        (n === !0 || n === !1) && (r = n,
        n = void 0),
        (na(e) && Xm(e) || Mr(e) && e.length === 0) && (e = void 0),
        o._isAMomentObject = !0,
        o._useUTC = o._isUTC = s,
        o._l = n,
        o._i = e,
        o._f = t,
        o._strict = r,
        _k(o)
    }
    function Rt(e, t, n, r) {
        return q1(e, t, n, r, !1)
    }
    var wk = hr("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var e = Rt.apply(null, arguments);
        return this.isValid() && e.isValid() ? e < this ? this : e : vd()
    })
      , bk = hr("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var e = Rt.apply(null, arguments);
        return this.isValid() && e.isValid() ? e > this ? this : e : vd()
    });
    function H1(e, t) {
        var n, r;
        if (t.length === 1 && Mr(t[0]) && (t = t[0]),
        !t.length)
            return Rt();
        for (n = t[0],
        r = 1; r < t.length; ++r)
            (!t[r].isValid() || t[r][e](n)) && (n = t[r]);
        return n
    }
    function Ek() {
        var e = [].slice.call(arguments, 0);
        return H1("isBefore", e)
    }
    function Sk() {
        var e = [].slice.call(arguments, 0);
        return H1("isAfter", e)
    }
    var Tk = function() {
        return Date.now ? Date.now() : +new Date
    }
      , Nc = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
    function Ak(e) {
        var t, n = !1, r, s = Nc.length;
        for (t in e)
            if (mt(e, t) && !(Vt.call(Nc, t) !== -1 && (e[t] == null || !isNaN(e[t]))))
                return !1;
        for (r = 0; r < s; ++r)
            if (e[Nc[r]]) {
                if (n)
                    return !1;
                parseFloat(e[Nc[r]]) !== ft(e[Nc[r]]) && (n = !0)
            }
        return !0
    }
    function Ok() {
        return this._isValid
    }
    function Ik() {
        return Ur(NaN)
    }
    function Id(e) {
        var t = rg(e)
          , n = t.year || 0
          , r = t.quarter || 0
          , s = t.month || 0
          , o = t.week || t.isoWeek || 0
          , c = t.day || 0
          , l = t.hour || 0
          , f = t.minute || 0
          , d = t.second || 0
          , h = t.millisecond || 0;
        this._isValid = Ak(t),
        this._milliseconds = +h + d * 1e3 + f * 6e4 + l * 1e3 * 60 * 60,
        this._days = +c + o * 7,
        this._months = +s + r * 3 + n * 12,
        this._data = {},
        this._locale = Vi(),
        this._bubble()
    }
    function yf(e) {
        return e instanceof Id
    }
    function om(e) {
        return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e)
    }
    function Nk(e, t, n) {
        var r = Math.min(e.length, t.length), s = Math.abs(e.length - t.length), o = 0, c;
        for (c = 0; c < r; c++)
            ft(e[c]) !== ft(t[c]) && o++;
        return o + s
    }
    function Y1(e, t) {
        Le(e, 0, 0, function() {
            var n = this.utcOffset()
              , r = "+";
            return n < 0 && (n = -n,
            r = "-"),
            r + ni(~~(n / 60), 2) + t + ni(~~n % 60, 2)
        })
    }
    Y1("Z", ":");
    Y1("ZZ", "");
    Ne("Z", Td);
    Ne("ZZ", Td);
    Ot(["Z", "ZZ"], function(e, t, n) {
        n._useUTC = !0,
        n._tzm = mg(Td, e)
    });
    var xk = /([\+\-]|\d\d)/gi;
    function mg(e, t) {
        var n = (t || "").match(e), r, s, o;
        return n === null ? null : (r = n[n.length - 1] || [],
        s = (r + "").match(xk) || ["-", 0, 0],
        o = +(s[1] * 60) + ft(s[2]),
        o === 0 ? 0 : s[0] === "+" ? o : -o)
    }
    function gg(e, t) {
        var n, r;
        return t._isUTC ? (n = t.clone(),
        r = (Lr(e) || Mu(e) ? e.valueOf() : Rt(e).valueOf()) - n.valueOf(),
        n._d.setTime(n._d.valueOf() + r),
        Ee.updateOffset(n, !1),
        n) : Rt(e).local()
    }
    function cm(e) {
        return -Math.round(e._d.getTimezoneOffset())
    }
    Ee.updateOffset = function() {}
    ;
    function $k(e, t, n) {
        var r = this._offset || 0, s;
        if (!this.isValid())
            return e != null ? this : NaN;
        if (e != null) {
            if (typeof e == "string") {
                if (e = mg(Td, e),
                e === null)
                    return this
            } else
                Math.abs(e) < 16 && !n && (e = e * 60);
            return !this._isUTC && t && (s = cm(this)),
            this._offset = e,
            this._isUTC = !0,
            s != null && this.add(s, "m"),
            r !== e && (!t || this._changeInProgress ? z1(this, Ur(e - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0,
            Ee.updateOffset(this, !0),
            this._changeInProgress = null)),
            this
        } else
            return this._isUTC ? r : cm(this)
    }
    function Rk(e, t) {
        return e != null ? (typeof e != "string" && (e = -e),
        this.utcOffset(e, t),
        this) : -this.utcOffset()
    }
    function Pk(e) {
        return this.utcOffset(0, e)
    }
    function kk(e) {
        return this._isUTC && (this.utcOffset(0, e),
        this._isUTC = !1,
        e && this.subtract(cm(this), "m")),
        this
    }
    function Ck() {
        if (this._tzm != null)
            this.utcOffset(this._tzm, !1, !0);
        else if (typeof this._i == "string") {
            var e = mg(QR, this._i);
            e != null ? this.utcOffset(e) : this.utcOffset(0, !0)
        }
        return this
    }
    function Mk(e) {
        return this.isValid() ? (e = e ? Rt(e).utcOffset() : 0,
        (this.utcOffset() - e) % 60 === 0) : !1
    }
    function Lk() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
    }
    function Dk() {
        if (!$n(this._isDSTShifted))
            return this._isDSTShifted;
        var e = {}, t;
        return eg(e, this),
        e = j1(e),
        e._a ? (t = e._isUTC ? si(e._a) : Rt(e._a),
        this._isDSTShifted = this.isValid() && Nk(e._a, t.toArray()) > 0) : this._isDSTShifted = !1,
        this._isDSTShifted
    }
    function Uk() {
        return this.isValid() ? !this._isUTC : !1
    }
    function Bk() {
        return this.isValid() ? this._isUTC : !1
    }
    function V1() {
        return this.isValid() ? this._isUTC && this._offset === 0 : !1
    }
    var Fk = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/
      , jk = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function Ur(e, t) {
        var n = e, r = null, s, o, c;
        return yf(e) ? n = {
            ms: e._milliseconds,
            d: e._days,
            M: e._months
        } : Bi(e) || !isNaN(+e) ? (n = {},
        t ? n[t] = +e : n.milliseconds = +e) : (r = Fk.exec(e)) ? (s = r[1] === "-" ? -1 : 1,
        n = {
            y: 0,
            d: ft(r[Kr]) * s,
            h: ft(r[Jt]) * s,
            m: ft(r[Rr]) * s,
            s: ft(r[ki]) * s,
            ms: ft(om(r[Qs] * 1e3)) * s
        }) : (r = jk.exec(e)) ? (s = r[1] === "-" ? -1 : 1,
        n = {
            y: Ys(r[2], s),
            M: Ys(r[3], s),
            w: Ys(r[4], s),
            d: Ys(r[5], s),
            h: Ys(r[6], s),
            m: Ys(r[7], s),
            s: Ys(r[8], s)
        }) : n == null ? n = {} : typeof n == "object" && ("from"in n || "to"in n) && (c = qk(Rt(n.from), Rt(n.to)),
        n = {},
        n.ms = c.milliseconds,
        n.M = c.months),
        o = new Id(n),
        yf(e) && mt(e, "_locale") && (o._locale = e._locale),
        yf(e) && mt(e, "_isValid") && (o._isValid = e._isValid),
        o
    }
    Ur.fn = Id.prototype;
    Ur.invalid = Ik;
    function Ys(e, t) {
        var n = e && parseFloat(e.replace(",", "."));
        return (isNaN(n) ? 0 : n) * t
    }
    function iv(e, t) {
        var n = {};
        return n.months = t.month() - e.month() + (t.year() - e.year()) * 12,
        e.clone().add(n.months, "M").isAfter(t) && --n.months,
        n.milliseconds = +t - +e.clone().add(n.months, "M"),
        n
    }
    function qk(e, t) {
        var n;
        return e.isValid() && t.isValid() ? (t = gg(t, e),
        e.isBefore(t) ? n = iv(e, t) : (n = iv(t, e),
        n.milliseconds = -n.milliseconds,
        n.months = -n.months),
        n) : {
            milliseconds: 0,
            months: 0
        }
    }
    function W1(e, t) {
        return function(n, r) {
            var s, o;
            return r !== null && !isNaN(+r) && (b1(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),
            o = n,
            n = r,
            r = o),
            s = Ur(n, r),
            z1(this, s, e),
            this
        }
    }
    function z1(e, t, n, r) {
        var s = t._milliseconds
          , o = om(t._days)
          , c = om(t._months);
        e.isValid() && (r = r ?? !0,
        c && R1(e, lu(e, "Month") + c * n),
        o && N1(e, "Date", lu(e, "Date") + o * n),
        s && e._d.setTime(e._d.valueOf() + s * n),
        r && Ee.updateOffset(e, o || c))
    }
    var Hk = W1(1, "add")
      , Yk = W1(-1, "subtract");
    function G1(e) {
        return typeof e == "string" || e instanceof String
    }
    function Vk(e) {
        return Lr(e) || Mu(e) || G1(e) || Bi(e) || zk(e) || Wk(e) || e === null || e === void 0
    }
    function Wk(e) {
        var t = na(e) && !Xm(e), n = !1, r = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], s, o, c = r.length;
        for (s = 0; s < c; s += 1)
            o = r[s],
            n = n || mt(e, o);
        return t && n
    }
    function zk(e) {
        var t = Mr(e)
          , n = !1;
        return t && (n = e.filter(function(r) {
            return !Bi(r) && G1(e)
        }).length === 0),
        t && n
    }
    function Gk(e) {
        var t = na(e) && !Xm(e), n = !1, r = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], s, o;
        for (s = 0; s < r.length; s += 1)
            o = r[s],
            n = n || mt(e, o);
        return t && n
    }
    function Zk(e, t) {
        var n = e.diff(t, "days", !0);
        return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
    }
    function Kk(e, t) {
        arguments.length === 1 && (arguments[0] ? Vk(arguments[0]) ? (e = arguments[0],
        t = void 0) : Gk(arguments[0]) && (t = arguments[0],
        e = void 0) : (e = void 0,
        t = void 0));
        var n = e || Rt()
          , r = gg(n, this).startOf("day")
          , s = Ee.calendarFormat(this, r) || "sameElse"
          , o = t && (ai(t[s]) ? t[s].call(this, n) : t[s]);
        return this.format(o || this.localeData().calendar(s, this, Rt(n)))
    }
    function Jk() {
        return new Lu(this)
    }
    function Xk(e, t) {
        var n = Lr(e) ? e : Rt(e);
        return this.isValid() && n.isValid() ? (t = pr(t) || "millisecond",
        t === "millisecond" ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf()) : !1
    }
    function Qk(e, t) {
        var n = Lr(e) ? e : Rt(e);
        return this.isValid() && n.isValid() ? (t = pr(t) || "millisecond",
        t === "millisecond" ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf()) : !1
    }
    function eC(e, t, n, r) {
        var s = Lr(e) ? e : Rt(e)
          , o = Lr(t) ? t : Rt(t);
        return this.isValid() && s.isValid() && o.isValid() ? (r = r || "()",
        (r[0] === "(" ? this.isAfter(s, n) : !this.isBefore(s, n)) && (r[1] === ")" ? this.isBefore(o, n) : !this.isAfter(o, n))) : !1
    }
    function tC(e, t) {
        var n = Lr(e) ? e : Rt(e), r;
        return this.isValid() && n.isValid() ? (t = pr(t) || "millisecond",
        t === "millisecond" ? this.valueOf() === n.valueOf() : (r = n.valueOf(),
        this.clone().startOf(t).valueOf() <= r && r <= this.clone().endOf(t).valueOf())) : !1
    }
    function nC(e, t) {
        return this.isSame(e, t) || this.isAfter(e, t)
    }
    function rC(e, t) {
        return this.isSame(e, t) || this.isBefore(e, t)
    }
    function iC(e, t, n) {
        var r, s, o;
        if (!this.isValid())
            return NaN;
        if (r = gg(e, this),
        !r.isValid())
            return NaN;
        switch (s = (r.utcOffset() - this.utcOffset()) * 6e4,
        t = pr(t),
        t) {
        case "year":
            o = _f(this, r) / 12;
            break;
        case "month":
            o = _f(this, r);
            break;
        case "quarter":
            o = _f(this, r) / 3;
            break;
        case "second":
            o = (this - r) / 1e3;
            break;
        case "minute":
            o = (this - r) / 6e4;
            break;
        case "hour":
            o = (this - r) / 36e5;
            break;
        case "day":
            o = (this - r - s) / 864e5;
            break;
        case "week":
            o = (this - r - s) / 6048e5;
            break;
        default:
            o = this - r
        }
        return n ? o : fr(o)
    }
    function _f(e, t) {
        if (e.date() < t.date())
            return -_f(t, e);
        var n = (t.year() - e.year()) * 12 + (t.month() - e.month()), r = e.clone().add(n, "months"), s, o;
        return t - r < 0 ? (s = e.clone().add(n - 1, "months"),
        o = (t - r) / (r - s)) : (s = e.clone().add(n + 1, "months"),
        o = (t - r) / (s - r)),
        -(n + o) || 0
    }
    Ee.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    Ee.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function sC() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
    }
    function aC(e) {
        if (!this.isValid())
            return null;
        var t = e !== !0
          , n = t ? this.clone().utc() : this;
        return n.year() < 0 || n.year() > 9999 ? gf(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : ai(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", gf(n, "Z")) : gf(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
    }
    function oC() {
        if (!this.isValid())
            return "moment.invalid(/* " + this._i + " */)";
        var e = "moment", t = "", n, r, s, o;
        return this.isLocal() || (e = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone",
        t = "Z"),
        n = "[" + e + '("]',
        r = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
        s = "-MM-DD[T]HH:mm:ss.SSS",
        o = t + '[")]',
        this.format(n + r + s + o)
    }
    function cC(e) {
        e || (e = this.isUtc() ? Ee.defaultFormatUtc : Ee.defaultFormat);
        var t = gf(this, e);
        return this.localeData().postformat(t)
    }
    function uC(e, t) {
        return this.isValid() && (Lr(e) && e.isValid() || Rt(e).isValid()) ? Ur({
            to: this,
            from: e
        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
    }
    function lC(e) {
        return this.from(Rt(), e)
    }
    function fC(e, t) {
        return this.isValid() && (Lr(e) && e.isValid() || Rt(e).isValid()) ? Ur({
            from: this,
            to: e
        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
    }
    function dC(e) {
        return this.to(Rt(), e)
    }
    function Z1(e) {
        var t;
        return e === void 0 ? this._locale._abbr : (t = Vi(e),
        t != null && (this._locale = t),
        this)
    }
    var K1 = hr("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e) {
        return e === void 0 ? this.localeData() : this.locale(e)
    });
    function J1() {
        return this._locale
    }
    var xf = 1e3
      , po = 60 * xf
      , $f = 60 * po
      , X1 = (365 * 400 + 97) * 24 * $f;
    function mo(e, t) {
        return (e % t + t) % t
    }
    function Q1(e, t, n) {
        return e < 100 && e >= 0 ? new Date(e + 400,t,n) - X1 : new Date(e,t,n).valueOf()
    }
    function eb(e, t, n) {
        return e < 100 && e >= 0 ? Date.UTC(e + 400, t, n) - X1 : Date.UTC(e, t, n)
    }
    function hC(e) {
        var t, n;
        if (e = pr(e),
        e === void 0 || e === "millisecond" || !this.isValid())
            return this;
        switch (n = this._isUTC ? eb : Q1,
        e) {
        case "year":
            t = n(this.year(), 0, 1);
            break;
        case "quarter":
            t = n(this.year(), this.month() - this.month() % 3, 1);
            break;
        case "month":
            t = n(this.year(), this.month(), 1);
            break;
        case "week":
            t = n(this.year(), this.month(), this.date() - this.weekday());
            break;
        case "isoWeek":
            t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
        case "day":
        case "date":
            t = n(this.year(), this.month(), this.date());
            break;
        case "hour":
            t = this._d.valueOf(),
            t -= mo(t + (this._isUTC ? 0 : this.utcOffset() * po), $f);
            break;
        case "minute":
            t = this._d.valueOf(),
            t -= mo(t, po);
            break;
        case "second":
            t = this._d.valueOf(),
            t -= mo(t, xf);
            break
        }
        return this._d.setTime(t),
        Ee.updateOffset(this, !0),
        this
    }
    function pC(e) {
        var t, n;
        if (e = pr(e),
        e === void 0 || e === "millisecond" || !this.isValid())
            return this;
        switch (n = this._isUTC ? eb : Q1,
        e) {
        case "year":
            t = n(this.year() + 1, 0, 1) - 1;
            break;
        case "quarter":
            t = n(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
        case "month":
            t = n(this.year(), this.month() + 1, 1) - 1;
            break;
        case "week":
            t = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
        case "isoWeek":
            t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
        case "day":
        case "date":
            t = n(this.year(), this.month(), this.date() + 1) - 1;
            break;
        case "hour":
            t = this._d.valueOf(),
            t += $f - mo(t + (this._isUTC ? 0 : this.utcOffset() * po), $f) - 1;
            break;
        case "minute":
            t = this._d.valueOf(),
            t += po - mo(t, po) - 1;
            break;
        case "second":
            t = this._d.valueOf(),
            t += xf - mo(t, xf) - 1;
            break
        }
        return this._d.setTime(t),
        Ee.updateOffset(this, !0),
        this
    }
    function mC() {
        return this._d.valueOf() - (this._offset || 0) * 6e4
    }
    function gC() {
        return Math.floor(this.valueOf() / 1e3)
    }
    function yC() {
        return new Date(this.valueOf())
    }
    function _C() {
        var e = this;
        return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()]
    }
    function vC() {
        var e = this;
        return {
            years: e.year(),
            months: e.month(),
            date: e.date(),
            hours: e.hours(),
            minutes: e.minutes(),
            seconds: e.seconds(),
            milliseconds: e.milliseconds()
        }
    }
    function wC() {
        return this.isValid() ? this.toISOString() : null
    }
    function bC() {
        return Qm(this)
    }
    function EC() {
        return ys({}, et(this))
    }
    function SC() {
        return et(this).overflow
    }
    function TC() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        }
    }
    Le("N", 0, 0, "eraAbbr");
    Le("NN", 0, 0, "eraAbbr");
    Le("NNN", 0, 0, "eraAbbr");
    Le("NNNN", 0, 0, "eraName");
    Le("NNNNN", 0, 0, "eraNarrow");
    Le("y", ["y", 1], "yo", "eraYear");
    Le("y", ["yy", 2], 0, "eraYear");
    Le("y", ["yyy", 3], 0, "eraYear");
    Le("y", ["yyyy", 4], 0, "eraYear");
    Ne("N", yg);
    Ne("NN", yg);
    Ne("NNN", yg);
    Ne("NNNN", MC);
    Ne("NNNNN", LC);
    Ot(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e, t, n, r) {
        var s = n._locale.erasParse(e, r, n._strict);
        s ? et(n).era = s : et(n).invalidEra = e
    });
    Ne("y", No);
    Ne("yy", No);
    Ne("yyy", No);
    Ne("yyyy", No);
    Ne("yo", DC);
    Ot(["y", "yy", "yyy", "yyyy"], mn);
    Ot(["yo"], function(e, t, n, r) {
        var s;
        n._locale._eraYearOrdinalRegex && (s = e.match(n._locale._eraYearOrdinalRegex)),
        n._locale.eraYearOrdinalParse ? t[mn] = n._locale.eraYearOrdinalParse(e, s) : t[mn] = parseInt(e, 10)
    });
    function AC(e, t) {
        var n, r, s, o = this._eras || Vi("en")._eras;
        for (n = 0,
        r = o.length; n < r; ++n) {
            switch (typeof o[n].since) {
            case "string":
                s = Ee(o[n].since).startOf("day"),
                o[n].since = s.valueOf();
                break
            }
            switch (typeof o[n].until) {
            case "undefined":
                o[n].until = 1 / 0;
                break;
            case "string":
                s = Ee(o[n].until).startOf("day").valueOf(),
                o[n].until = s.valueOf();
                break
            }
        }
        return o
    }
    function OC(e, t, n) {
        var r, s, o = this.eras(), c, l, f;
        for (e = e.toUpperCase(),
        r = 0,
        s = o.length; r < s; ++r)
            if (c = o[r].name.toUpperCase(),
            l = o[r].abbr.toUpperCase(),
            f = o[r].narrow.toUpperCase(),
            n)
                switch (t) {
                case "N":
                case "NN":
                case "NNN":
                    if (l === e)
                        return o[r];
                    break;
                case "NNNN":
                    if (c === e)
                        return o[r];
                    break;
                case "NNNNN":
                    if (f === e)
                        return o[r];
                    break
                }
            else if ([c, l, f].indexOf(e) >= 0)
                return o[r]
    }
    function IC(e, t) {
        var n = e.since <= e.until ? 1 : -1;
        return t === void 0 ? Ee(e.since).year() : Ee(e.since).year() + (t - e.offset) * n
    }
    function NC() {
        var e, t, n, r = this.localeData().eras();
        for (e = 0,
        t = r.length; e < t; ++e)
            if (n = this.clone().startOf("day").valueOf(),
            r[e].since <= n && n <= r[e].until || r[e].until <= n && n <= r[e].since)
                return r[e].name;
        return ""
    }
    function xC() {
        var e, t, n, r = this.localeData().eras();
        for (e = 0,
        t = r.length; e < t; ++e)
            if (n = this.clone().startOf("day").valueOf(),
            r[e].since <= n && n <= r[e].until || r[e].until <= n && n <= r[e].since)
                return r[e].narrow;
        return ""
    }
    function $C() {
        var e, t, n, r = this.localeData().eras();
        for (e = 0,
        t = r.length; e < t; ++e)
            if (n = this.clone().startOf("day").valueOf(),
            r[e].since <= n && n <= r[e].until || r[e].until <= n && n <= r[e].since)
                return r[e].abbr;
        return ""
    }
    function RC() {
        var e, t, n, r, s = this.localeData().eras();
        for (e = 0,
        t = s.length; e < t; ++e)
            if (n = s[e].since <= s[e].until ? 1 : -1,
            r = this.clone().startOf("day").valueOf(),
            s[e].since <= r && r <= s[e].until || s[e].until <= r && r <= s[e].since)
                return (this.year() - Ee(s[e].since).year()) * n + s[e].offset;
        return this.year()
    }
    function PC(e) {
        return mt(this, "_erasNameRegex") || _g.call(this),
        e ? this._erasNameRegex : this._erasRegex
    }
    function kC(e) {
        return mt(this, "_erasAbbrRegex") || _g.call(this),
        e ? this._erasAbbrRegex : this._erasRegex
    }
    function CC(e) {
        return mt(this, "_erasNarrowRegex") || _g.call(this),
        e ? this._erasNarrowRegex : this._erasRegex
    }
    function yg(e, t) {
        return t.erasAbbrRegex(e)
    }
    function MC(e, t) {
        return t.erasNameRegex(e)
    }
    function LC(e, t) {
        return t.erasNarrowRegex(e)
    }
    function DC(e, t) {
        return t._eraYearOrdinalRegex || No
    }
    function _g() {
        var e = [], t = [], n = [], r = [], s, o, c, l, f, d = this.eras();
        for (s = 0,
        o = d.length; s < o; ++s)
            c = Mi(d[s].name),
            l = Mi(d[s].abbr),
            f = Mi(d[s].narrow),
            t.push(c),
            e.push(l),
            n.push(f),
            r.push(c),
            r.push(l),
            r.push(f);
        this._erasRegex = new RegExp("^(" + r.join("|") + ")","i"),
        this._erasNameRegex = new RegExp("^(" + t.join("|") + ")","i"),
        this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")","i"),
        this._erasNarrowRegex = new RegExp("^(" + n.join("|") + ")","i")
    }
    Le(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100
    });
    Le(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100
    });
    function Nd(e, t) {
        Le(0, [e, e.length], 0, t)
    }
    Nd("gggg", "weekYear");
    Nd("ggggg", "weekYear");
    Nd("GGGG", "isoWeekYear");
    Nd("GGGGG", "isoWeekYear");
    Ne("G", Sd);
    Ne("g", Sd);
    Ne("GG", Pt, Vn);
    Ne("gg", Pt, Vn);
    Ne("GGGG", sg, ig);
    Ne("gggg", sg, ig);
    Ne("GGGGG", Ed, wd);
    Ne("ggggg", Ed, wd);
    Uu(["gggg", "ggggg", "GGGG", "GGGGG"], function(e, t, n, r) {
        t[r.substr(0, 2)] = ft(e)
    });
    Uu(["gg", "GG"], function(e, t, n, r) {
        t[r] = Ee.parseTwoDigitYear(e)
    });
    function UC(e) {
        return tb.call(this, e, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy)
    }
    function BC(e) {
        return tb.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
    }
    function FC() {
        return Li(this.year(), 1, 4)
    }
    function jC() {
        return Li(this.isoWeekYear(), 1, 4)
    }
    function qC() {
        var e = this.localeData()._week;
        return Li(this.year(), e.dow, e.doy)
    }
    function HC() {
        var e = this.localeData()._week;
        return Li(this.weekYear(), e.dow, e.doy)
    }
    function tb(e, t, n, r, s) {
        var o;
        return e == null ? du(this, r, s).year : (o = Li(e, r, s),
        t > o && (t = o),
        YC.call(this, e, t, n, r, s))
    }
    function YC(e, t, n, r, s) {
        var o = C1(e, t, n, r, s)
          , c = fu(o.year, 0, o.dayOfYear);
        return this.year(c.getUTCFullYear()),
        this.month(c.getUTCMonth()),
        this.date(c.getUTCDate()),
        this
    }
    Le("Q", 0, "Qo", "quarter");
    Ne("Q", S1);
    Ot("Q", function(e, t) {
        t[Pi] = (ft(e) - 1) * 3
    });
    function VC(e) {
        return e == null ? Math.ceil((this.month() + 1) / 3) : this.month((e - 1) * 3 + this.month() % 3)
    }
    Le("D", ["DD", 2], "Do", "date");
    Ne("D", Pt, xo);
    Ne("DD", Pt, Vn);
    Ne("Do", function(e, t) {
        return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
    });
    Ot(["D", "DD"], Kr);
    Ot("Do", function(e, t) {
        t[Kr] = ft(e.match(Pt)[0])
    });
    var nb = $o("Date", !0);
    Le("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    Ne("DDD", bd);
    Ne("DDDD", T1);
    Ot(["DDD", "DDDD"], function(e, t, n) {
        n._dayOfYear = ft(e)
    });
    function WC(e) {
        var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return e == null ? t : this.add(e - t, "d")
    }
    Le("m", ["mm", 2], 0, "minute");
    Ne("m", Pt, ag);
    Ne("mm", Pt, Vn);
    Ot(["m", "mm"], Rr);
    var zC = $o("Minutes", !1);
    Le("s", ["ss", 2], 0, "second");
    Ne("s", Pt, ag);
    Ne("ss", Pt, Vn);
    Ot(["s", "ss"], ki);
    var GC = $o("Seconds", !1);
    Le("S", 0, 0, function() {
        return ~~(this.millisecond() / 100)
    });
    Le(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10)
    });
    Le(0, ["SSS", 3], 0, "millisecond");
    Le(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10
    });
    Le(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100
    });
    Le(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3
    });
    Le(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4
    });
    Le(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5
    });
    Le(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6
    });
    Ne("S", bd, S1);
    Ne("SS", bd, Vn);
    Ne("SSS", bd, T1);
    var _s, rb;
    for (_s = "SSSS"; _s.length <= 9; _s += "S")
        Ne(_s, No);
    function ZC(e, t) {
        t[Qs] = ft(("0." + e) * 1e3)
    }
    for (_s = "S"; _s.length <= 9; _s += "S")
        Ot(_s, ZC);
    rb = $o("Milliseconds", !1);
    Le("z", 0, 0, "zoneAbbr");
    Le("zz", 0, 0, "zoneName");
    function KC() {
        return this._isUTC ? "UTC" : ""
    }
    function JC() {
        return this._isUTC ? "Coordinated Universal Time" : ""
    }
    var ge = Lu.prototype;
    ge.add = Hk;
    ge.calendar = Kk;
    ge.clone = Jk;
    ge.diff = iC;
    ge.endOf = pC;
    ge.format = cC;
    ge.from = uC;
    ge.fromNow = lC;
    ge.to = fC;
    ge.toNow = dC;
    ge.get = oP;
    ge.invalidAt = SC;
    ge.isAfter = Xk;
    ge.isBefore = Qk;
    ge.isBetween = eC;
    ge.isSame = tC;
    ge.isSameOrAfter = nC;
    ge.isSameOrBefore = rC;
    ge.isValid = bC;
    ge.lang = K1;
    ge.locale = Z1;
    ge.localeData = J1;
    ge.max = bk;
    ge.min = wk;
    ge.parsingFlags = EC;
    ge.set = cP;
    ge.startOf = hC;
    ge.subtract = Yk;
    ge.toArray = _C;
    ge.toObject = vC;
    ge.toDate = yC;
    ge.toISOString = aC;
    ge.inspect = oC;
    typeof Symbol < "u" && Symbol.for != null && (ge[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">"
    }
    );
    ge.toJSON = wC;
    ge.toString = sC;
    ge.unix = gC;
    ge.valueOf = mC;
    ge.creationData = TC;
    ge.eraName = NC;
    ge.eraNarrow = xC;
    ge.eraAbbr = $C;
    ge.eraYear = RC;
    ge.year = I1;
    ge.isLeapYear = aP;
    ge.weekYear = UC;
    ge.isoWeekYear = BC;
    ge.quarter = ge.quarters = VC;
    ge.month = P1;
    ge.daysInMonth = yP;
    ge.week = ge.weeks = AP;
    ge.isoWeek = ge.isoWeeks = OP;
    ge.weeksInYear = qC;
    ge.weeksInWeekYear = HC;
    ge.isoWeeksInYear = FC;
    ge.isoWeeksInISOWeekYear = jC;
    ge.date = nb;
    ge.day = ge.days = BP;
    ge.weekday = FP;
    ge.isoWeekday = jP;
    ge.dayOfYear = WC;
    ge.hour = ge.hours = GP;
    ge.minute = ge.minutes = zC;
    ge.second = ge.seconds = GC;
    ge.millisecond = ge.milliseconds = rb;
    ge.utcOffset = $k;
    ge.utc = Pk;
    ge.local = kk;
    ge.parseZone = Ck;
    ge.hasAlignedHourOffset = Mk;
    ge.isDST = Lk;
    ge.isLocal = Uk;
    ge.isUtcOffset = Bk;
    ge.isUtc = V1;
    ge.isUTC = V1;
    ge.zoneAbbr = KC;
    ge.zoneName = JC;
    ge.dates = hr("dates accessor is deprecated. Use date instead.", nb);
    ge.months = hr("months accessor is deprecated. Use month instead", P1);
    ge.years = hr("years accessor is deprecated. Use year instead", I1);
    ge.zone = hr("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", Rk);
    ge.isDSTShifted = hr("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", Dk);
    function XC(e) {
        return Rt(e * 1e3)
    }
    function QC() {
        return Rt.apply(null, arguments).parseZone()
    }
    function ib(e) {
        return e
    }
    var gt = tg.prototype;
    gt.calendar = UR;
    gt.longDateFormat = qR;
    gt.invalidDate = YR;
    gt.ordinal = zR;
    gt.preparse = ib;
    gt.postformat = ib;
    gt.relativeTime = ZR;
    gt.pastFuture = KR;
    gt.set = LR;
    gt.eras = AC;
    gt.erasParse = OC;
    gt.erasConvertYear = IC;
    gt.erasAbbrRegex = kC;
    gt.erasNameRegex = PC;
    gt.erasNarrowRegex = CC;
    gt.months = hP;
    gt.monthsShort = pP;
    gt.monthsParse = gP;
    gt.monthsRegex = vP;
    gt.monthsShortRegex = _P;
    gt.week = bP;
    gt.firstDayOfYear = TP;
    gt.firstDayOfWeek = SP;
    gt.weekdays = CP;
    gt.weekdaysMin = LP;
    gt.weekdaysShort = MP;
    gt.weekdaysParse = UP;
    gt.weekdaysRegex = qP;
    gt.weekdaysShortRegex = HP;
    gt.weekdaysMinRegex = YP;
    gt.isPM = WP;
    gt.meridiem = ZP;
    function Rf(e, t, n, r) {
        var s = Vi()
          , o = si().set(r, t);
        return s[n](o, e)
    }
    function sb(e, t, n) {
        if (Bi(e) && (t = e,
        e = void 0),
        e = e || "",
        t != null)
            return Rf(e, t, n, "month");
        var r, s = [];
        for (r = 0; r < 12; r++)
            s[r] = Rf(e, r, n, "month");
        return s
    }
    function vg(e, t, n, r) {
        typeof e == "boolean" ? (Bi(t) && (n = t,
        t = void 0),
        t = t || "") : (t = e,
        n = t,
        e = !1,
        Bi(t) && (n = t,
        t = void 0),
        t = t || "");
        var s = Vi(), o = e ? s._week.dow : 0, c, l = [];
        if (n != null)
            return Rf(t, (n + o) % 7, r, "day");
        for (c = 0; c < 7; c++)
            l[c] = Rf(t, (c + o) % 7, r, "day");
        return l
    }
    function e2(e, t) {
        return sb(e, t, "months")
    }
    function t2(e, t) {
        return sb(e, t, "monthsShort")
    }
    function n2(e, t, n) {
        return vg(e, t, n, "weekdays")
    }
    function r2(e, t, n) {
        return vg(e, t, n, "weekdaysShort")
    }
    function i2(e, t, n) {
        return vg(e, t, n, "weekdaysMin")
    }
    bs("en", {
        eras: [{
            since: "0001-01-01",
            until: 1 / 0,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
        }, {
            since: "0000-12-31",
            until: -1 / 0,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
        }],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(e) {
            var t = e % 10
              , n = ft(e % 100 / 10) === 1 ? "th" : t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th";
            return e + n
        }
    });
    Ee.lang = hr("moment.lang is deprecated. Use moment.locale instead.", bs);
    Ee.langData = hr("moment.langData is deprecated. Use moment.localeData instead.", Vi);
    var Ti = Math.abs;
    function s2() {
        var e = this._data;
        return this._milliseconds = Ti(this._milliseconds),
        this._days = Ti(this._days),
        this._months = Ti(this._months),
        e.milliseconds = Ti(e.milliseconds),
        e.seconds = Ti(e.seconds),
        e.minutes = Ti(e.minutes),
        e.hours = Ti(e.hours),
        e.months = Ti(e.months),
        e.years = Ti(e.years),
        this
    }
    function ab(e, t, n, r) {
        var s = Ur(t, n);
        return e._milliseconds += r * s._milliseconds,
        e._days += r * s._days,
        e._months += r * s._months,
        e._bubble()
    }
    function a2(e, t) {
        return ab(this, e, t, 1)
    }
    function o2(e, t) {
        return ab(this, e, t, -1)
    }
    function sv(e) {
        return e < 0 ? Math.floor(e) : Math.ceil(e)
    }
    function c2() {
        var e = this._milliseconds, t = this._days, n = this._months, r = this._data, s, o, c, l, f;
        return e >= 0 && t >= 0 && n >= 0 || e <= 0 && t <= 0 && n <= 0 || (e += sv(um(n) + t) * 864e5,
        t = 0,
        n = 0),
        r.milliseconds = e % 1e3,
        s = fr(e / 1e3),
        r.seconds = s % 60,
        o = fr(s / 60),
        r.minutes = o % 60,
        c = fr(o / 60),
        r.hours = c % 24,
        t += fr(c / 24),
        f = fr(ob(t)),
        n += f,
        t -= sv(um(f)),
        l = fr(n / 12),
        n %= 12,
        r.days = t,
        r.months = n,
        r.years = l,
        this
    }
    function ob(e) {
        return e * 4800 / 146097
    }
    function um(e) {
        return e * 146097 / 4800
    }
    function u2(e) {
        if (!this.isValid())
            return NaN;
        var t, n, r = this._milliseconds;
        if (e = pr(e),
        e === "month" || e === "quarter" || e === "year")
            switch (t = this._days + r / 864e5,
            n = this._months + ob(t),
            e) {
            case "month":
                return n;
            case "quarter":
                return n / 3;
            case "year":
                return n / 12
            }
        else
            switch (t = this._days + Math.round(um(this._months)),
            e) {
            case "week":
                return t / 7 + r / 6048e5;
            case "day":
                return t + r / 864e5;
            case "hour":
                return t * 24 + r / 36e5;
            case "minute":
                return t * 1440 + r / 6e4;
            case "second":
                return t * 86400 + r / 1e3;
            case "millisecond":
                return Math.floor(t * 864e5) + r;
            default:
                throw new Error("Unknown unit " + e)
            }
    }
    function Wi(e) {
        return function() {
            return this.as(e)
        }
    }
    var cb = Wi("ms")
      , l2 = Wi("s")
      , f2 = Wi("m")
      , d2 = Wi("h")
      , h2 = Wi("d")
      , p2 = Wi("w")
      , m2 = Wi("M")
      , g2 = Wi("Q")
      , y2 = Wi("y")
      , _2 = cb;
    function v2() {
        return Ur(this)
    }
    function w2(e) {
        return e = pr(e),
        this.isValid() ? this[e + "s"]() : NaN
    }
    function da(e) {
        return function() {
            return this.isValid() ? this._data[e] : NaN
        }
    }
    var b2 = da("milliseconds")
      , E2 = da("seconds")
      , S2 = da("minutes")
      , T2 = da("hours")
      , A2 = da("days")
      , O2 = da("months")
      , I2 = da("years");
    function N2() {
        return fr(this.days() / 7)
    }
    var xi = Math.round
      , so = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
    };
    function x2(e, t, n, r, s) {
        return s.relativeTime(t || 1, !!n, e, r)
    }
    function $2(e, t, n, r) {
        var s = Ur(e).abs()
          , o = xi(s.as("s"))
          , c = xi(s.as("m"))
          , l = xi(s.as("h"))
          , f = xi(s.as("d"))
          , d = xi(s.as("M"))
          , h = xi(s.as("w"))
          , y = xi(s.as("y"))
          , I = o <= n.ss && ["s", o] || o < n.s && ["ss", o] || c <= 1 && ["m"] || c < n.m && ["mm", c] || l <= 1 && ["h"] || l < n.h && ["hh", l] || f <= 1 && ["d"] || f < n.d && ["dd", f];
        return n.w != null && (I = I || h <= 1 && ["w"] || h < n.w && ["ww", h]),
        I = I || d <= 1 && ["M"] || d < n.M && ["MM", d] || y <= 1 && ["y"] || ["yy", y],
        I[2] = t,
        I[3] = +e > 0,
        I[4] = r,
        x2.apply(null, I)
    }
    function R2(e) {
        return e === void 0 ? xi : typeof e == "function" ? (xi = e,
        !0) : !1
    }
    function P2(e, t) {
        return so[e] === void 0 ? !1 : t === void 0 ? so[e] : (so[e] = t,
        e === "s" && (so.ss = t - 1),
        !0)
    }
    function k2(e, t) {
        if (!this.isValid())
            return this.localeData().invalidDate();
        var n = !1, r = so, s, o;
        return typeof e == "object" && (t = e,
        e = !1),
        typeof e == "boolean" && (n = e),
        typeof t == "object" && (r = Object.assign({}, so, t),
        t.s != null && t.ss == null && (r.ss = t.s - 1)),
        s = this.localeData(),
        o = $2(this, !n, r, s),
        n && (o = s.pastFuture(+this, o)),
        s.postformat(o)
    }
    var bp = Math.abs;
    function Za(e) {
        return (e > 0) - (e < 0) || +e
    }
    function xd() {
        if (!this.isValid())
            return this.localeData().invalidDate();
        var e = bp(this._milliseconds) / 1e3, t = bp(this._days), n = bp(this._months), r, s, o, c, l = this.asSeconds(), f, d, h, y;
        return l ? (r = fr(e / 60),
        s = fr(r / 60),
        e %= 60,
        r %= 60,
        o = fr(n / 12),
        n %= 12,
        c = e ? e.toFixed(3).replace(/\.?0+$/, "") : "",
        f = l < 0 ? "-" : "",
        d = Za(this._months) !== Za(l) ? "-" : "",
        h = Za(this._days) !== Za(l) ? "-" : "",
        y = Za(this._milliseconds) !== Za(l) ? "-" : "",
        f + "P" + (o ? d + o + "Y" : "") + (n ? d + n + "M" : "") + (t ? h + t + "D" : "") + (s || r || e ? "T" : "") + (s ? y + s + "H" : "") + (r ? y + r + "M" : "") + (e ? y + c + "S" : "")) : "P0D"
    }
    var pt = Id.prototype;
    pt.isValid = Ok;
    pt.abs = s2;
    pt.add = a2;
    pt.subtract = o2;
    pt.as = u2;
    pt.asMilliseconds = cb;
    pt.asSeconds = l2;
    pt.asMinutes = f2;
    pt.asHours = d2;
    pt.asDays = h2;
    pt.asWeeks = p2;
    pt.asMonths = m2;
    pt.asQuarters = g2;
    pt.asYears = y2;
    pt.valueOf = _2;
    pt._bubble = c2;
    pt.clone = v2;
    pt.get = w2;
    pt.milliseconds = b2;
    pt.seconds = E2;
    pt.minutes = S2;
    pt.hours = T2;
    pt.days = A2;
    pt.weeks = N2;
    pt.months = O2;
    pt.years = I2;
    pt.humanize = k2;
    pt.toISOString = xd;
    pt.toString = xd;
    pt.toJSON = xd;
    pt.locale = Z1;
    pt.localeData = J1;
    pt.toIsoString = hr("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", xd);
    pt.lang = K1;
    Le("X", 0, 0, "unix");
    Le("x", 0, 0, "valueOf");
    Ne("x", Sd);
    Ne("X", eP);
    Ot("X", function(e, t, n) {
        n._d = new Date(parseFloat(e) * 1e3)
    });
    Ot("x", function(e, t, n) {
        n._d = new Date(ft(e))
    });
    //! moment.js
    Ee.version = "2.30.1";
    CR(Rt);
    Ee.fn = ge;
    Ee.min = Ek;
    Ee.max = Sk;
    Ee.now = Tk;
    Ee.utc = si;
    Ee.unix = XC;
    Ee.months = e2;
    Ee.isDate = Mu;
    Ee.locale = bs;
    Ee.invalid = vd;
    Ee.duration = Ur;
    Ee.isMoment = Lr;
    Ee.weekdays = n2;
    Ee.parseZone = QC;
    Ee.localeData = Vi;
    Ee.isDuration = yf;
    Ee.monthsShort = t2;
    Ee.weekdaysMin = i2;
    Ee.defineLocale = fg;
    Ee.updateLocale = QP;
    Ee.locales = ek;
    Ee.weekdaysShort = r2;
    Ee.normalizeUnits = pr;
    Ee.relativeTimeRounding = R2;
    Ee.relativeTimeThreshold = P2;
    Ee.calendarFormat = Zk;
    Ee.prototype = ge;
    Ee.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
    };
    var av = {
        exports: {}
    }
      , ub = {}
      , kr = {}
      , vo = {}
      , Bu = {}
      , ot = {}
      , pu = {};
    (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
        class t {
        }
        e._CodeOrName = t,
        e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        class n extends t {
            constructor(g) {
                if (super(),
                !e.IDENTIFIER.test(g))
                    throw new Error("CodeGen: name must be a valid identifier");
                this.str = g
            }
            toString() {
                return this.str
            }
            emptyStr() {
                return !1
            }
            get names() {
                return {
                    [this.str]: 1
                }
            }
        }
        e.Name = n;
        class r extends t {
            constructor(g) {
                super(),
                this._items = typeof g == "string" ? [g] : g
            }
            toString() {
                return this.str
            }
            emptyStr() {
                if (this._items.length > 1)
                    return !1;
                const g = this._items[0];
                return g === "" || g === '""'
            }
            get str() {
                var g;
                return (g = this._str) !== null && g !== void 0 ? g : this._str = this._items.reduce( (M, G) => `${M}${G}`, "")
            }
            get names() {
                var g;
                return (g = this._names) !== null && g !== void 0 ? g : this._names = this._items.reduce( (M, G) => (G instanceof n && (M[G.str] = (M[G.str] || 0) + 1),
                M), {})
            }
        }
        e._Code = r,
        e.nil = new r("");
        function s(m, ...g) {
            const M = [m[0]];
            let G = 0;
            for (; G < g.length; )
                l(M, g[G]),
                M.push(m[++G]);
            return new r(M)
        }
        e._ = s;
        const o = new r("+");
        function c(m, ...g) {
            const M = [$(m[0])];
            let G = 0;
            for (; G < g.length; )
                M.push(o),
                l(M, g[G]),
                M.push(o, $(m[++G]));
            return f(M),
            new r(M)
        }
        e.str = c;
        function l(m, g) {
            g instanceof r ? m.push(...g._items) : g instanceof n ? m.push(g) : m.push(y(g))
        }
        e.addCodeArg = l;
        function f(m) {
            let g = 1;
            for (; g < m.length - 1; ) {
                if (m[g] === o) {
                    const M = d(m[g - 1], m[g + 1]);
                    if (M !== void 0) {
                        m.splice(g - 1, 3, M);
                        continue
                    }
                    m[g++] = "+"
                }
                g++
            }
        }
        function d(m, g) {
            if (g === '""')
                return m;
            if (m === '""')
                return g;
            if (typeof m == "string")
                return g instanceof n || m[m.length - 1] !== '"' ? void 0 : typeof g != "string" ? `${m.slice(0, -1)}${g}"` : g[0] === '"' ? m.slice(0, -1) + g.slice(1) : void 0;
            if (typeof g == "string" && g[0] === '"' && !(m instanceof n))
                return `"${m}${g.slice(1)}`
        }
        function h(m, g) {
            return g.emptyStr() ? m : m.emptyStr() ? g : c`${m}${g}`
        }
        e.strConcat = h;
        function y(m) {
            return typeof m == "number" || typeof m == "boolean" || m === null ? m : $(Array.isArray(m) ? m.join(",") : m)
        }
        function I(m) {
            return new r($(m))
        }
        e.stringify = I;
        function $(m) {
            return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
        }
        e.safeStringify = $;
        function O(m) {
            return typeof m == "string" && e.IDENTIFIER.test(m) ? new r(`.${m}`) : s`[${m}]`
        }
        e.getProperty = O;
        function A(m) {
            if (typeof m == "string" && e.IDENTIFIER.test(m))
                return new r(`${m}`);
            throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`)
        }
        e.getEsmExportName = A;
        function N(m) {
            return new r(m.toString())
        }
        e.regexpCode = N
    }
    )(pu);
    var lm = {};
    (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
        const t = pu;
        class n extends Error {
            constructor(d) {
                super(`CodeGen: "code" for ${d} not defined`),
                this.value = d.value
            }
        }
        var r;
        (function(f) {
            f[f.Started = 0] = "Started",
            f[f.Completed = 1] = "Completed"
        }
        )(r || (e.UsedValueState = r = {})),
        e.varKinds = {
            const: new t.Name("const"),
            let: new t.Name("let"),
            var: new t.Name("var")
        };
        class s {
            constructor({prefixes: d, parent: h}={}) {
                this._names = {},
                this._prefixes = d,
                this._parent = h
            }
            toName(d) {
                return d instanceof t.Name ? d : this.name(d)
            }
            name(d) {
                return new t.Name(this._newName(d))
            }
            _newName(d) {
                const h = this._names[d] || this._nameGroup(d);
                return `${d}${h.index++}`
            }
            _nameGroup(d) {
                var h, y;
                if (!((y = (h = this._parent) === null || h === void 0 ? void 0 : h._prefixes) === null || y === void 0) && y.has(d) || this._prefixes && !this._prefixes.has(d))
                    throw new Error(`CodeGen: prefix "${d}" is not allowed in this scope`);
                return this._names[d] = {
                    prefix: d,
                    index: 0
                }
            }
        }
        e.Scope = s;
        class o extends t.Name {
            constructor(d, h) {
                super(h),
                this.prefix = d
            }
            setValue(d, {property: h, itemIndex: y}) {
                this.value = d,
                this.scopePath = (0,
                t._)`.${new t.Name(h)}[${y}]`
            }
        }
        e.ValueScopeName = o;
        const c = (0,
        t._)`\n`;
        class l extends s {
            constructor(d) {
                super(d),
                this._values = {},
                this._scope = d.scope,
                this.opts = {
                    ...d,
                    _n: d.lines ? c : t.nil
                }
            }
            get() {
                return this._scope
            }
            name(d) {
                return new o(d,this._newName(d))
            }
            value(d, h) {
                var y;
                if (h.ref === void 0)
                    throw new Error("CodeGen: ref must be passed in value");
                const I = this.toName(d)
                  , {prefix: $} = I
                  , O = (y = h.key) !== null && y !== void 0 ? y : h.ref;
                let A = this._values[$];
                if (A) {
                    const g = A.get(O);
                    if (g)
                        return g
                } else
                    A = this._values[$] = new Map;
                A.set(O, I);
                const N = this._scope[$] || (this._scope[$] = [])
                  , m = N.length;
                return N[m] = h.ref,
                I.setValue(h, {
                    property: $,
                    itemIndex: m
                }),
                I
            }
            getValue(d, h) {
                const y = this._values[d];
                if (y)
                    return y.get(h)
            }
            scopeRefs(d, h=this._values) {
                return this._reduceValues(h, y => {
                    if (y.scopePath === void 0)
                        throw new Error(`CodeGen: name "${y}" has no value`);
                    return (0,
                    t._)`${d}${y.scopePath}`
                }
                )
            }
            scopeCode(d=this._values, h, y) {
                return this._reduceValues(d, I => {
                    if (I.value === void 0)
                        throw new Error(`CodeGen: name "${I}" has no value`);
                    return I.value.code
                }
                , h, y)
            }
            _reduceValues(d, h, y={}, I) {
                let $ = t.nil;
                for (const O in d) {
                    const A = d[O];
                    if (!A)
                        continue;
                    const N = y[O] = y[O] || new Map;
                    A.forEach(m => {
                        if (N.has(m))
                            return;
                        N.set(m, r.Started);
                        let g = h(m);
                        if (g) {
                            const M = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
                            $ = (0,
                            t._)`${$}${M} ${m} = ${g};${this.opts._n}`
                        } else if (g = I?.(m))
                            $ = (0,
                            t._)`${$}${g}${this.opts._n}`;
                        else
                            throw new n(m);
                        N.set(m, r.Completed)
                    }
                    )
                }
                return $
            }
        }
        e.ValueScope = l
    }
    )(lm);
    (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
        const t = pu
          , n = lm;
        var r = pu;
        Object.defineProperty(e, "_", {
            enumerable: !0,
            get: function() {
                return r._
            }
        }),
        Object.defineProperty(e, "str", {
            enumerable: !0,
            get: function() {
                return r.str
            }
        }),
        Object.defineProperty(e, "strConcat", {
            enumerable: !0,
            get: function() {
                return r.strConcat
            }
        }),
        Object.defineProperty(e, "nil", {
            enumerable: !0,
            get: function() {
                return r.nil
            }
        }),
        Object.defineProperty(e, "getProperty", {
            enumerable: !0,
            get: function() {
                return r.getProperty
            }
        }),
        Object.defineProperty(e, "stringify", {
            enumerable: !0,
            get: function() {
                return r.stringify
            }
        }),
        Object.defineProperty(e, "regexpCode", {
            enumerable: !0,
            get: function() {
                return r.regexpCode
            }
        }),
        Object.defineProperty(e, "Name", {
            enumerable: !0,
            get: function() {
                return r.Name
            }
        });
        var s = lm;
        Object.defineProperty(e, "Scope", {
            enumerable: !0,
            get: function() {
                return s.Scope
            }
        }),
        Object.defineProperty(e, "ValueScope", {
            enumerable: !0,
            get: function() {
                return s.ValueScope
            }
        }),
        Object.defineProperty(e, "ValueScopeName", {
            enumerable: !0,
            get: function() {
                return s.ValueScopeName
            }
        }),
        Object.defineProperty(e, "varKinds", {
            enumerable: !0,
            get: function() {
                return s.varKinds
            }
        }),
        e.operators = {
            GT: new t._Code(">"),
            GTE: new t._Code(">="),
            LT: new t._Code("<"),
            LTE: new t._Code("<="),
            EQ: new t._Code("==="),
            NEQ: new t._Code("!=="),
            NOT: new t._Code("!"),
            OR: new t._Code("||"),
            AND: new t._Code("&&"),
            ADD: new t._Code("+")
        };
        class o {
            optimizeNodes() {
                return this
            }
            optimizeNames(P, j) {
                return this
            }
        }
        class c extends o {
            constructor(P, j, se) {
                super(),
                this.varKind = P,
                this.name = j,
                this.rhs = se
            }
            render({es5: P, _n: j}) {
                const se = P ? n.varKinds.var : this.varKind
                  , ye = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
                return `${se} ${this.name}${ye};` + j
            }
            optimizeNames(P, j) {
                if (P[this.name.str])
                    return this.rhs && (this.rhs = X(this.rhs, P, j)),
                    this
            }
            get names() {
                return this.rhs instanceof t._CodeOrName ? this.rhs.names : {}
            }
        }
        class l extends o {
            constructor(P, j, se) {
                super(),
                this.lhs = P,
                this.rhs = j,
                this.sideEffects = se
            }
            render({_n: P}) {
                return `${this.lhs} = ${this.rhs};` + P
            }
            optimizeNames(P, j) {
                if (!(this.lhs instanceof t.Name && !P[this.lhs.str] && !this.sideEffects))
                    return this.rhs = X(this.rhs, P, j),
                    this
            }
            get names() {
                const P = this.lhs instanceof t.Name ? {} : {
                    ...this.lhs.names
                };
                return F(P, this.rhs)
            }
        }
        class f extends l {
            constructor(P, j, se, ye) {
                super(P, se, ye),
                this.op = j
            }
            render({_n: P}) {
                return `${this.lhs} ${this.op}= ${this.rhs};` + P
            }
        }
        class d extends o {
            constructor(P) {
                super(),
                this.label = P,
                this.names = {}
            }
            render({_n: P}) {
                return `${this.label}:` + P
            }
        }
        class h extends o {
            constructor(P) {
                super(),
                this.label = P,
                this.names = {}
            }
            render({_n: P}) {
                return `break${this.label ? ` ${this.label}` : ""};` + P
            }
        }
        class y extends o {
            constructor(P) {
                super(),
                this.error = P
            }
            render({_n: P}) {
                return `throw ${this.error};` + P
            }
            get names() {
                return this.error.names
            }
        }
        class I extends o {
            constructor(P) {
                super(),
                this.code = P
            }
            render({_n: P}) {
                return `${this.code};` + P
            }
            optimizeNodes() {
                return `${this.code}` ? this : void 0
            }
            optimizeNames(P, j) {
                return this.code = X(this.code, P, j),
                this
            }
            get names() {
                return this.code instanceof t._CodeOrName ? this.code.names : {}
            }
        }
        class $ extends o {
            constructor(P=[]) {
                super(),
                this.nodes = P
            }
            render(P) {
                return this.nodes.reduce( (j, se) => j + se.render(P), "")
            }
            optimizeNodes() {
                const {nodes: P} = this;
                let j = P.length;
                for (; j--; ) {
                    const se = P[j].optimizeNodes();
                    Array.isArray(se) ? P.splice(j, 1, ...se) : se ? P[j] = se : P.splice(j, 1)
                }
                return P.length > 0 ? this : void 0
            }
            optimizeNames(P, j) {
                const {nodes: se} = this;
                let ye = se.length;
                for (; ye--; ) {
                    const we = se[ye];
                    we.optimizeNames(P, j) || (v(P, we.names),
                    se.splice(ye, 1))
                }
                return se.length > 0 ? this : void 0
            }
            get names() {
                return this.nodes.reduce( (P, j) => C(P, j.names), {})
            }
        }
        class O extends $ {
            render(P) {
                return "{" + P._n + super.render(P) + "}" + P._n
            }
        }
        class A extends $ {
        }
        class N extends O {
        }
        N.kind = "else";
        class m extends O {
            constructor(P, j) {
                super(j),
                this.condition = P
            }
            render(P) {
                let j = `if(${this.condition})` + super.render(P);
                return this.else && (j += "else " + this.else.render(P)),
                j
            }
            optimizeNodes() {
                super.optimizeNodes();
                const P = this.condition;
                if (P === !0)
                    return this.nodes;
                let j = this.else;
                if (j) {
                    const se = j.optimizeNodes();
                    j = this.else = Array.isArray(se) ? new N(se) : se
                }
                if (j)
                    return P === !1 ? j instanceof m ? j : j.nodes : this.nodes.length ? this : new m(x(P),j instanceof m ? [j] : j.nodes);
                if (!(P === !1 || !this.nodes.length))
                    return this
            }
            optimizeNames(P, j) {
                var se;
                if (this.else = (se = this.else) === null || se === void 0 ? void 0 : se.optimizeNames(P, j),
                !!(super.optimizeNames(P, j) || this.else))
                    return this.condition = X(this.condition, P, j),
                    this
            }
            get names() {
                const P = super.names;
                return F(P, this.condition),
                this.else && C(P, this.else.names),
                P
            }
        }
        m.kind = "if";
        class g extends O {
        }
        g.kind = "for";
        class M extends g {
            constructor(P) {
                super(),
                this.iteration = P
            }
            render(P) {
                return `for(${this.iteration})` + super.render(P)
            }
            optimizeNames(P, j) {
                if (super.optimizeNames(P, j))
                    return this.iteration = X(this.iteration, P, j),
                    this
            }
            get names() {
                return C(super.names, this.iteration.names)
            }
        }
        class G extends g {
            constructor(P, j, se, ye) {
                super(),
                this.varKind = P,
                this.name = j,
                this.from = se,
                this.to = ye
            }
            render(P) {
                const j = P.es5 ? n.varKinds.var : this.varKind
                  , {name: se, from: ye, to: we} = this;
                return `for(${j} ${se}=${ye}; ${se}<${we}; ${se}++)` + super.render(P)
            }
            get names() {
                const P = F(super.names, this.from);
                return F(P, this.to)
            }
        }
        class U extends g {
            constructor(P, j, se, ye) {
                super(),
                this.loop = P,
                this.varKind = j,
                this.name = se,
                this.iterable = ye
            }
            render(P) {
                return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(P)
            }
            optimizeNames(P, j) {
                if (super.optimizeNames(P, j))
                    return this.iterable = X(this.iterable, P, j),
                    this
            }
            get names() {
                return C(super.names, this.iterable.names)
            }
        }
        class D extends O {
            constructor(P, j, se) {
                super(),
                this.name = P,
                this.args = j,
                this.async = se
            }
            render(P) {
                return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(P)
            }
        }
        D.kind = "func";
        class K extends $ {
            render(P) {
                return "return " + super.render(P)
            }
        }
        K.kind = "return";
        class _ extends O {
            render(P) {
                let j = "try" + super.render(P);
                return this.catch && (j += this.catch.render(P)),
                this.finally && (j += this.finally.render(P)),
                j
            }
            optimizeNodes() {
                var P, j;
                return super.optimizeNodes(),
                (P = this.catch) === null || P === void 0 || P.optimizeNodes(),
                (j = this.finally) === null || j === void 0 || j.optimizeNodes(),
                this
            }
            optimizeNames(P, j) {
                var se, ye;
                return super.optimizeNames(P, j),
                (se = this.catch) === null || se === void 0 || se.optimizeNames(P, j),
                (ye = this.finally) === null || ye === void 0 || ye.optimizeNames(P, j),
                this
            }
            get names() {
                const P = super.names;
                return this.catch && C(P, this.catch.names),
                this.finally && C(P, this.finally.names),
                P
            }
        }
        class T extends O {
            constructor(P) {
                super(),
                this.error = P
            }
            render(P) {
                return `catch(${this.error})` + super.render(P)
            }
        }
        T.kind = "catch";
        class S extends O {
            render(P) {
                return "finally" + super.render(P)
            }
        }
        S.kind = "finally";
        class q {
            constructor(P, j={}) {
                this._values = {},
                this._blockStarts = [],
                this._constants = {},
                this.opts = {
                    ...j,
                    _n: j.lines ? `
` : ""
                },
                this._extScope = P,
                this._scope = new n.Scope({
                    parent: P
                }),
                this._nodes = [new A]
            }
            toString() {
                return this._root.render(this.opts)
            }
            name(P) {
                return this._scope.name(P)
            }
            scopeName(P) {
                return this._extScope.name(P)
            }
            scopeValue(P, j) {
                const se = this._extScope.value(P, j);
                return (this._values[se.prefix] || (this._values[se.prefix] = new Set)).add(se),
                se
            }
            getScopeValue(P, j) {
                return this._extScope.getValue(P, j)
            }
            scopeRefs(P) {
                return this._extScope.scopeRefs(P, this._values)
            }
            scopeCode() {
                return this._extScope.scopeCode(this._values)
            }
            _def(P, j, se, ye) {
                const we = this._scope.toName(j);
                return se !== void 0 && ye && (this._constants[we.str] = se),
                this._leafNode(new c(P,we,se)),
                we
            }
            const(P, j, se) {
                return this._def(n.varKinds.const, P, j, se)
            }
            let(P, j, se) {
                return this._def(n.varKinds.let, P, j, se)
            }
            var(P, j, se) {
                return this._def(n.varKinds.var, P, j, se)
            }
            assign(P, j, se) {
                return this._leafNode(new l(P,j,se))
            }
            add(P, j) {
                return this._leafNode(new f(P,e.operators.ADD,j))
            }
            code(P) {
                return typeof P == "function" ? P() : P !== t.nil && this._leafNode(new I(P)),
                this
            }
            object(...P) {
                const j = ["{"];
                for (const [se,ye] of P)
                    j.length > 1 && j.push(","),
                    j.push(se),
                    (se !== ye || this.opts.es5) && (j.push(":"),
                    (0,
                    t.addCodeArg)(j, ye));
                return j.push("}"),
                new t._Code(j)
            }
            if(P, j, se) {
                if (this._blockNode(new m(P)),
                j && se)
                    this.code(j).else().code(se).endIf();
                else if (j)
                    this.code(j).endIf();
                else if (se)
                    throw new Error('CodeGen: "else" body without "then" body');
                return this
            }
            elseIf(P) {
                return this._elseNode(new m(P))
            }
            else() {
                return this._elseNode(new N)
            }
            endIf() {
                return this._endBlockNode(m, N)
            }
            _for(P, j) {
                return this._blockNode(P),
                j && this.code(j).endFor(),
                this
            }
            for(P, j) {
                return this._for(new M(P), j)
            }
            forRange(P, j, se, ye, we=this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
                const De = this._scope.toName(P);
                return this._for(new G(we,De,j,se), () => ye(De))
            }
            forOf(P, j, se, ye=n.varKinds.const) {
                const we = this._scope.toName(P);
                if (this.opts.es5) {
                    const De = j instanceof t.Name ? j : this.var("_arr", j);
                    return this.forRange("_i", 0, (0,
                    t._)`${De}.length`, Re => {
                        this.var(we, (0,
                        t._)`${De}[${Re}]`),
                        se(we)
                    }
                    )
                }
                return this._for(new U("of",ye,we,j), () => se(we))
            }
            forIn(P, j, se, ye=this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
                if (this.opts.ownProperties)
                    return this.forOf(P, (0,
                    t._)`Object.keys(${j})`, se);
                const we = this._scope.toName(P);
                return this._for(new U("in",ye,we,j), () => se(we))
            }
            endFor() {
                return this._endBlockNode(g)
            }
            label(P) {
                return this._leafNode(new d(P))
            }
            break(P) {
                return this._leafNode(new h(P))
            }
            return(P) {
                const j = new K;
                if (this._blockNode(j),
                this.code(P),
                j.nodes.length !== 1)
                    throw new Error('CodeGen: "return" should have one node');
                return this._endBlockNode(K)
            }
            try(P, j, se) {
                if (!j && !se)
                    throw new Error('CodeGen: "try" without "catch" and "finally"');
                const ye = new _;
                if (this._blockNode(ye),
                this.code(P),
                j) {
                    const we = this.name("e");
                    this._currNode = ye.catch = new T(we),
                    j(we)
                }
                return se && (this._currNode = ye.finally = new S,
                this.code(se)),
                this._endBlockNode(T, S)
            }
            throw(P) {
                return this._leafNode(new y(P))
            }
            block(P, j) {
                return this._blockStarts.push(this._nodes.length),
                P && this.code(P).endBlock(j),
                this
            }
            endBlock(P) {
                const j = this._blockStarts.pop();
                if (j === void 0)
                    throw new Error("CodeGen: not in self-balancing block");
                const se = this._nodes.length - j;
                if (se < 0 || P !== void 0 && se !== P)
                    throw new Error(`CodeGen: wrong number of nodes: ${se} vs ${P} expected`);
                return this._nodes.length = j,
                this
            }
            func(P, j=t.nil, se, ye) {
                return this._blockNode(new D(P,j,se)),
                ye && this.code(ye).endFunc(),
                this
            }
            endFunc() {
                return this._endBlockNode(D)
            }
            optimize(P=1) {
                for (; P-- > 0; )
                    this._root.optimizeNodes(),
                    this._root.optimizeNames(this._root.names, this._constants)
            }
            _leafNode(P) {
                return this._currNode.nodes.push(P),
                this
            }
            _blockNode(P) {
                this._currNode.nodes.push(P),
                this._nodes.push(P)
            }
            _endBlockNode(P, j) {
                const se = this._currNode;
                if (se instanceof P || j && se instanceof j)
                    return this._nodes.pop(),
                    this;
                throw new Error(`CodeGen: not in block "${j ? `${P.kind}/${j.kind}` : P.kind}"`)
            }
            _elseNode(P) {
                const j = this._currNode;
                if (!(j instanceof m))
                    throw new Error('CodeGen: "else" without "if"');
                return this._currNode = j.else = P,
                this
            }
            get _root() {
                return this._nodes[0]
            }
            get _currNode() {
                const P = this._nodes;
                return P[P.length - 1]
            }
            set _currNode(P) {
                const j = this._nodes;
                j[j.length - 1] = P
            }
        }
        e.CodeGen = q;
        function C(Q, P) {
            for (const j in P)
                Q[j] = (Q[j] || 0) + (P[j] || 0);
            return Q
        }
        function F(Q, P) {
            return P instanceof t._CodeOrName ? C(Q, P.names) : Q
        }
        function X(Q, P, j) {
            if (Q instanceof t.Name)
                return se(Q);
            if (!ye(Q))
                return Q;
            return new t._Code(Q._items.reduce( (we, De) => (De instanceof t.Name && (De = se(De)),
            De instanceof t._Code ? we.push(...De._items) : we.push(De),
            we), []));
            function se(we) {
                const De = j[we.str];
                return De === void 0 || P[we.str] !== 1 ? we : (delete P[we.str],
                De)
            }
            function ye(we) {
                return we instanceof t._Code && we._items.some(De => De instanceof t.Name && P[De.str] === 1 && j[De.str] !== void 0)
            }
        }
        function v(Q, P) {
            for (const j in P)
                Q[j] = (Q[j] || 0) - (P[j] || 0)
        }
        function x(Q) {
            return typeof Q == "boolean" || typeof Q == "number" || Q === null ? !Q : (0,
            t._)`!${ae(Q)}`
        }
        e.not = x;
        const Y = H(e.operators.AND);
        function W(...Q) {
            return Q.reduce(Y)
        }
        e.and = W;
        const te = H(e.operators.OR);
        function J(...Q) {
            return Q.reduce(te)
        }
        e.or = J;
        function H(Q) {
            return (P, j) => P === t.nil ? j : j === t.nil ? P : (0,
            t._)`${ae(P)} ${Q} ${ae(j)}`
        }
        function ae(Q) {
            return Q instanceof t.Name ? Q : (0,
            t._)`(${Q})`
        }
    }
    )(ot);
    var Te = {};
    Object.defineProperty(Te, "__esModule", {
        value: !0
    });
    Te.checkStrictMode = Te.getErrorPath = Te.Type = Te.useFunc = Te.setEvaluated = Te.evaluatedPropsToName = Te.mergeEvaluated = Te.eachItem = Te.unescapeJsonPointer = Te.escapeJsonPointer = Te.escapeFragment = Te.unescapeFragment = Te.schemaRefOrVal = Te.schemaHasRulesButRef = Te.schemaHasRules = Te.checkUnknownRules = Te.alwaysValidSchema = Te.toHash = void 0;
    const xt = ot
      , C2 = pu;
    function M2(e) {
        const t = {};
        for (const n of e)
            t[n] = !0;
        return t
    }
    Te.toHash = M2;
    function L2(e, t) {
        return typeof t == "boolean" ? t : Object.keys(t).length === 0 ? !0 : (lb(e, t),
        !fb(t, e.self.RULES.all))
    }
    Te.alwaysValidSchema = L2;
    function lb(e, t=e.schema) {
        const {opts: n, self: r} = e;
        if (!n.strictSchema || typeof t == "boolean")
            return;
        const s = r.RULES.keywords;
        for (const o in t)
            s[o] || pb(e, `unknown keyword: "${o}"`)
    }
    Te.checkUnknownRules = lb;
    function fb(e, t) {
        if (typeof e == "boolean")
            return !e;
        for (const n in e)
            if (t[n])
                return !0;
        return !1
    }
    Te.schemaHasRules = fb;
    function D2(e, t) {
        if (typeof e == "boolean")
            return !e;
        for (const n in e)
            if (n !== "$ref" && t.all[n])
                return !0;
        return !1
    }
    Te.schemaHasRulesButRef = D2;
    function U2({topSchemaRef: e, schemaPath: t}, n, r, s) {
        if (!s) {
            if (typeof n == "number" || typeof n == "boolean")
                return n;
            if (typeof n == "string")
                return (0,
                xt._)`${n}`
        }
        return (0,
        xt._)`${e}${t}${(0,
        xt.getProperty)(r)}`
    }
    Te.schemaRefOrVal = U2;
    function B2(e) {
        return db(decodeURIComponent(e))
    }
    Te.unescapeFragment = B2;
    function F2(e) {
        return encodeURIComponent(wg(e))
    }
    Te.escapeFragment = F2;
    function wg(e) {
        return typeof e == "number" ? `${e}` : e.replace(/~/g, "~0").replace(/\//g, "~1")
    }
    Te.escapeJsonPointer = wg;
    function db(e) {
        return e.replace(/~1/g, "/").replace(/~0/g, "~")
    }
    Te.unescapeJsonPointer = db;
    function j2(e, t) {
        if (Array.isArray(e))
            for (const n of e)
                t(n);
        else
            t(e)
    }
    Te.eachItem = j2;
    function ov({mergeNames: e, mergeToName: t, mergeValues: n, resultToName: r}) {
        return (s, o, c, l) => {
            const f = c === void 0 ? o : c instanceof xt.Name ? (o instanceof xt.Name ? e(s, o, c) : t(s, o, c),
            c) : o instanceof xt.Name ? (t(s, c, o),
            o) : n(o, c);
            return l === xt.Name && !(f instanceof xt.Name) ? r(s, f) : f
        }
    }
    Te.mergeEvaluated = {
        props: ov({
            mergeNames: (e, t, n) => e.if((0,
            xt._)`${n} !== true && ${t} !== undefined`, () => {
                e.if((0,
                xt._)`${t} === true`, () => e.assign(n, !0), () => e.assign(n, (0,
                xt._)`${n} || {}`).code((0,
                xt._)`Object.assign(${n}, ${t})`))
            }
            ),
            mergeToName: (e, t, n) => e.if((0,
            xt._)`${n} !== true`, () => {
                t === !0 ? e.assign(n, !0) : (e.assign(n, (0,
                xt._)`${n} || {}`),
                bg(e, n, t))
            }
            ),
            mergeValues: (e, t) => e === !0 ? !0 : {
                ...e,
                ...t
            },
            resultToName: hb
        }),
        items: ov({
            mergeNames: (e, t, n) => e.if((0,
            xt._)`${n} !== true && ${t} !== undefined`, () => e.assign(n, (0,
            xt._)`${t} === true ? true : ${n} > ${t} ? ${n} : ${t}`)),
            mergeToName: (e, t, n) => e.if((0,
            xt._)`${n} !== true`, () => e.assign(n, t === !0 ? !0 : (0,
            xt._)`${n} > ${t} ? ${n} : ${t}`)),
            mergeValues: (e, t) => e === !0 ? !0 : Math.max(e, t),
            resultToName: (e, t) => e.var("items", t)
        })
    };
    function hb(e, t) {
        if (t === !0)
            return e.var("props", !0);
        const n = e.var("props", (0,
        xt._)`{}`);
        return t !== void 0 && bg(e, n, t),
        n
    }
    Te.evaluatedPropsToName = hb;
    function bg(e, t, n) {
        Object.keys(n).forEach(r => e.assign((0,
        xt._)`${t}${(0,
        xt.getProperty)(r)}`, !0))
    }
    Te.setEvaluated = bg;
    const cv = {};
    function q2(e, t) {
        return e.scopeValue("func", {
            ref: t,
            code: cv[t.code] || (cv[t.code] = new C2._Code(t.code))
        })
    }
    Te.useFunc = q2;
    var fm;
    (function(e) {
        e[e.Num = 0] = "Num",
        e[e.Str = 1] = "Str"
    }
    )(fm || (Te.Type = fm = {}));
    function H2(e, t, n) {
        if (e instanceof xt.Name) {
            const r = t === fm.Num;
            return n ? r ? (0,
            xt._)`"[" + ${e} + "]"` : (0,
            xt._)`"['" + ${e} + "']"` : r ? (0,
            xt._)`"/" + ${e}` : (0,
            xt._)`"/" + ${e}.replace(/~/g, "~0").replace(/\\//g, "~1")`
        }
        return n ? (0,
        xt.getProperty)(e).toString() : "/" + wg(e)
    }
    Te.getErrorPath = H2;
    function pb(e, t, n=e.opts.strictSchema) {
        if (n) {
            if (t = `strict mode: ${t}`,
            n === !0)
                throw new Error(t);
            e.self.logger.warn(t)
        }
    }
    Te.checkStrictMode = pb;
    var oi = {};
    Object.defineProperty(oi, "__esModule", {
        value: !0
    });
    const hn = ot
      , Y2 = {
        data: new hn.Name("data"),
        valCxt: new hn.Name("valCxt"),
        instancePath: new hn.Name("instancePath"),
        parentData: new hn.Name("parentData"),
        parentDataProperty: new hn.Name("parentDataProperty"),
        rootData: new hn.Name("rootData"),
        dynamicAnchors: new hn.Name("dynamicAnchors"),
        vErrors: new hn.Name("vErrors"),
        errors: new hn.Name("errors"),
        this: new hn.Name("this"),
        self: new hn.Name("self"),
        scope: new hn.Name("scope"),
        json: new hn.Name("json"),
        jsonPos: new hn.Name("jsonPos"),
        jsonLen: new hn.Name("jsonLen"),
        jsonPart: new hn.Name("jsonPart")
    };
    oi.default = Y2;
    (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
        const t = ot
          , n = Te
          , r = oi;
        e.keywordError = {
            message: ({keyword: N}) => (0,
            t.str)`must pass "${N}" keyword validation`
        },
        e.keyword$DataError = {
            message: ({keyword: N, schemaType: m}) => m ? (0,
            t.str)`"${N}" keyword must be ${m} ($data)` : (0,
            t.str)`"${N}" keyword is invalid ($data)`
        };
        function s(N, m=e.keywordError, g, M) {
            const {it: G} = N
              , {gen: U, compositeRule: D, allErrors: K} = G
              , _ = y(N, m, g);
            M ?? (D || K) ? f(U, _) : d(G, (0,
            t._)`[${_}]`)
        }
        e.reportError = s;
        function o(N, m=e.keywordError, g) {
            const {it: M} = N
              , {gen: G, compositeRule: U, allErrors: D} = M
              , K = y(N, m, g);
            f(G, K),
            U || D || d(M, r.default.vErrors)
        }
        e.reportExtraError = o;
        function c(N, m) {
            N.assign(r.default.errors, m),
            N.if((0,
            t._)`${r.default.vErrors} !== null`, () => N.if(m, () => N.assign((0,
            t._)`${r.default.vErrors}.length`, m), () => N.assign(r.default.vErrors, null)))
        }
        e.resetErrorsCount = c;
        function l({gen: N, keyword: m, schemaValue: g, data: M, errsCount: G, it: U}) {
            if (G === void 0)
                throw new Error("ajv implementation error");
            const D = N.name("err");
            N.forRange("i", G, r.default.errors, K => {
                N.const(D, (0,
                t._)`${r.default.vErrors}[${K}]`),
                N.if((0,
                t._)`${D}.instancePath === undefined`, () => N.assign((0,
                t._)`${D}.instancePath`, (0,
                t.strConcat)(r.default.instancePath, U.errorPath))),
                N.assign((0,
                t._)`${D}.schemaPath`, (0,
                t.str)`${U.errSchemaPath}/${m}`),
                U.opts.verbose && (N.assign((0,
                t._)`${D}.schema`, g),
                N.assign((0,
                t._)`${D}.data`, M))
            }
            )
        }
        e.extendErrors = l;
        function f(N, m) {
            const g = N.const("err", m);
            N.if((0,
            t._)`${r.default.vErrors} === null`, () => N.assign(r.default.vErrors, (0,
            t._)`[${g}]`), (0,
            t._)`${r.default.vErrors}.push(${g})`),
            N.code((0,
            t._)`${r.default.errors}++`)
        }
        function d(N, m) {
            const {gen: g, validateName: M, schemaEnv: G} = N;
            G.$async ? g.throw((0,
            t._)`new ${N.ValidationError}(${m})`) : (g.assign((0,
            t._)`${M}.errors`, m),
            g.return(!1))
        }
        const h = {
            keyword: new t.Name("keyword"),
            schemaPath: new t.Name("schemaPath"),
            params: new t.Name("params"),
            propertyName: new t.Name("propertyName"),
            message: new t.Name("message"),
            schema: new t.Name("schema"),
            parentSchema: new t.Name("parentSchema")
        };
        function y(N, m, g) {
            const {createErrors: M} = N.it;
            return M === !1 ? (0,
            t._)`{}` : I(N, m, g)
        }
        function I(N, m, g={}) {
            const {gen: M, it: G} = N
              , U = [$(G, g), O(N, g)];
            return A(N, m, U),
            M.object(...U)
        }
        function $({errorPath: N}, {instancePath: m}) {
            const g = m ? (0,
            t.str)`${N}${(0,
            n.getErrorPath)(m, n.Type.Str)}` : N;
            return [r.default.instancePath, (0,
            t.strConcat)(r.default.instancePath, g)]
        }
        function O({keyword: N, it: {errSchemaPath: m}}, {schemaPath: g, parentSchema: M}) {
            let G = M ? m : (0,
            t.str)`${m}/${N}`;
            return g && (G = (0,
            t.str)`${G}${(0,
            n.getErrorPath)(g, n.Type.Str)}`),
            [h.schemaPath, G]
        }
        function A(N, {params: m, message: g}, M) {
            const {keyword: G, data: U, schemaValue: D, it: K} = N
              , {opts: _, propertyName: T, topSchemaRef: S, schemaPath: q} = K;
            M.push([h.keyword, G], [h.params, typeof m == "function" ? m(N) : m || (0,
            t._)`{}`]),
            _.messages && M.push([h.message, typeof g == "function" ? g(N) : g]),
            _.verbose && M.push([h.schema, D], [h.parentSchema, (0,
            t._)`${S}${q}`], [r.default.data, U]),
            T && M.push([h.propertyName, T])
        }
    }
    )(Bu);
    Object.defineProperty(vo, "__esModule", {
        value: !0
    });
    vo.boolOrEmptySchema = vo.topBoolOrEmptySchema = void 0;
    const V2 = Bu
      , W2 = ot
      , z2 = oi
      , G2 = {
        message: "boolean schema is false"
    };
    function Z2(e) {
        const {gen: t, schema: n, validateName: r} = e;
        n === !1 ? mb(e, !1) : typeof n == "object" && n.$async === !0 ? t.return(z2.default.data) : (t.assign((0,
        W2._)`${r}.errors`, null),
        t.return(!0))
    }
    vo.topBoolOrEmptySchema = Z2;
    function K2(e, t) {
        const {gen: n, schema: r} = e;
        r === !1 ? (n.var(t, !1),
        mb(e)) : n.var(t, !0)
    }
    vo.boolOrEmptySchema = K2;
    function mb(e, t) {
        const {gen: n, data: r} = e
          , s = {
            gen: n,
            keyword: "false schema",
            data: r,
            schema: !1,
            schemaCode: !1,
            schemaValue: !1,
            params: {},
            it: e
        };
        (0,
        V2.reportError)(s, G2, void 0, t)
    }
    var Kt = {}
      , sa = {};
    Object.defineProperty(sa, "__esModule", {
        value: !0
    });
    sa.getRules = sa.isJSONType = void 0;
    const J2 = ["string", "number", "integer", "boolean", "null", "object", "array"]
      , X2 = new Set(J2);
    function Q2(e) {
        return typeof e == "string" && X2.has(e)
    }
    sa.isJSONType = Q2;
    function eM() {
        const e = {
            number: {
                type: "number",
                rules: []
            },
            string: {
                type: "string",
                rules: []
            },
            array: {
                type: "array",
                rules: []
            },
            object: {
                type: "object",
                rules: []
            }
        };
        return {
            types: {
                ...e,
                integer: !0,
                boolean: !0,
                null: !0
            },
            rules: [{
                rules: []
            }, e.number, e.string, e.array, e.object],
            post: {
                rules: []
            },
            all: {},
            keywords: {}
        }
    }
    sa.getRules = eM;
    var Di = {};
    Object.defineProperty(Di, "__esModule", {
        value: !0
    });
    Di.shouldUseRule = Di.shouldUseGroup = Di.schemaHasRulesForType = void 0;
    function tM({schema: e, self: t}, n) {
        const r = t.RULES.types[n];
        return r && r !== !0 && gb(e, r)
    }
    Di.schemaHasRulesForType = tM;
    function gb(e, t) {
        return t.rules.some(n => yb(e, n))
    }
    Di.shouldUseGroup = gb;
    function yb(e, t) {
        var n;
        return e[t.keyword] !== void 0 || ((n = t.definition.implements) === null || n === void 0 ? void 0 : n.some(r => e[r] !== void 0))
    }
    Di.shouldUseRule = yb;
    Object.defineProperty(Kt, "__esModule", {
        value: !0
    });
    Kt.reportTypeError = Kt.checkDataTypes = Kt.checkDataType = Kt.coerceAndCheckDataType = Kt.getJSONTypes = Kt.getSchemaTypes = Kt.DataType = void 0;
    const nM = sa
      , rM = Di
      , iM = Bu
      , Qe = ot
      , _b = Te;
    var go;
    (function(e) {
        e[e.Correct = 0] = "Correct",
        e[e.Wrong = 1] = "Wrong"
    }
    )(go || (Kt.DataType = go = {}));
    function sM(e) {
        const t = vb(e.type);
        if (t.includes("null")) {
            if (e.nullable === !1)
                throw new Error("type: null contradicts nullable: false")
        } else {
            if (!t.length && e.nullable !== void 0)
                throw new Error('"nullable" cannot be used without "type"');
            e.nullable === !0 && t.push("null")
        }
        return t
    }
    Kt.getSchemaTypes = sM;
    function vb(e) {
        const t = Array.isArray(e) ? e : e ? [e] : [];
        if (t.every(nM.isJSONType))
            return t;
        throw new Error("type must be JSONType or JSONType[]: " + t.join(","))
    }
    Kt.getJSONTypes = vb;
    function aM(e, t) {
        const {gen: n, data: r, opts: s} = e
          , o = oM(t, s.coerceTypes)
          , c = t.length > 0 && !(o.length === 0 && t.length === 1 && (0,
        rM.schemaHasRulesForType)(e, t[0]));
        if (c) {
            const l = Eg(t, r, s.strictNumbers, go.Wrong);
            n.if(l, () => {
                o.length ? cM(e, t, o) : Sg(e)
            }
            )
        }
        return c
    }
    Kt.coerceAndCheckDataType = aM;
    const wb = new Set(["string", "number", "integer", "boolean", "null"]);
    function oM(e, t) {
        return t ? e.filter(n => wb.has(n) || t === "array" && n === "array") : []
    }
    function cM(e, t, n) {
        const {gen: r, data: s, opts: o} = e
          , c = r.let("dataType", (0,
        Qe._)`typeof ${s}`)
          , l = r.let("coerced", (0,
        Qe._)`undefined`);
        o.coerceTypes === "array" && r.if((0,
        Qe._)`${c} == 'object' && Array.isArray(${s}) && ${s}.length == 1`, () => r.assign(s, (0,
        Qe._)`${s}[0]`).assign(c, (0,
        Qe._)`typeof ${s}`).if(Eg(t, s, o.strictNumbers), () => r.assign(l, s))),
        r.if((0,
        Qe._)`${l} !== undefined`);
        for (const d of n)
            (wb.has(d) || d === "array" && o.coerceTypes === "array") && f(d);
        r.else(),
        Sg(e),
        r.endIf(),
        r.if((0,
        Qe._)`${l} !== undefined`, () => {
            r.assign(s, l),
            uM(e, l)
        }
        );
        function f(d) {
            switch (d) {
            case "string":
                r.elseIf((0,
                Qe._)`${c} == "number" || ${c} == "boolean"`).assign(l, (0,
                Qe._)`"" + ${s}`).elseIf((0,
                Qe._)`${s} === null`).assign(l, (0,
                Qe._)`""`);
                return;
            case "number":
                r.elseIf((0,
                Qe._)`${c} == "boolean" || ${s} === null
              || (${c} == "string" && ${s} && ${s} == +${s})`).assign(l, (0,
                Qe._)`+${s}`);
                return;
            case "integer":
                r.elseIf((0,
                Qe._)`${c} === "boolean" || ${s} === null
              || (${c} === "string" && ${s} && ${s} == +${s} && !(${s} % 1))`).assign(l, (0,
                Qe._)`+${s}`);
                return;
            case "boolean":
                r.elseIf((0,
                Qe._)`${s} === "false" || ${s} === 0 || ${s} === null`).assign(l, !1).elseIf((0,
                Qe._)`${s} === "true" || ${s} === 1`).assign(l, !0);
                return;
            case "null":
                r.elseIf((0,
                Qe._)`${s} === "" || ${s} === 0 || ${s} === false`),
                r.assign(l, null);
                return;
            case "array":
                r.elseIf((0,
                Qe._)`${c} === "string" || ${c} === "number"
              || ${c} === "boolean" || ${s} === null`).assign(l, (0,
                Qe._)`[${s}]`)
            }
        }
    }
    function uM({gen: e, parentData: t, parentDataProperty: n}, r) {
        e.if((0,
        Qe._)`${t} !== undefined`, () => e.assign((0,
        Qe._)`${t}[${n}]`, r))
    }
    function dm(e, t, n, r=go.Correct) {
        const s = r === go.Correct ? Qe.operators.EQ : Qe.operators.NEQ;
        let o;
        switch (e) {
        case "null":
            return (0,
            Qe._)`${t} ${s} null`;
        case "array":
            o = (0,
            Qe._)`Array.isArray(${t})`;
            break;
        case "object":
            o = (0,
            Qe._)`${t} && typeof ${t} == "object" && !Array.isArray(${t})`;
            break;
        case "integer":
            o = c((0,
            Qe._)`!(${t} % 1) && !isNaN(${t})`);
            break;
        case "number":
            o = c();
            break;
        default:
            return (0,
            Qe._)`typeof ${t} ${s} ${e}`
        }
        return r === go.Correct ? o : (0,
        Qe.not)(o);
        function c(l=Qe.nil) {
            return (0,
            Qe.and)((0,
            Qe._)`typeof ${t} == "number"`, l, n ? (0,
            Qe._)`isFinite(${t})` : Qe.nil)
        }
    }
    Kt.checkDataType = dm;
    function Eg(e, t, n, r) {
        if (e.length === 1)
            return dm(e[0], t, n, r);
        let s;
        const o = (0,
        _b.toHash)(e);
        if (o.array && o.object) {
            const c = (0,
            Qe._)`typeof ${t} != "object"`;
            s = o.null ? c : (0,
            Qe._)`!${t} || ${c}`,
            delete o.null,
            delete o.array,
            delete o.object
        } else
            s = Qe.nil;
        o.number && delete o.integer;
        for (const c in o)
            s = (0,
            Qe.and)(s, dm(c, t, n, r));
        return s
    }
    Kt.checkDataTypes = Eg;
    const lM = {
        message: ({schema: e}) => `must be ${e}`,
        params: ({schema: e, schemaValue: t}) => typeof e == "string" ? (0,
        Qe._)`{type: ${e}}` : (0,
        Qe._)`{type: ${t}}`
    };
    function Sg(e) {
        const t = fM(e);
        (0,
        iM.reportError)(t, lM)
    }
    Kt.reportTypeError = Sg;
    function fM(e) {
        const {gen: t, data: n, schema: r} = e
          , s = (0,
        _b.schemaRefOrVal)(e, r, "type");
        return {
            gen: t,
            keyword: "type",
            data: n,
            schema: r.type,
            schemaCode: s,
            schemaValue: s,
            parentSchema: r,
            params: {},
            it: e
        }
    }
    var $d = {};
    Object.defineProperty($d, "__esModule", {
        value: !0
    });
    $d.assignDefaults = void 0;
    const Ka = ot
      , dM = Te;
    function hM(e, t) {
        const {properties: n, items: r} = e.schema;
        if (t === "object" && n)
            for (const s in n)
                uv(e, s, n[s].default);
        else
            t === "array" && Array.isArray(r) && r.forEach( (s, o) => uv(e, o, s.default))
    }
    $d.assignDefaults = hM;
    function uv(e, t, n) {
        const {gen: r, compositeRule: s, data: o, opts: c} = e;
        if (n === void 0)
            return;
        const l = (0,
        Ka._)`${o}${(0,
        Ka.getProperty)(t)}`;
        if (s) {
            (0,
            dM.checkStrictMode)(e, `default is ignored for: ${l}`);
            return
        }
        let f = (0,
        Ka._)`${l} === undefined`;
        c.useDefaults === "empty" && (f = (0,
        Ka._)`${f} || ${l} === null || ${l} === ""`),
        r.if(f, (0,
        Ka._)`${l} = ${(0,
        Ka.stringify)(n)}`)
    }
    var Qr = {}
      , at = {};
    Object.defineProperty(at, "__esModule", {
        value: !0
    });
    at.validateUnion = at.validateArray = at.usePattern = at.callValidateCode = at.schemaProperties = at.allSchemaProperties = at.noPropertyInData = at.propertyInData = at.isOwnProperty = at.hasPropFunc = at.reportMissingProp = at.checkMissingProp = at.checkReportMissingProp = void 0;
    const $t = ot
      , Tg = Te
      , us = oi
      , pM = Te;
    function mM(e, t) {
        const {gen: n, data: r, it: s} = e;
        n.if(Og(n, r, t, s.opts.ownProperties), () => {
            e.setParams({
                missingProperty: (0,
                $t._)`${t}`
            }, !0),
            e.error()
        }
        )
    }
    at.checkReportMissingProp = mM;
    function gM({gen: e, data: t, it: {opts: n}}, r, s) {
        return (0,
        $t.or)(...r.map(o => (0,
        $t.and)(Og(e, t, o, n.ownProperties), (0,
        $t._)`${s} = ${o}`)))
    }
    at.checkMissingProp = gM;
    function yM(e, t) {
        e.setParams({
            missingProperty: t
        }, !0),
        e.error()
    }
    at.reportMissingProp = yM;
    function bb(e) {
        return e.scopeValue("func", {
            ref: Object.prototype.hasOwnProperty,
            code: (0,
            $t._)`Object.prototype.hasOwnProperty`
        })
    }
    at.hasPropFunc = bb;
    function Ag(e, t, n) {
        return (0,
        $t._)`${bb(e)}.call(${t}, ${n})`
    }
    at.isOwnProperty = Ag;
    function _M(e, t, n, r) {
        const s = (0,
        $t._)`${t}${(0,
        $t.getProperty)(n)} !== undefined`;
        return r ? (0,
        $t._)`${s} && ${Ag(e, t, n)}` : s
    }
    at.propertyInData = _M;
    function Og(e, t, n, r) {
        const s = (0,
        $t._)`${t}${(0,
        $t.getProperty)(n)} === undefined`;
        return r ? (0,
        $t.or)(s, (0,
        $t.not)(Ag(e, t, n))) : s
    }
    at.noPropertyInData = Og;
    function Eb(e) {
        return e ? Object.keys(e).filter(t => t !== "__proto__") : []
    }
    at.allSchemaProperties = Eb;
    function vM(e, t) {
        return Eb(t).filter(n => !(0,
        Tg.alwaysValidSchema)(e, t[n]))
    }
    at.schemaProperties = vM;
    function wM({schemaCode: e, data: t, it: {gen: n, topSchemaRef: r, schemaPath: s, errorPath: o}, it: c}, l, f, d) {
        const h = d ? (0,
        $t._)`${e}, ${t}, ${r}${s}` : t
          , y = [[us.default.instancePath, (0,
        $t.strConcat)(us.default.instancePath, o)], [us.default.parentData, c.parentData], [us.default.parentDataProperty, c.parentDataProperty], [us.default.rootData, us.default.rootData]];
        c.opts.dynamicRef && y.push([us.default.dynamicAnchors, us.default.dynamicAnchors]);
        const I = (0,
        $t._)`${h}, ${n.object(...y)}`;
        return f !== $t.nil ? (0,
        $t._)`${l}.call(${f}, ${I})` : (0,
        $t._)`${l}(${I})`
    }
    at.callValidateCode = wM;
    const bM = (0,
    $t._)`new RegExp`;
    function EM({gen: e, it: {opts: t}}, n) {
        const r = t.unicodeRegExp ? "u" : ""
          , {regExp: s} = t.code
          , o = s(n, r);
        return e.scopeValue("pattern", {
            key: o.toString(),
            ref: o,
            code: (0,
            $t._)`${s.code === "new RegExp" ? bM : (0,
            pM.useFunc)(e, s)}(${n}, ${r})`
        })
    }
    at.usePattern = EM;
    function SM(e) {
        const {gen: t, data: n, keyword: r, it: s} = e
          , o = t.name("valid");
        if (s.allErrors) {
            const l = t.let("valid", !0);
            return c( () => t.assign(l, !1)),
            l
        }
        return t.var(o, !0),
        c( () => t.break()),
        o;
        function c(l) {
            const f = t.const("len", (0,
            $t._)`${n}.length`);
            t.forRange("i", 0, f, d => {
                e.subschema({
                    keyword: r,
                    dataProp: d,
                    dataPropType: Tg.Type.Num
                }, o),
                t.if((0,
                $t.not)(o), l)
            }
            )
        }
    }
    at.validateArray = SM;
    function TM(e) {
        const {gen: t, schema: n, keyword: r, it: s} = e;
        if (!Array.isArray(n))
            throw new Error("ajv implementation error");
        if (n.some(f => (0,
        Tg.alwaysValidSchema)(s, f)) && !s.opts.unevaluated)
            return;
        const c = t.let("valid", !1)
          , l = t.name("_valid");
        t.block( () => n.forEach( (f, d) => {
            const h = e.subschema({
                keyword: r,
                schemaProp: d,
                compositeRule: !0
            }, l);
            t.assign(c, (0,
            $t._)`${c} || ${l}`),
            e.mergeValidEvaluated(h, l) || t.if((0,
            $t.not)(c))
        }
        )),
        e.result(c, () => e.reset(), () => e.error(!0))
    }
    at.validateUnion = TM;
    Object.defineProperty(Qr, "__esModule", {
        value: !0
    });
    Qr.validateKeywordUsage = Qr.validSchemaType = Qr.funcKeywordCode = Qr.macroKeywordCode = void 0;
    const bn = ot
      , zs = oi
      , AM = at
      , OM = Bu;
    function IM(e, t) {
        const {gen: n, keyword: r, schema: s, parentSchema: o, it: c} = e
          , l = t.macro.call(c.self, s, o, c)
          , f = Sb(n, r, l);
        c.opts.validateSchema !== !1 && c.self.validateSchema(l, !0);
        const d = n.name("valid");
        e.subschema({
            schema: l,
            schemaPath: bn.nil,
            errSchemaPath: `${c.errSchemaPath}/${r}`,
            topSchemaRef: f,
            compositeRule: !0
        }, d),
        e.pass(d, () => e.error(!0))
    }
    Qr.macroKeywordCode = IM;
    function NM(e, t) {
        var n;
        const {gen: r, keyword: s, schema: o, parentSchema: c, $data: l, it: f} = e;
        $M(f, t);
        const d = !l && t.compile ? t.compile.call(f.self, o, c, f) : t.validate
          , h = Sb(r, s, d)
          , y = r.let("valid");
        e.block$data(y, I),
        e.ok((n = t.valid) !== null && n !== void 0 ? n : y);
        function I() {
            if (t.errors === !1)
                A(),
                t.modifying && lv(e),
                N( () => e.error());
            else {
                const m = t.async ? $() : O();
                t.modifying && lv(e),
                N( () => xM(e, m))
            }
        }
        function $() {
            const m = r.let("ruleErrs", null);
            return r.try( () => A((0,
            bn._)`await `), g => r.assign(y, !1).if((0,
            bn._)`${g} instanceof ${f.ValidationError}`, () => r.assign(m, (0,
            bn._)`${g}.errors`), () => r.throw(g))),
            m
        }
        function O() {
            const m = (0,
            bn._)`${h}.errors`;
            return r.assign(m, null),
            A(bn.nil),
            m
        }
        function A(m=t.async ? (0,
        bn._)`await ` : bn.nil) {
            const g = f.opts.passContext ? zs.default.this : zs.default.self
              , M = !("compile"in t && !l || t.schema === !1);
            r.assign(y, (0,
            bn._)`${m}${(0,
            AM.callValidateCode)(e, h, g, M)}`, t.modifying)
        }
        function N(m) {
            var g;
            r.if((0,
            bn.not)((g = t.valid) !== null && g !== void 0 ? g : y), m)
        }
    }
    Qr.funcKeywordCode = NM;
    function lv(e) {
        const {gen: t, data: n, it: r} = e;
        t.if(r.parentData, () => t.assign(n, (0,
        bn._)`${r.parentData}[${r.parentDataProperty}]`))
    }
    function xM(e, t) {
        const {gen: n} = e;
        n.if((0,
        bn._)`Array.isArray(${t})`, () => {
            n.assign(zs.default.vErrors, (0,
            bn._)`${zs.default.vErrors} === null ? ${t} : ${zs.default.vErrors}.concat(${t})`).assign(zs.default.errors, (0,
            bn._)`${zs.default.vErrors}.length`),
            (0,
            OM.extendErrors)(e)
        }
        , () => e.error())
    }
    function $M({schemaEnv: e}, t) {
        if (t.async && !e.$async)
            throw new Error("async keyword in sync schema")
    }
    function Sb(e, t, n) {
        if (n === void 0)
            throw new Error(`keyword "${t}" failed to compile`);
        return e.scopeValue("keyword", typeof n == "function" ? {
            ref: n
        } : {
            ref: n,
            code: (0,
            bn.stringify)(n)
        })
    }
    function RM(e, t, n=!1) {
        return !t.length || t.some(r => r === "array" ? Array.isArray(e) : r === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == r || n && typeof e > "u")
    }
    Qr.validSchemaType = RM;
    function PM({schema: e, opts: t, self: n, errSchemaPath: r}, s, o) {
        if (Array.isArray(s.keyword) ? !s.keyword.includes(o) : s.keyword !== o)
            throw new Error("ajv implementation error");
        const c = s.dependencies;
        if (c?.some(l => !Object.prototype.hasOwnProperty.call(e, l)))
            throw new Error(`parent schema must have dependencies of ${o}: ${c.join(",")}`);
        if (s.validateSchema && !s.validateSchema(e[o])) {
            const f = `keyword "${o}" value is invalid at path "${r}": ` + n.errorsText(s.validateSchema.errors);
            if (t.validateSchema === "log")
                n.logger.error(f);
            else
                throw new Error(f)
        }
    }
    Qr.validateKeywordUsage = PM;
    var Es = {};
    Object.defineProperty(Es, "__esModule", {
        value: !0
    });
    Es.extendSubschemaMode = Es.extendSubschemaData = Es.getSubschema = void 0;
    const Jr = ot
      , Tb = Te;
    function kM(e, {keyword: t, schemaProp: n, schema: r, schemaPath: s, errSchemaPath: o, topSchemaRef: c}) {
        if (t !== void 0 && r !== void 0)
            throw new Error('both "keyword" and "schema" passed, only one allowed');
        if (t !== void 0) {
            const l = e.schema[t];
            return n === void 0 ? {
                schema: l,
                schemaPath: (0,
                Jr._)`${e.schemaPath}${(0,
                Jr.getProperty)(t)}`,
                errSchemaPath: `${e.errSchemaPath}/${t}`
            } : {
                schema: l[n],
                schemaPath: (0,
                Jr._)`${e.schemaPath}${(0,
                Jr.getProperty)(t)}${(0,
                Jr.getProperty)(n)}`,
                errSchemaPath: `${e.errSchemaPath}/${t}/${(0,
                Tb.escapeFragment)(n)}`
            }
        }
        if (r !== void 0) {
            if (s === void 0 || o === void 0 || c === void 0)
                throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
            return {
                schema: r,
                schemaPath: s,
                topSchemaRef: c,
                errSchemaPath: o
            }
        }
        throw new Error('either "keyword" or "schema" must be passed')
    }
    Es.getSubschema = kM;
    function CM(e, t, {dataProp: n, dataPropType: r, data: s, dataTypes: o, propertyName: c}) {
        if (s !== void 0 && n !== void 0)
            throw new Error('both "data" and "dataProp" passed, only one allowed');
        const {gen: l} = t;
        if (n !== void 0) {
            const {errorPath: d, dataPathArr: h, opts: y} = t
              , I = l.let("data", (0,
            Jr._)`${t.data}${(0,
            Jr.getProperty)(n)}`, !0);
            f(I),
            e.errorPath = (0,
            Jr.str)`${d}${(0,
            Tb.getErrorPath)(n, r, y.jsPropertySyntax)}`,
            e.parentDataProperty = (0,
            Jr._)`${n}`,
            e.dataPathArr = [...h, e.parentDataProperty]
        }
        if (s !== void 0) {
            const d = s instanceof Jr.Name ? s : l.let("data", s, !0);
            f(d),
            c !== void 0 && (e.propertyName = c)
        }
        o && (e.dataTypes = o);
        function f(d) {
            e.data = d,
            e.dataLevel = t.dataLevel + 1,
            e.dataTypes = [],
            t.definedProperties = new Set,
            e.parentData = t.data,
            e.dataNames = [...t.dataNames, d]
        }
    }
    Es.extendSubschemaData = CM;
    function MM(e, {jtdDiscriminator: t, jtdMetadata: n, compositeRule: r, createErrors: s, allErrors: o}) {
        r !== void 0 && (e.compositeRule = r),
        s !== void 0 && (e.createErrors = s),
        o !== void 0 && (e.allErrors = o),
        e.jtdDiscriminator = t,
        e.jtdMetadata = n
    }
    Es.extendSubschemaMode = MM;
    var ln = {}
      , Ab = function e(t, n) {
        if (t === n)
            return !0;
        if (t && n && typeof t == "object" && typeof n == "object") {
            if (t.constructor !== n.constructor)
                return !1;
            var r, s, o;
            if (Array.isArray(t)) {
                if (r = t.length,
                r != n.length)
                    return !1;
                for (s = r; s-- !== 0; )
                    if (!e(t[s], n[s]))
                        return !1;
                return !0
            }
            if (t.constructor === RegExp)
                return t.source === n.source && t.flags === n.flags;
            if (t.valueOf !== Object.prototype.valueOf)
                return t.valueOf() === n.valueOf();
            if (t.toString !== Object.prototype.toString)
                return t.toString() === n.toString();
            if (o = Object.keys(t),
            r = o.length,
            r !== Object.keys(n).length)
                return !1;
            for (s = r; s-- !== 0; )
                if (!Object.prototype.hasOwnProperty.call(n, o[s]))
                    return !1;
            for (s = r; s-- !== 0; ) {
                var c = o[s];
                if (!e(t[c], n[c]))
                    return !1
            }
            return !0
        }
        return t !== t && n !== n
    }
      , Ob = {
        exports: {}
    }
      , vs = Ob.exports = function(e, t, n) {
        typeof t == "function" && (n = t,
        t = {}),
        n = t.cb || n;
        var r = typeof n == "function" ? n : n.pre || function() {}
          , s = n.post || function() {}
        ;
        vf(t, r, s, e, "", e)
    }
    ;
    vs.keywords = {
        additionalItems: !0,
        items: !0,
        contains: !0,
        additionalProperties: !0,
        propertyNames: !0,
        not: !0,
        if: !0,
        then: !0,
        else: !0
    };
    vs.arrayKeywords = {
        items: !0,
        allOf: !0,
        anyOf: !0,
        oneOf: !0
    };
    vs.propsKeywords = {
        $defs: !0,
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0
    };
    vs.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0
    };
    function vf(e, t, n, r, s, o, c, l, f, d) {
        if (r && typeof r == "object" && !Array.isArray(r)) {
            t(r, s, o, c, l, f, d);
            for (var h in r) {
                var y = r[h];
                if (Array.isArray(y)) {
                    if (h in vs.arrayKeywords)
                        for (var I = 0; I < y.length; I++)
                            vf(e, t, n, y[I], s + "/" + h + "/" + I, o, s, h, r, I)
                } else if (h in vs.propsKeywords) {
                    if (y && typeof y == "object")
                        for (var $ in y)
                            vf(e, t, n, y[$], s + "/" + h + "/" + LM($), o, s, h, r, $)
                } else
                    (h in vs.keywords || e.allKeys && !(h in vs.skipKeywords)) && vf(e, t, n, y, s + "/" + h, o, s, h, r)
            }
            n(r, s, o, c, l, f, d)
        }
    }
    function LM(e) {
        return e.replace(/~/g, "~0").replace(/\//g, "~1")
    }
    var DM = Ob.exports;
    Object.defineProperty(ln, "__esModule", {
        value: !0
    });
    ln.getSchemaRefs = ln.resolveUrl = ln.normalizeId = ln._getFullPath = ln.getFullPath = ln.inlineRef = void 0;
    const UM = Te
      , BM = Ab
      , FM = DM
      , jM = new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
    function qM(e, t=!0) {
        return typeof e == "boolean" ? !0 : t === !0 ? !hm(e) : t ? Ib(e) <= t : !1
    }
    ln.inlineRef = qM;
    const HM = new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
    function hm(e) {
        for (const t in e) {
            if (HM.has(t))
                return !0;
            const n = e[t];
            if (Array.isArray(n) && n.some(hm) || typeof n == "object" && hm(n))
                return !0
        }
        return !1
    }
    function Ib(e) {
        let t = 0;
        for (const n in e) {
            if (n === "$ref")
                return 1 / 0;
            if (t++,
            !jM.has(n) && (typeof e[n] == "object" && (0,
            UM.eachItem)(e[n], r => t += Ib(r)),
            t === 1 / 0))
                return 1 / 0
        }
        return t
    }
    function Nb(e, t="", n) {
        n !== !1 && (t = yo(t));
        const r = e.parse(t);
        return xb(e, r)
    }
    ln.getFullPath = Nb;
    function xb(e, t) {
        return e.serialize(t).split("#")[0] + "#"
    }
    ln._getFullPath = xb;
    const YM = /#\/?$/;
    function yo(e) {
        return e ? e.replace(YM, "") : ""
    }
    ln.normalizeId = yo;
    function VM(e, t, n) {
        return n = yo(n),
        e.resolve(t, n)
    }
    ln.resolveUrl = VM;
    const WM = /^[a-z_][-a-z0-9._]*$/i;
    function zM(e, t) {
        if (typeof e == "boolean")
            return {};
        const {schemaId: n, uriResolver: r} = this.opts
          , s = yo(e[n] || t)
          , o = {
            "": s
        }
          , c = Nb(r, s, !1)
          , l = {}
          , f = new Set;
        return FM(e, {
            allKeys: !0
        }, (y, I, $, O) => {
            if (O === void 0)
                return;
            const A = c + I;
            let N = o[O];
            typeof y[n] == "string" && (N = m.call(this, y[n])),
            g.call(this, y.$anchor),
            g.call(this, y.$dynamicAnchor),
            o[I] = N;
            function m(M) {
                const G = this.opts.uriResolver.resolve;
                if (M = yo(N ? G(N, M) : M),
                f.has(M))
                    throw h(M);
                f.add(M);
                let U = this.refs[M];
                return typeof U == "string" && (U = this.refs[U]),
                typeof U == "object" ? d(y, U.schema, M) : M !== yo(A) && (M[0] === "#" ? (d(y, l[M], M),
                l[M] = y) : this.refs[M] = A),
                M
            }
            function g(M) {
                if (typeof M == "string") {
                    if (!WM.test(M))
                        throw new Error(`invalid anchor "${M}"`);
                    m.call(this, `#${M}`)
                }
            }
        }
        ),
        l;
        function d(y, I, $) {
            if (I !== void 0 && !BM(y, I))
                throw h($)
        }
        function h(y) {
            return new Error(`reference "${y}" resolves to more than one schema`)
        }
    }
    ln.getSchemaRefs = zM;
    Object.defineProperty(kr, "__esModule", {
        value: !0
    });
    kr.getData = kr.KeywordCxt = kr.validateFunctionCode = void 0;
    const $b = vo
      , fv = Kt
      , Ig = Di
      , Pf = Kt
      , GM = $d
      , Xc = Qr
      , Ep = Es
      , ke = ot
      , Ve = oi
      , ZM = ln
      , Ui = Te
      , xc = Bu;
    function KM(e) {
        if (kb(e) && (Cb(e),
        Pb(e))) {
            QM(e);
            return
        }
        Rb(e, () => (0,
        $b.topBoolOrEmptySchema)(e))
    }
    kr.validateFunctionCode = KM;
    function Rb({gen: e, validateName: t, schema: n, schemaEnv: r, opts: s}, o) {
        s.code.es5 ? e.func(t, (0,
        ke._)`${Ve.default.data}, ${Ve.default.valCxt}`, r.$async, () => {
            e.code((0,
            ke._)`"use strict"; ${dv(n, s)}`),
            XM(e, s),
            e.code(o)
        }
        ) : e.func(t, (0,
        ke._)`${Ve.default.data}, ${JM(s)}`, r.$async, () => e.code(dv(n, s)).code(o))
    }
    function JM(e) {
        return (0,
        ke._)`{${Ve.default.instancePath}="", ${Ve.default.parentData}, ${Ve.default.parentDataProperty}, ${Ve.default.rootData}=${Ve.default.data}${e.dynamicRef ? (0,
        ke._)`, ${Ve.default.dynamicAnchors}={}` : ke.nil}}={}`
    }
    function XM(e, t) {
        e.if(Ve.default.valCxt, () => {
            e.var(Ve.default.instancePath, (0,
            ke._)`${Ve.default.valCxt}.${Ve.default.instancePath}`),
            e.var(Ve.default.parentData, (0,
            ke._)`${Ve.default.valCxt}.${Ve.default.parentData}`),
            e.var(Ve.default.parentDataProperty, (0,
            ke._)`${Ve.default.valCxt}.${Ve.default.parentDataProperty}`),
            e.var(Ve.default.rootData, (0,
            ke._)`${Ve.default.valCxt}.${Ve.default.rootData}`),
            t.dynamicRef && e.var(Ve.default.dynamicAnchors, (0,
            ke._)`${Ve.default.valCxt}.${Ve.default.dynamicAnchors}`)
        }
        , () => {
            e.var(Ve.default.instancePath, (0,
            ke._)`""`),
            e.var(Ve.default.parentData, (0,
            ke._)`undefined`),
            e.var(Ve.default.parentDataProperty, (0,
            ke._)`undefined`),
            e.var(Ve.default.rootData, Ve.default.data),
            t.dynamicRef && e.var(Ve.default.dynamicAnchors, (0,
            ke._)`{}`)
        }
        )
    }
    function QM(e) {
        const {schema: t, opts: n, gen: r} = e;
        Rb(e, () => {
            n.$comment && t.$comment && Lb(e),
            iL(e),
            r.let(Ve.default.vErrors, null),
            r.let(Ve.default.errors, 0),
            n.unevaluated && eL(e),
            Mb(e),
            oL(e)
        }
        )
    }
    function eL(e) {
        const {gen: t, validateName: n} = e;
        e.evaluated = t.const("evaluated", (0,
        ke._)`${n}.evaluated`),
        t.if((0,
        ke._)`${e.evaluated}.dynamicProps`, () => t.assign((0,
        ke._)`${e.evaluated}.props`, (0,
        ke._)`undefined`)),
        t.if((0,
        ke._)`${e.evaluated}.dynamicItems`, () => t.assign((0,
        ke._)`${e.evaluated}.items`, (0,
        ke._)`undefined`))
    }
    function dv(e, t) {
        const n = typeof e == "object" && e[t.schemaId];
        return n && (t.code.source || t.code.process) ? (0,
        ke._)`/*# sourceURL=${n} */` : ke.nil
    }
    function tL(e, t) {
        if (kb(e) && (Cb(e),
        Pb(e))) {
            nL(e, t);
            return
        }
        (0,
        $b.boolOrEmptySchema)(e, t)
    }
    function Pb({schema: e, self: t}) {
        if (typeof e == "boolean")
            return !e;
        for (const n in e)
            if (t.RULES.all[n])
                return !0;
        return !1
    }
    function kb(e) {
        return typeof e.schema != "boolean"
    }
    function nL(e, t) {
        const {schema: n, gen: r, opts: s} = e;
        s.$comment && n.$comment && Lb(e),
        sL(e),
        aL(e);
        const o = r.const("_errs", Ve.default.errors);
        Mb(e, o),
        r.var(t, (0,
        ke._)`${o} === ${Ve.default.errors}`)
    }
    function Cb(e) {
        (0,
        Ui.checkUnknownRules)(e),
        rL(e)
    }
    function Mb(e, t) {
        if (e.opts.jtd)
            return hv(e, [], !1, t);
        const n = (0,
        fv.getSchemaTypes)(e.schema)
          , r = (0,
        fv.coerceAndCheckDataType)(e, n);
        hv(e, n, !r, t)
    }
    function rL(e) {
        const {schema: t, errSchemaPath: n, opts: r, self: s} = e;
        t.$ref && r.ignoreKeywordsWithRef && (0,
        Ui.schemaHasRulesButRef)(t, s.RULES) && s.logger.warn(`$ref: keywords ignored in schema at path "${n}"`)
    }
    function iL(e) {
        const {schema: t, opts: n} = e;
        t.default !== void 0 && n.useDefaults && n.strictSchema && (0,
        Ui.checkStrictMode)(e, "default is ignored in the schema root")
    }
    function sL(e) {
        const t = e.schema[e.opts.schemaId];
        t && (e.baseId = (0,
        ZM.resolveUrl)(e.opts.uriResolver, e.baseId, t))
    }
    function aL(e) {
        if (e.schema.$async && !e.schemaEnv.$async)
            throw new Error("async schema in sync schema")
    }
    function Lb({gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: s}) {
        const o = n.$comment;
        if (s.$comment === !0)
            e.code((0,
            ke._)`${Ve.default.self}.logger.log(${o})`);
        else if (typeof s.$comment == "function") {
            const c = (0,
            ke.str)`${r}/$comment`
              , l = e.scopeValue("root", {
                ref: t.root
            });
            e.code((0,
            ke._)`${Ve.default.self}.opts.$comment(${o}, ${c}, ${l}.schema)`)
        }
    }
    function oL(e) {
        const {gen: t, schemaEnv: n, validateName: r, ValidationError: s, opts: o} = e;
        n.$async ? t.if((0,
        ke._)`${Ve.default.errors} === 0`, () => t.return(Ve.default.data), () => t.throw((0,
        ke._)`new ${s}(${Ve.default.vErrors})`)) : (t.assign((0,
        ke._)`${r}.errors`, Ve.default.vErrors),
        o.unevaluated && cL(e),
        t.return((0,
        ke._)`${Ve.default.errors} === 0`))
    }
    function cL({gen: e, evaluated: t, props: n, items: r}) {
        n instanceof ke.Name && e.assign((0,
        ke._)`${t}.props`, n),
        r instanceof ke.Name && e.assign((0,
        ke._)`${t}.items`, r)
    }
    function hv(e, t, n, r) {
        const {gen: s, schema: o, data: c, allErrors: l, opts: f, self: d} = e
          , {RULES: h} = d;
        if (o.$ref && (f.ignoreKeywordsWithRef || !(0,
        Ui.schemaHasRulesButRef)(o, h))) {
            s.block( () => Bb(e, "$ref", h.all.$ref.definition));
            return
        }
        f.jtd || uL(e, t),
        s.block( () => {
            for (const I of h.rules)
                y(I);
            y(h.post)
        }
        );
        function y(I) {
            (0,
            Ig.shouldUseGroup)(o, I) && (I.type ? (s.if((0,
            Pf.checkDataType)(I.type, c, f.strictNumbers)),
            pv(e, I),
            t.length === 1 && t[0] === I.type && n && (s.else(),
            (0,
            Pf.reportTypeError)(e)),
            s.endIf()) : pv(e, I),
            l || s.if((0,
            ke._)`${Ve.default.errors} === ${r || 0}`))
        }
    }
    function pv(e, t) {
        const {gen: n, schema: r, opts: {useDefaults: s}} = e;
        s && (0,
        GM.assignDefaults)(e, t.type),
        n.block( () => {
            for (const o of t.rules)
                (0,
                Ig.shouldUseRule)(r, o) && Bb(e, o.keyword, o.definition, t.type)
        }
        )
    }
    function uL(e, t) {
        e.schemaEnv.meta || !e.opts.strictTypes || (lL(e, t),
        e.opts.allowUnionTypes || fL(e, t),
        dL(e, e.dataTypes))
    }
    function lL(e, t) {
        if (t.length) {
            if (!e.dataTypes.length) {
                e.dataTypes = t;
                return
            }
            t.forEach(n => {
                Db(e.dataTypes, n) || Ng(e, `type "${n}" not allowed by context "${e.dataTypes.join(",")}"`)
            }
            ),
            pL(e, t)
        }
    }
    function fL(e, t) {
        t.length > 1 && !(t.length === 2 && t.includes("null")) && Ng(e, "use allowUnionTypes to allow union type keyword")
    }
    function dL(e, t) {
        const n = e.self.RULES.all;
        for (const r in n) {
            const s = n[r];
            if (typeof s == "object" && (0,
            Ig.shouldUseRule)(e.schema, s)) {
                const {type: o} = s.definition;
                o.length && !o.some(c => hL(t, c)) && Ng(e, `missing type "${o.join(",")}" for keyword "${r}"`)
            }
        }
    }
    function hL(e, t) {
        return e.includes(t) || t === "number" && e.includes("integer")
    }
    function Db(e, t) {
        return e.includes(t) || t === "integer" && e.includes("number")
    }
    function pL(e, t) {
        const n = [];
        for (const r of e.dataTypes)
            Db(t, r) ? n.push(r) : t.includes("integer") && r === "number" && n.push("integer");
        e.dataTypes = n
    }
    function Ng(e, t) {
        const n = e.schemaEnv.baseId + e.errSchemaPath;
        t += ` at "${n}" (strictTypes)`,
        (0,
        Ui.checkStrictMode)(e, t, e.opts.strictTypes)
    }
    class Ub {
        constructor(t, n, r) {
            if ((0,
            Xc.validateKeywordUsage)(t, n, r),
            this.gen = t.gen,
            this.allErrors = t.allErrors,
            this.keyword = r,
            this.data = t.data,
            this.schema = t.schema[r],
            this.$data = n.$data && t.opts.$data && this.schema && this.schema.$data,
            this.schemaValue = (0,
            Ui.schemaRefOrVal)(t, this.schema, r, this.$data),
            this.schemaType = n.schemaType,
            this.parentSchema = t.schema,
            this.params = {},
            this.it = t,
            this.def = n,
            this.$data)
                this.schemaCode = t.gen.const("vSchema", Fb(this.$data, t));
            else if (this.schemaCode = this.schemaValue,
            !(0,
            Xc.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
                throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
            ("code"in n ? n.trackErrors : n.errors !== !1) && (this.errsCount = t.gen.const("_errs", Ve.default.errors))
        }
        result(t, n, r) {
            this.failResult((0,
            ke.not)(t), n, r)
        }
        failResult(t, n, r) {
            this.gen.if(t),
            r ? r() : this.error(),
            n ? (this.gen.else(),
            n(),
            this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else()
        }
        pass(t, n) {
            this.failResult((0,
            ke.not)(t), void 0, n)
        }
        fail(t) {
            if (t === void 0) {
                this.error(),
                this.allErrors || this.gen.if(!1);
                return
            }
            this.gen.if(t),
            this.error(),
            this.allErrors ? this.gen.endIf() : this.gen.else()
        }
        fail$data(t) {
            if (!this.$data)
                return this.fail(t);
            const {schemaCode: n} = this;
            this.fail((0,
            ke._)`${n} !== undefined && (${(0,
            ke.or)(this.invalid$data(), t)})`)
        }
        error(t, n, r) {
            if (n) {
                this.setParams(n),
                this._error(t, r),
                this.setParams({});
                return
            }
            this._error(t, r)
        }
        _error(t, n) {
            (t ? xc.reportExtraError : xc.reportError)(this, this.def.error, n)
        }
        $dataError() {
            (0,
            xc.reportError)(this, this.def.$dataError || xc.keyword$DataError)
        }
        reset() {
            if (this.errsCount === void 0)
                throw new Error('add "trackErrors" to keyword definition');
            (0,
            xc.resetErrorsCount)(this.gen, this.errsCount)
        }
        ok(t) {
            this.allErrors || this.gen.if(t)
        }
        setParams(t, n) {
            n ? Object.assign(this.params, t) : this.params = t
        }
        block$data(t, n, r=ke.nil) {
            this.gen.block( () => {
                this.check$data(t, r),
                n()
            }
            )
        }
        check$data(t=ke.nil, n=ke.nil) {
            if (!this.$data)
                return;
            const {gen: r, schemaCode: s, schemaType: o, def: c} = this;
            r.if((0,
            ke.or)((0,
            ke._)`${s} === undefined`, n)),
            t !== ke.nil && r.assign(t, !0),
            (o.length || c.validateSchema) && (r.elseIf(this.invalid$data()),
            this.$dataError(),
            t !== ke.nil && r.assign(t, !1)),
            r.else()
        }
        invalid$data() {
            const {gen: t, schemaCode: n, schemaType: r, def: s, it: o} = this;
            return (0,
            ke.or)(c(), l());
            function c() {
                if (r.length) {
                    if (!(n instanceof ke.Name))
                        throw new Error("ajv implementation error");
                    const f = Array.isArray(r) ? r : [r];
                    return (0,
                    ke._)`${(0,
                    Pf.checkDataTypes)(f, n, o.opts.strictNumbers, Pf.DataType.Wrong)}`
                }
                return ke.nil
            }
            function l() {
                if (s.validateSchema) {
                    const f = t.scopeValue("validate$data", {
                        ref: s.validateSchema
                    });
                    return (0,
                    ke._)`!${f}(${n})`
                }
                return ke.nil
            }
        }
        subschema(t, n) {
            const r = (0,
            Ep.getSubschema)(this.it, t);
            (0,
            Ep.extendSubschemaData)(r, this.it, t),
            (0,
            Ep.extendSubschemaMode)(r, t);
            const s = {
                ...this.it,
                ...r,
                items: void 0,
                props: void 0
            };
            return tL(s, n),
            s
        }
        mergeEvaluated(t, n) {
            const {it: r, gen: s} = this;
            r.opts.unevaluated && (r.props !== !0 && t.props !== void 0 && (r.props = Ui.mergeEvaluated.props(s, t.props, r.props, n)),
            r.items !== !0 && t.items !== void 0 && (r.items = Ui.mergeEvaluated.items(s, t.items, r.items, n)))
        }
        mergeValidEvaluated(t, n) {
            const {it: r, gen: s} = this;
            if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
                return s.if(n, () => this.mergeEvaluated(t, ke.Name)),
                !0
        }
    }
    kr.KeywordCxt = Ub;
    function Bb(e, t, n, r) {
        const s = new Ub(e,n,t);
        "code"in n ? n.code(s, r) : s.$data && n.validate ? (0,
        Xc.funcKeywordCode)(s, n) : "macro"in n ? (0,
        Xc.macroKeywordCode)(s, n) : (n.compile || n.validate) && (0,
        Xc.funcKeywordCode)(s, n)
    }
    const mL = /^\/(?:[^~]|~0|~1)*$/
      , gL = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function Fb(e, {dataLevel: t, dataNames: n, dataPathArr: r}) {
        let s, o;
        if (e === "")
            return Ve.default.rootData;
        if (e[0] === "/") {
            if (!mL.test(e))
                throw new Error(`Invalid JSON-pointer: ${e}`);
            s = e,
            o = Ve.default.rootData
        } else {
            const d = gL.exec(e);
            if (!d)
                throw new Error(`Invalid JSON-pointer: ${e}`);
            const h = +d[1];
            if (s = d[2],
            s === "#") {
                if (h >= t)
                    throw new Error(f("property/index", h));
                return r[t - h]
            }
            if (h > t)
                throw new Error(f("data", h));
            if (o = n[t - h],
            !s)
                return o
        }
        let c = o;
        const l = s.split("/");
        for (const d of l)
            d && (o = (0,
            ke._)`${o}${(0,
            ke.getProperty)((0,
            Ui.unescapeJsonPointer)(d))}`,
            c = (0,
            ke._)`${c} && ${o}`);
        return c;
        function f(d, h) {
            return `Cannot access ${d} ${h} levels up, current level is ${t}`
        }
    }
    kr.getData = Fb;
    var Fu = {};
    Object.defineProperty(Fu, "__esModule", {
        value: !0
    });
    class yL extends Error {
        constructor(t) {
            super("validation failed"),
            this.errors = t,
            this.ajv = this.validation = !0
        }
    }
    Fu.default = yL;
    var Ro = {};
    Object.defineProperty(Ro, "__esModule", {
        value: !0
    });
    const Sp = ln;
    class _L extends Error {
        constructor(t, n, r, s) {
            super(s || `can't resolve reference ${r} from id ${n}`),
            this.missingRef = (0,
            Sp.resolveUrl)(t, n, r),
            this.missingSchema = (0,
            Sp.normalizeId)((0,
            Sp.getFullPath)(t, this.missingRef))
        }
    }
    Ro.default = _L;
    var Cn = {};
    Object.defineProperty(Cn, "__esModule", {
        value: !0
    });
    Cn.resolveSchema = Cn.getCompilingSchema = Cn.resolveRef = Cn.compileSchema = Cn.SchemaEnv = void 0;
    const Tr = ot
      , vL = Fu
      , Vs = oi
      , $r = ln
      , mv = Te
      , wL = kr;
    class Rd {
        constructor(t) {
            var n;
            this.refs = {},
            this.dynamicAnchors = {};
            let r;
            typeof t.schema == "object" && (r = t.schema),
            this.schema = t.schema,
            this.schemaId = t.schemaId,
            this.root = t.root || this,
            this.baseId = (n = t.baseId) !== null && n !== void 0 ? n : (0,
            $r.normalizeId)(r?.[t.schemaId || "$id"]),
            this.schemaPath = t.schemaPath,
            this.localRefs = t.localRefs,
            this.meta = t.meta,
            this.$async = r?.$async,
            this.refs = {}
        }
    }
    Cn.SchemaEnv = Rd;
    function xg(e) {
        const t = jb.call(this, e);
        if (t)
            return t;
        const n = (0,
        $r.getFullPath)(this.opts.uriResolver, e.root.baseId)
          , {es5: r, lines: s} = this.opts.code
          , {ownProperties: o} = this.opts
          , c = new Tr.CodeGen(this.scope,{
            es5: r,
            lines: s,
            ownProperties: o
        });
        let l;
        e.$async && (l = c.scopeValue("Error", {
            ref: vL.default,
            code: (0,
            Tr._)`require("ajv/dist/runtime/validation_error").default`
        }));
        const f = c.scopeName("validate");
        e.validateName = f;
        const d = {
            gen: c,
            allErrors: this.opts.allErrors,
            data: Vs.default.data,
            parentData: Vs.default.parentData,
            parentDataProperty: Vs.default.parentDataProperty,
            dataNames: [Vs.default.data],
            dataPathArr: [Tr.nil],
            dataLevel: 0,
            dataTypes: [],
            definedProperties: new Set,
            topSchemaRef: c.scopeValue("schema", this.opts.code.source === !0 ? {
                ref: e.schema,
                code: (0,
                Tr.stringify)(e.schema)
            } : {
                ref: e.schema
            }),
            validateName: f,
            ValidationError: l,
            schema: e.schema,
            schemaEnv: e,
            rootId: n,
            baseId: e.baseId || n,
            schemaPath: Tr.nil,
            errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
            errorPath: (0,
            Tr._)`""`,
            opts: this.opts,
            self: this
        };
        let h;
        try {
            this._compilations.add(e),
            (0,
            wL.validateFunctionCode)(d),
            c.optimize(this.opts.code.optimize);
            const y = c.toString();
            h = `${c.scopeRefs(Vs.default.scope)}return ${y}`,
            this.opts.code.process && (h = this.opts.code.process(h, e));
            const $ = new Function(`${Vs.default.self}`,`${Vs.default.scope}`,h)(this, this.scope.get());
            if (this.scope.value(f, {
                ref: $
            }),
            $.errors = null,
            $.schema = e.schema,
            $.schemaEnv = e,
            e.$async && ($.$async = !0),
            this.opts.code.source === !0 && ($.source = {
                validateName: f,
                validateCode: y,
                scopeValues: c._values
            }),
            this.opts.unevaluated) {
                const {props: O, items: A} = d;
                $.evaluated = {
                    props: O instanceof Tr.Name ? void 0 : O,
                    items: A instanceof Tr.Name ? void 0 : A,
                    dynamicProps: O instanceof Tr.Name,
                    dynamicItems: A instanceof Tr.Name
                },
                $.source && ($.source.evaluated = (0,
                Tr.stringify)($.evaluated))
            }
            return e.validate = $,
            e
        } catch (y) {
            throw delete e.validate,
            delete e.validateName,
            h && this.logger.error("Error compiling schema, function code:", h),
            y
        } finally {
            this._compilations.delete(e)
        }
    }
    Cn.compileSchema = xg;
    function bL(e, t, n) {
        var r;
        n = (0,
        $r.resolveUrl)(this.opts.uriResolver, t, n);
        const s = e.refs[n];
        if (s)
            return s;
        let o = TL.call(this, e, n);
        if (o === void 0) {
            const c = (r = e.localRefs) === null || r === void 0 ? void 0 : r[n]
              , {schemaId: l} = this.opts;
            c && (o = new Rd({
                schema: c,
                schemaId: l,
                root: e,
                baseId: t
            }))
        }
        if (o !== void 0)
            return e.refs[n] = EL.call(this, o)
    }
    Cn.resolveRef = bL;
    function EL(e) {
        return (0,
        $r.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : xg.call(this, e)
    }
    function jb(e) {
        for (const t of this._compilations)
            if (SL(t, e))
                return t
    }
    Cn.getCompilingSchema = jb;
    function SL(e, t) {
        return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId
    }
    function TL(e, t) {
        let n;
        for (; typeof (n = this.refs[t]) == "string"; )
            t = n;
        return n || this.schemas[t] || Pd.call(this, e, t)
    }
    function Pd(e, t) {
        const n = this.opts.uriResolver.parse(t)
          , r = (0,
        $r._getFullPath)(this.opts.uriResolver, n);
        let s = (0,
        $r.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
        if (Object.keys(e.schema).length > 0 && r === s)
            return Tp.call(this, n, e);
        const o = (0,
        $r.normalizeId)(r)
          , c = this.refs[o] || this.schemas[o];
        if (typeof c == "string") {
            const l = Pd.call(this, e, c);
            return typeof l?.schema != "object" ? void 0 : Tp.call(this, n, l)
        }
        if (typeof c?.schema == "object") {
            if (c.validate || xg.call(this, c),
            o === (0,
            $r.normalizeId)(t)) {
                const {schema: l} = c
                  , {schemaId: f} = this.opts
                  , d = l[f];
                return d && (s = (0,
                $r.resolveUrl)(this.opts.uriResolver, s, d)),
                new Rd({
                    schema: l,
                    schemaId: f,
                    root: e,
                    baseId: s
                })
            }
            return Tp.call(this, n, c)
        }
    }
    Cn.resolveSchema = Pd;
    const AL = new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function Tp(e, {baseId: t, schema: n, root: r}) {
        var s;
        if (((s = e.fragment) === null || s === void 0 ? void 0 : s[0]) !== "/")
            return;
        for (const l of e.fragment.slice(1).split("/")) {
            if (typeof n == "boolean")
                return;
            const f = n[(0,
            mv.unescapeFragment)(l)];
            if (f === void 0)
                return;
            n = f;
            const d = typeof n == "object" && n[this.opts.schemaId];
            !AL.has(l) && d && (t = (0,
            $r.resolveUrl)(this.opts.uriResolver, t, d))
        }
        let o;
        if (typeof n != "boolean" && n.$ref && !(0,
        mv.schemaHasRulesButRef)(n, this.RULES)) {
            const l = (0,
            $r.resolveUrl)(this.opts.uriResolver, t, n.$ref);
            o = Pd.call(this, r, l)
        }
        const {schemaId: c} = this.opts;
        if (o = o || new Rd({
            schema: n,
            schemaId: c,
            root: r,
            baseId: t
        }),
        o.schema !== o.root.schema)
            return o
    }
    const OL = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      , IL = "Meta-schema for $data reference (JSON AnySchema extension proposal)"
      , NL = "object"
      , xL = ["$data"]
      , $L = {
        $data: {
            type: "string",
            anyOf: [{
                format: "relative-json-pointer"
            }, {
                format: "json-pointer"
            }]
        }
    }
      , RL = !1
      , PL = {
        $id: OL,
        description: IL,
        type: NL,
        required: xL,
        properties: $L,
        additionalProperties: RL
    };
    var $g = {}
      , kd = {
        exports: {}
    };
    const kL = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
    };
    var CL = {
        HEX: kL
    };
    const {HEX: ML} = CL
      , LL = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function qb(e) {
        if (Yb(e, ".") < 3)
            return {
                host: e,
                isIPV4: !1
            };
        const t = e.match(LL) || []
          , [n] = t;
        return n ? {
            host: UL(n, "."),
            isIPV4: !0
        } : {
            host: e,
            isIPV4: !1
        }
    }
    function pm(e, t=!1) {
        let n = ""
          , r = !0;
        for (const s of e) {
            if (ML[s] === void 0)
                return;
            s !== "0" && r === !0 && (r = !1),
            r || (n += s)
        }
        return t && n.length === 0 && (n = "0"),
        n
    }
    function DL(e) {
        let t = 0;
        const n = {
            error: !1,
            address: "",
            zone: ""
        }
          , r = []
          , s = [];
        let o = !1
          , c = !1
          , l = !1;
        function f() {
            if (s.length) {
                if (o === !1) {
                    const d = pm(s);
                    if (d !== void 0)
                        r.push(d);
                    else
                        return n.error = !0,
                        !1
                }
                s.length = 0
            }
            return !0
        }
        for (let d = 0; d < e.length; d++) {
            const h = e[d];
            if (!(h === "[" || h === "]"))
                if (h === ":") {
                    if (c === !0 && (l = !0),
                    !f())
                        break;
                    if (t++,
                    r.push(":"),
                    t > 7) {
                        n.error = !0;
                        break
                    }
                    d - 1 >= 0 && e[d - 1] === ":" && (c = !0);
                    continue
                } else if (h === "%") {
                    if (!f())
                        break;
                    o = !0
                } else {
                    s.push(h);
                    continue
                }
        }
        return s.length && (o ? n.zone = s.join("") : l ? r.push(s.join("")) : r.push(pm(s))),
        n.address = r.join(""),
        n
    }
    function Hb(e) {
        if (Yb(e, ":") < 2)
            return {
                host: e,
                isIPV6: !1
            };
        const t = DL(e);
        if (t.error)
            return {
                host: e,
                isIPV6: !1
            };
        {
            let n = t.address
              , r = t.address;
            return t.zone && (n += "%" + t.zone,
            r += "%25" + t.zone),
            {
                host: n,
                escapedHost: r,
                isIPV6: !0
            }
        }
    }
    function UL(e, t) {
        let n = ""
          , r = !0;
        const s = e.length;
        for (let o = 0; o < s; o++) {
            const c = e[o];
            c === "0" && r ? (o + 1 <= s && e[o + 1] === t || o + 1 === s) && (n += c,
            r = !1) : (c === t ? r = !0 : r = !1,
            n += c)
        }
        return n
    }
    function Yb(e, t) {
        let n = 0;
        for (let r = 0; r < e.length; r++)
            e[r] === t && n++;
        return n
    }
    const gv = /^\.\.?\//u
      , yv = /^\/\.(?:\/|$)/u
      , _v = /^\/\.\.(?:\/|$)/u
      , BL = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function FL(e) {
        const t = [];
        for (; e.length; )
            if (e.match(gv))
                e = e.replace(gv, "");
            else if (e.match(yv))
                e = e.replace(yv, "/");
            else if (e.match(_v))
                e = e.replace(_v, "/"),
                t.pop();
            else if (e === "." || e === "..")
                e = "";
            else {
                const n = e.match(BL);
                if (n) {
                    const r = n[0];
                    e = e.slice(r.length),
                    t.push(r)
                } else
                    throw new Error("Unexpected dot segment condition")
            }
        return t.join("")
    }
    function jL(e, t) {
        const n = t !== !0 ? escape : unescape;
        return e.scheme !== void 0 && (e.scheme = n(e.scheme)),
        e.userinfo !== void 0 && (e.userinfo = n(e.userinfo)),
        e.host !== void 0 && (e.host = n(e.host)),
        e.path !== void 0 && (e.path = n(e.path)),
        e.query !== void 0 && (e.query = n(e.query)),
        e.fragment !== void 0 && (e.fragment = n(e.fragment)),
        e
    }
    function qL(e) {
        const t = [];
        if (e.userinfo !== void 0 && (t.push(e.userinfo),
        t.push("@")),
        e.host !== void 0) {
            let n = unescape(e.host);
            const r = qb(n);
            if (r.isIPV4)
                n = r.host;
            else {
                const s = Hb(r.host);
                s.isIPV6 === !0 ? n = `[${s.escapedHost}]` : n = e.host
            }
            t.push(n)
        }
        return (typeof e.port == "number" || typeof e.port == "string") && (t.push(":"),
        t.push(String(e.port))),
        t.length ? t.join("") : void 0
    }
    var HL = {
        recomposeAuthority: qL,
        normalizeComponentEncoding: jL,
        removeDotSegments: FL,
        normalizeIPv4: qb,
        normalizeIPv6: Hb,
        stringArrayToHexStripped: pm
    };
    const YL = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu
      , VL = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function Vb(e) {
        return typeof e.secure == "boolean" ? e.secure : String(e.scheme).toLowerCase() === "wss"
    }
    function Wb(e) {
        return e.host || (e.error = e.error || "HTTP URIs must have a host."),
        e
    }
    function zb(e) {
        const t = String(e.scheme).toLowerCase() === "https";
        return (e.port === (t ? 443 : 80) || e.port === "") && (e.port = void 0),
        e.path || (e.path = "/"),
        e
    }
    function WL(e) {
        return e.secure = Vb(e),
        e.resourceName = (e.path || "/") + (e.query ? "?" + e.query : ""),
        e.path = void 0,
        e.query = void 0,
        e
    }
    function zL(e) {
        if ((e.port === (Vb(e) ? 443 : 80) || e.port === "") && (e.port = void 0),
        typeof e.secure == "boolean" && (e.scheme = e.secure ? "wss" : "ws",
        e.secure = void 0),
        e.resourceName) {
            const [t,n] = e.resourceName.split("?");
            e.path = t && t !== "/" ? t : void 0,
            e.query = n,
            e.resourceName = void 0
        }
        return e.fragment = void 0,
        e
    }
    function GL(e, t) {
        if (!e.path)
            return e.error = "URN can not be parsed",
            e;
        const n = e.path.match(VL);
        if (n) {
            const r = t.scheme || e.scheme || "urn";
            e.nid = n[1].toLowerCase(),
            e.nss = n[2];
            const s = `${r}:${t.nid || e.nid}`
              , o = Rg[s];
            e.path = void 0,
            o && (e = o.parse(e, t))
        } else
            e.error = e.error || "URN can not be parsed.";
        return e
    }
    function ZL(e, t) {
        const n = t.scheme || e.scheme || "urn"
          , r = e.nid.toLowerCase()
          , s = `${n}:${t.nid || r}`
          , o = Rg[s];
        o && (e = o.serialize(e, t));
        const c = e
          , l = e.nss;
        return c.path = `${r || t.nid}:${l}`,
        t.skipEscape = !0,
        c
    }
    function KL(e, t) {
        const n = e;
        return n.uuid = n.nss,
        n.nss = void 0,
        !t.tolerant && (!n.uuid || !YL.test(n.uuid)) && (n.error = n.error || "UUID is not valid."),
        n
    }
    function JL(e) {
        const t = e;
        return t.nss = (e.uuid || "").toLowerCase(),
        t
    }
    const Gb = {
        scheme: "http",
        domainHost: !0,
        parse: Wb,
        serialize: zb
    }
      , XL = {
        scheme: "https",
        domainHost: Gb.domainHost,
        parse: Wb,
        serialize: zb
    }
      , wf = {
        scheme: "ws",
        domainHost: !0,
        parse: WL,
        serialize: zL
    }
      , QL = {
        scheme: "wss",
        domainHost: wf.domainHost,
        parse: wf.parse,
        serialize: wf.serialize
    }
      , eD = {
        scheme: "urn",
        parse: GL,
        serialize: ZL,
        skipNormalize: !0
    }
      , tD = {
        scheme: "urn:uuid",
        parse: KL,
        serialize: JL,
        skipNormalize: !0
    }
      , Rg = {
        http: Gb,
        https: XL,
        ws: wf,
        wss: QL,
        urn: eD,
        "urn:uuid": tD
    };
    var nD = Rg;
    const {normalizeIPv6: rD, normalizeIPv4: iD, removeDotSegments: Vc, recomposeAuthority: sD, normalizeComponentEncoding: sf} = HL
      , Pg = nD;
    function aD(e, t) {
        return typeof e == "string" ? e = ei(Fi(e, t), t) : typeof e == "object" && (e = Fi(ei(e, t), t)),
        e
    }
    function oD(e, t, n) {
        const r = Object.assign({
            scheme: "null"
        }, n)
          , s = Zb(Fi(e, r), Fi(t, r), r, !0);
        return ei(s, {
            ...r,
            skipEscape: !0
        })
    }
    function Zb(e, t, n, r) {
        const s = {};
        return r || (e = Fi(ei(e, n), n),
        t = Fi(ei(t, n), n)),
        n = n || {},
        !n.tolerant && t.scheme ? (s.scheme = t.scheme,
        s.userinfo = t.userinfo,
        s.host = t.host,
        s.port = t.port,
        s.path = Vc(t.path || ""),
        s.query = t.query) : (t.userinfo !== void 0 || t.host !== void 0 || t.port !== void 0 ? (s.userinfo = t.userinfo,
        s.host = t.host,
        s.port = t.port,
        s.path = Vc(t.path || ""),
        s.query = t.query) : (t.path ? (t.path.charAt(0) === "/" ? s.path = Vc(t.path) : ((e.userinfo !== void 0 || e.host !== void 0 || e.port !== void 0) && !e.path ? s.path = "/" + t.path : e.path ? s.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : s.path = t.path,
        s.path = Vc(s.path)),
        s.query = t.query) : (s.path = e.path,
        t.query !== void 0 ? s.query = t.query : s.query = e.query),
        s.userinfo = e.userinfo,
        s.host = e.host,
        s.port = e.port),
        s.scheme = e.scheme),
        s.fragment = t.fragment,
        s
    }
    function cD(e, t, n) {
        return typeof e == "string" ? (e = unescape(e),
        e = ei(sf(Fi(e, n), !0), {
            ...n,
            skipEscape: !0
        })) : typeof e == "object" && (e = ei(sf(e, !0), {
            ...n,
            skipEscape: !0
        })),
        typeof t == "string" ? (t = unescape(t),
        t = ei(sf(Fi(t, n), !0), {
            ...n,
            skipEscape: !0
        })) : typeof t == "object" && (t = ei(sf(t, !0), {
            ...n,
            skipEscape: !0
        })),
        e.toLowerCase() === t.toLowerCase()
    }
    function ei(e, t) {
        const n = {
            host: e.host,
            scheme: e.scheme,
            userinfo: e.userinfo,
            port: e.port,
            path: e.path,
            query: e.query,
            nid: e.nid,
            nss: e.nss,
            uuid: e.uuid,
            fragment: e.fragment,
            reference: e.reference,
            resourceName: e.resourceName,
            secure: e.secure,
            error: ""
        }
          , r = Object.assign({}, t)
          , s = []
          , o = Pg[(r.scheme || n.scheme || "").toLowerCase()];
        o && o.serialize && o.serialize(n, r),
        n.path !== void 0 && (r.skipEscape ? n.path = unescape(n.path) : (n.path = escape(n.path),
        n.scheme !== void 0 && (n.path = n.path.split("%3A").join(":")))),
        r.reference !== "suffix" && n.scheme && s.push(n.scheme, ":");
        const c = sD(n);
        if (c !== void 0 && (r.reference !== "suffix" && s.push("//"),
        s.push(c),
        n.path && n.path.charAt(0) !== "/" && s.push("/")),
        n.path !== void 0) {
            let l = n.path;
            !r.absolutePath && (!o || !o.absolutePath) && (l = Vc(l)),
            c === void 0 && (l = l.replace(/^\/\//u, "/%2F")),
            s.push(l)
        }
        return n.query !== void 0 && s.push("?", n.query),
        n.fragment !== void 0 && s.push("#", n.fragment),
        s.join("")
    }
    const uD = Array.from({
        length: 127
    }, (e, t) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(t)));
    function lD(e) {
        let t = 0;
        for (let n = 0, r = e.length; n < r; ++n)
            if (t = e.charCodeAt(n),
            t > 126 || uD[t])
                return !0;
        return !1
    }
    const fD = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function Fi(e, t) {
        const n = Object.assign({}, t)
          , r = {
            scheme: void 0,
            userinfo: void 0,
            host: "",
            port: void 0,
            path: "",
            query: void 0,
            fragment: void 0
        }
          , s = e.indexOf("%") !== -1;
        let o = !1;
        n.reference === "suffix" && (e = (n.scheme ? n.scheme + ":" : "") + "//" + e);
        const c = e.match(fD);
        if (c) {
            if (r.scheme = c[1],
            r.userinfo = c[3],
            r.host = c[4],
            r.port = parseInt(c[5], 10),
            r.path = c[6] || "",
            r.query = c[7],
            r.fragment = c[8],
            isNaN(r.port) && (r.port = c[5]),
            r.host) {
                const f = iD(r.host);
                if (f.isIPV4 === !1) {
                    const d = rD(f.host);
                    r.host = d.host.toLowerCase(),
                    o = d.isIPV6
                } else
                    r.host = f.host,
                    o = !0
            }
            r.scheme === void 0 && r.userinfo === void 0 && r.host === void 0 && r.port === void 0 && r.query === void 0 && !r.path ? r.reference = "same-document" : r.scheme === void 0 ? r.reference = "relative" : r.fragment === void 0 ? r.reference = "absolute" : r.reference = "uri",
            n.reference && n.reference !== "suffix" && n.reference !== r.reference && (r.error = r.error || "URI is not a " + n.reference + " reference.");
            const l = Pg[(n.scheme || r.scheme || "").toLowerCase()];
            if (!n.unicodeSupport && (!l || !l.unicodeSupport) && r.host && (n.domainHost || l && l.domainHost) && o === !1 && lD(r.host))
                try {
                    r.host = URL.domainToASCII(r.host.toLowerCase())
                } catch (f) {
                    r.error = r.error || "Host's domain name can not be converted to ASCII: " + f
                }
            (!l || l && !l.skipNormalize) && (s && r.scheme !== void 0 && (r.scheme = unescape(r.scheme)),
            s && r.host !== void 0 && (r.host = unescape(r.host)),
            r.path && (r.path = escape(unescape(r.path))),
            r.fragment && (r.fragment = encodeURI(decodeURIComponent(r.fragment)))),
            l && l.parse && l.parse(r, n)
        } else
            r.error = r.error || "URI can not be parsed.";
        return r
    }
    const kg = {
        SCHEMES: Pg,
        normalize: aD,
        resolve: oD,
        resolveComponents: Zb,
        equal: cD,
        serialize: ei,
        parse: Fi
    };
    kd.exports = kg;
    kd.exports.default = kg;
    kd.exports.fastUri = kg;
    var dD = kd.exports;
    Object.defineProperty($g, "__esModule", {
        value: !0
    });
    const Kb = dD;
    Kb.code = 'require("ajv/dist/runtime/uri").default';
    $g.default = Kb;
    (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
        var t = kr;
        Object.defineProperty(e, "KeywordCxt", {
            enumerable: !0,
            get: function() {
                return t.KeywordCxt
            }
        });
        var n = ot;
        Object.defineProperty(e, "_", {
            enumerable: !0,
            get: function() {
                return n._
            }
        }),
        Object.defineProperty(e, "str", {
            enumerable: !0,
            get: function() {
                return n.str
            }
        }),
        Object.defineProperty(e, "stringify", {
            enumerable: !0,
            get: function() {
                return n.stringify
            }
        }),
        Object.defineProperty(e, "nil", {
            enumerable: !0,
            get: function() {
                return n.nil
            }
        }),
        Object.defineProperty(e, "Name", {
            enumerable: !0,
            get: function() {
                return n.Name
            }
        }),
        Object.defineProperty(e, "CodeGen", {
            enumerable: !0,
            get: function() {
                return n.CodeGen
            }
        });
        const r = Fu
          , s = Ro
          , o = sa
          , c = Cn
          , l = ot
          , f = ln
          , d = Kt
          , h = Te
          , y = PL
          , I = $g
          , $ = (J, H) => new RegExp(J,H);
        $.code = "new RegExp";
        const O = ["removeAdditional", "useDefaults", "coerceTypes"]
          , A = new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"])
          , N = {
            errorDataPath: "",
            format: "`validateFormats: false` can be used instead.",
            nullable: '"nullable" keyword is supported by default.',
            jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
            extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
            missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
            processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
            sourceCode: "Use option `code: {source: true}`",
            strictDefaults: "It is default now, see option `strict`.",
            strictKeywords: "It is default now, see option `strict`.",
            uniqueItems: '"uniqueItems" keyword is always validated.',
            unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
            cache: "Map is used as cache, schema object as key.",
            serialize: "Map is used as cache, schema object as key.",
            ajvErrors: "It is default now."
        }
          , m = {
            ignoreKeywordsWithRef: "",
            jsPropertySyntax: "",
            unicode: '"minLength"/"maxLength" account for unicode characters by default.'
        }
          , g = 200;
        function M(J) {
            var H, ae, Q, P, j, se, ye, we, De, Re, tt, vt, bt, st, ct, Br, yn, Gi, Ns, yr, an, Wn, Fr, pa, oe;
            const Be = J.strict
              , zn = (H = J.code) === null || H === void 0 ? void 0 : H.optimize
              , Gn = zn === !0 || zn === void 0 ? 1 : zn || 0
              , Zi = (Q = (ae = J.code) === null || ae === void 0 ? void 0 : ae.regExp) !== null && Q !== void 0 ? Q : $
              , ui = (P = J.uriResolver) !== null && P !== void 0 ? P : I.default;
            return {
                strictSchema: (se = (j = J.strictSchema) !== null && j !== void 0 ? j : Be) !== null && se !== void 0 ? se : !0,
                strictNumbers: (we = (ye = J.strictNumbers) !== null && ye !== void 0 ? ye : Be) !== null && we !== void 0 ? we : !0,
                strictTypes: (Re = (De = J.strictTypes) !== null && De !== void 0 ? De : Be) !== null && Re !== void 0 ? Re : "log",
                strictTuples: (vt = (tt = J.strictTuples) !== null && tt !== void 0 ? tt : Be) !== null && vt !== void 0 ? vt : "log",
                strictRequired: (st = (bt = J.strictRequired) !== null && bt !== void 0 ? bt : Be) !== null && st !== void 0 ? st : !1,
                code: J.code ? {
                    ...J.code,
                    optimize: Gn,
                    regExp: Zi
                } : {
                    optimize: Gn,
                    regExp: Zi
                },
                loopRequired: (ct = J.loopRequired) !== null && ct !== void 0 ? ct : g,
                loopEnum: (Br = J.loopEnum) !== null && Br !== void 0 ? Br : g,
                meta: (yn = J.meta) !== null && yn !== void 0 ? yn : !0,
                messages: (Gi = J.messages) !== null && Gi !== void 0 ? Gi : !0,
                inlineRefs: (Ns = J.inlineRefs) !== null && Ns !== void 0 ? Ns : !0,
                schemaId: (yr = J.schemaId) !== null && yr !== void 0 ? yr : "$id",
                addUsedSchema: (an = J.addUsedSchema) !== null && an !== void 0 ? an : !0,
                validateSchema: (Wn = J.validateSchema) !== null && Wn !== void 0 ? Wn : !0,
                validateFormats: (Fr = J.validateFormats) !== null && Fr !== void 0 ? Fr : !0,
                unicodeRegExp: (pa = J.unicodeRegExp) !== null && pa !== void 0 ? pa : !0,
                int32range: (oe = J.int32range) !== null && oe !== void 0 ? oe : !0,
                uriResolver: ui
            }
        }
        class G {
            constructor(H={}) {
                this.schemas = {},
                this.refs = {},
                this.formats = {},
                this._compilations = new Set,
                this._loading = {},
                this._cache = new Map,
                H = this.opts = {
                    ...H,
                    ...M(H)
                };
                const {es5: ae, lines: Q} = this.opts.code;
                this.scope = new l.ValueScope({
                    scope: {},
                    prefixes: A,
                    es5: ae,
                    lines: Q
                }),
                this.logger = C(H.logger);
                const P = H.validateFormats;
                H.validateFormats = !1,
                this.RULES = (0,
                o.getRules)(),
                U.call(this, N, H, "NOT SUPPORTED"),
                U.call(this, m, H, "DEPRECATED", "warn"),
                this._metaOpts = S.call(this),
                H.formats && _.call(this),
                this._addVocabularies(),
                this._addDefaultMetaSchema(),
                H.keywords && T.call(this, H.keywords),
                typeof H.meta == "object" && this.addMetaSchema(H.meta),
                K.call(this),
                H.validateFormats = P
            }
            _addVocabularies() {
                this.addKeyword("$async")
            }
            _addDefaultMetaSchema() {
                const {$data: H, meta: ae, schemaId: Q} = this.opts;
                let P = y;
                Q === "id" && (P = {
                    ...y
                },
                P.id = P.$id,
                delete P.$id),
                ae && H && this.addMetaSchema(P, P[Q], !1)
            }
            defaultMeta() {
                const {meta: H, schemaId: ae} = this.opts;
                return this.opts.defaultMeta = typeof H == "object" ? H[ae] || H : void 0
            }
            validate(H, ae) {
                let Q;
                if (typeof H == "string") {
                    if (Q = this.getSchema(H),
                    !Q)
                        throw new Error(`no schema with key or ref "${H}"`)
                } else
                    Q = this.compile(H);
                const P = Q(ae);
                return "$async"in Q || (this.errors = Q.errors),
                P
            }
            compile(H, ae) {
                const Q = this._addSchema(H, ae);
                return Q.validate || this._compileSchemaEnv(Q)
            }
            compileAsync(H, ae) {
                if (typeof this.opts.loadSchema != "function")
                    throw new Error("options.loadSchema should be a function");
                const {loadSchema: Q} = this.opts;
                return P.call(this, H, ae);
                async function P(Re, tt) {
                    await j.call(this, Re.$schema);
                    const vt = this._addSchema(Re, tt);
                    return vt.validate || se.call(this, vt)
                }
                async function j(Re) {
                    Re && !this.getSchema(Re) && await P.call(this, {
                        $ref: Re
                    }, !0)
                }
                async function se(Re) {
                    try {
                        return this._compileSchemaEnv(Re)
                    } catch (tt) {
                        if (!(tt instanceof s.default))
                            throw tt;
                        return ye.call(this, tt),
                        await we.call(this, tt.missingSchema),
                        se.call(this, Re)
                    }
                }
                function ye({missingSchema: Re, missingRef: tt}) {
                    if (this.refs[Re])
                        throw new Error(`AnySchema ${Re} is loaded but ${tt} cannot be resolved`)
                }
                async function we(Re) {
                    const tt = await De.call(this, Re);
                    this.refs[Re] || await j.call(this, tt.$schema),
                    this.refs[Re] || this.addSchema(tt, Re, ae)
                }
                async function De(Re) {
                    const tt = this._loading[Re];
                    if (tt)
                        return tt;
                    try {
                        return await (this._loading[Re] = Q(Re))
                    } finally {
                        delete this._loading[Re]
                    }
                }
            }
            addSchema(H, ae, Q, P=this.opts.validateSchema) {
                if (Array.isArray(H)) {
                    for (const se of H)
                        this.addSchema(se, void 0, Q, P);
                    return this
                }
                let j;
                if (typeof H == "object") {
                    const {schemaId: se} = this.opts;
                    if (j = H[se],
                    j !== void 0 && typeof j != "string")
                        throw new Error(`schema ${se} must be string`)
                }
                return ae = (0,
                f.normalizeId)(ae || j),
                this._checkUnique(ae),
                this.schemas[ae] = this._addSchema(H, Q, ae, P, !0),
                this
            }
            addMetaSchema(H, ae, Q=this.opts.validateSchema) {
                return this.addSchema(H, ae, !0, Q),
                this
            }
            validateSchema(H, ae) {
                if (typeof H == "boolean")
                    return !0;
                let Q;
                if (Q = H.$schema,
                Q !== void 0 && typeof Q != "string")
                    throw new Error("$schema must be a string");
                if (Q = Q || this.opts.defaultMeta || this.defaultMeta(),
                !Q)
                    return this.logger.warn("meta-schema not available"),
                    this.errors = null,
                    !0;
                const P = this.validate(Q, H);
                if (!P && ae) {
                    const j = "schema is invalid: " + this.errorsText();
                    if (this.opts.validateSchema === "log")
                        this.logger.error(j);
                    else
                        throw new Error(j)
                }
                return P
            }
            getSchema(H) {
                let ae;
                for (; typeof (ae = D.call(this, H)) == "string"; )
                    H = ae;
                if (ae === void 0) {
                    const {schemaId: Q} = this.opts
                      , P = new c.SchemaEnv({
                        schema: {},
                        schemaId: Q
                    });
                    if (ae = c.resolveSchema.call(this, P, H),
                    !ae)
                        return;
                    this.refs[H] = ae
                }
                return ae.validate || this._compileSchemaEnv(ae)
            }
            removeSchema(H) {
                if (H instanceof RegExp)
                    return this._removeAllSchemas(this.schemas, H),
                    this._removeAllSchemas(this.refs, H),
                    this;
                switch (typeof H) {
                case "undefined":
                    return this._removeAllSchemas(this.schemas),
                    this._removeAllSchemas(this.refs),
                    this._cache.clear(),
                    this;
                case "string":
                    {
                        const ae = D.call(this, H);
                        return typeof ae == "object" && this._cache.delete(ae.schema),
                        delete this.schemas[H],
                        delete this.refs[H],
                        this
                    }
                case "object":
                    {
                        const ae = H;
                        this._cache.delete(ae);
                        let Q = H[this.opts.schemaId];
                        return Q && (Q = (0,
                        f.normalizeId)(Q),
                        delete this.schemas[Q],
                        delete this.refs[Q]),
                        this
                    }
                default:
                    throw new Error("ajv.removeSchema: invalid parameter")
                }
            }
            addVocabulary(H) {
                for (const ae of H)
                    this.addKeyword(ae);
                return this
            }
            addKeyword(H, ae) {
                let Q;
                if (typeof H == "string")
                    Q = H,
                    typeof ae == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"),
                    ae.keyword = Q);
                else if (typeof H == "object" && ae === void 0) {
                    if (ae = H,
                    Q = ae.keyword,
                    Array.isArray(Q) && !Q.length)
                        throw new Error("addKeywords: keyword must be string or non-empty array")
                } else
                    throw new Error("invalid addKeywords parameters");
                if (X.call(this, Q, ae),
                !ae)
                    return (0,
                    h.eachItem)(Q, j => v.call(this, j)),
                    this;
                Y.call(this, ae);
                const P = {
                    ...ae,
                    type: (0,
                    d.getJSONTypes)(ae.type),
                    schemaType: (0,
                    d.getJSONTypes)(ae.schemaType)
                };
                return (0,
                h.eachItem)(Q, P.type.length === 0 ? j => v.call(this, j, P) : j => P.type.forEach(se => v.call(this, j, P, se))),
                this
            }
            getKeyword(H) {
                const ae = this.RULES.all[H];
                return typeof ae == "object" ? ae.definition : !!ae
            }
            removeKeyword(H) {
                const {RULES: ae} = this;
                delete ae.keywords[H],
                delete ae.all[H];
                for (const Q of ae.rules) {
                    const P = Q.rules.findIndex(j => j.keyword === H);
                    P >= 0 && Q.rules.splice(P, 1)
                }
                return this
            }
            addFormat(H, ae) {
                return typeof ae == "string" && (ae = new RegExp(ae)),
                this.formats[H] = ae,
                this
            }
            errorsText(H=this.errors, {separator: ae=", ", dataVar: Q="data"}={}) {
                return !H || H.length === 0 ? "No errors" : H.map(P => `${Q}${P.instancePath} ${P.message}`).reduce( (P, j) => P + ae + j)
            }
            $dataMetaSchema(H, ae) {
                const Q = this.RULES.all;
                H = JSON.parse(JSON.stringify(H));
                for (const P of ae) {
                    const j = P.split("/").slice(1);
                    let se = H;
                    for (const ye of j)
                        se = se[ye];
                    for (const ye in Q) {
                        const we = Q[ye];
                        if (typeof we != "object")
                            continue;
                        const {$data: De} = we.definition
                          , Re = se[ye];
                        De && Re && (se[ye] = te(Re))
                    }
                }
                return H
            }
            _removeAllSchemas(H, ae) {
                for (const Q in H) {
                    const P = H[Q];
                    (!ae || ae.test(Q)) && (typeof P == "string" ? delete H[Q] : P && !P.meta && (this._cache.delete(P.schema),
                    delete H[Q]))
                }
            }
            _addSchema(H, ae, Q, P=this.opts.validateSchema, j=this.opts.addUsedSchema) {
                let se;
                const {schemaId: ye} = this.opts;
                if (typeof H == "object")
                    se = H[ye];
                else {
                    if (this.opts.jtd)
                        throw new Error("schema must be object");
                    if (typeof H != "boolean")
                        throw new Error("schema must be object or boolean")
                }
                let we = this._cache.get(H);
                if (we !== void 0)
                    return we;
                Q = (0,
                f.normalizeId)(se || Q);
                const De = f.getSchemaRefs.call(this, H, Q);
                return we = new c.SchemaEnv({
                    schema: H,
                    schemaId: ye,
                    meta: ae,
                    baseId: Q,
                    localRefs: De
                }),
                this._cache.set(we.schema, we),
                j && !Q.startsWith("#") && (Q && this._checkUnique(Q),
                this.refs[Q] = we),
                P && this.validateSchema(H, !0),
                we
            }
            _checkUnique(H) {
                if (this.schemas[H] || this.refs[H])
                    throw new Error(`schema with key or id "${H}" already exists`)
            }
            _compileSchemaEnv(H) {
                if (H.meta ? this._compileMetaSchema(H) : c.compileSchema.call(this, H),
                !H.validate)
                    throw new Error("ajv implementation error");
                return H.validate
            }
            _compileMetaSchema(H) {
                const ae = this.opts;
                this.opts = this._metaOpts;
                try {
                    c.compileSchema.call(this, H)
                } finally {
                    this.opts = ae
                }
            }
        }
        G.ValidationError = r.default,
        G.MissingRefError = s.default,
        e.default = G;
        function U(J, H, ae, Q="error") {
            for (const P in J) {
                const j = P;
                j in H && this.logger[Q](`${ae}: option ${P}. ${J[j]}`)
            }
        }
        function D(J) {
            return J = (0,
            f.normalizeId)(J),
            this.schemas[J] || this.refs[J]
        }
        function K() {
            const J = this.opts.schemas;
            if (J)
                if (Array.isArray(J))
                    this.addSchema(J);
                else
                    for (const H in J)
                        this.addSchema(J[H], H)
        }
        function _() {
            for (const J in this.opts.formats) {
                const H = this.opts.formats[J];
                H && this.addFormat(J, H)
            }
        }
        function T(J) {
            if (Array.isArray(J)) {
                this.addVocabulary(J);
                return
            }
            this.logger.warn("keywords option as map is deprecated, pass array");
            for (const H in J) {
                const ae = J[H];
                ae.keyword || (ae.keyword = H),
                this.addKeyword(ae)
            }
        }
        function S() {
            const J = {
                ...this.opts
            };
            for (const H of O)
                delete J[H];
            return J
        }
        const q = {
            log() {},
            warn() {},
            error() {}
        };
        function C(J) {
            if (J === !1)
                return q;
            if (J === void 0)
                return console;
            if (J.log && J.warn && J.error)
                return J;
            throw new Error("logger must implement log, warn and error methods")
        }
        const F = /^[a-z_$][a-z0-9_$:-]*$/i;
        function X(J, H) {
            const {RULES: ae} = this;
            if ((0,
            h.eachItem)(J, Q => {
                if (ae.keywords[Q])
                    throw new Error(`Keyword ${Q} is already defined`);
                if (!F.test(Q))
                    throw new Error(`Keyword ${Q} has invalid name`)
            }
            ),
            !!H && H.$data && !("code"in H || "validate"in H))
                throw new Error('$data keyword must have "code" or "validate" function')
        }
        function v(J, H, ae) {
            var Q;
            const P = H?.post;
            if (ae && P)
                throw new Error('keyword with "post" flag cannot have "type"');
            const {RULES: j} = this;
            let se = P ? j.post : j.rules.find( ({type: we}) => we === ae);
            if (se || (se = {
                type: ae,
                rules: []
            },
            j.rules.push(se)),
            j.keywords[J] = !0,
            !H)
                return;
            const ye = {
                keyword: J,
                definition: {
                    ...H,
                    type: (0,
                    d.getJSONTypes)(H.type),
                    schemaType: (0,
                    d.getJSONTypes)(H.schemaType)
                }
            };
            H.before ? x.call(this, se, ye, H.before) : se.rules.push(ye),
            j.all[J] = ye,
            (Q = H.implements) === null || Q === void 0 || Q.forEach(we => this.addKeyword(we))
        }
        function x(J, H, ae) {
            const Q = J.rules.findIndex(P => P.keyword === ae);
            Q >= 0 ? J.rules.splice(Q, 0, H) : (J.rules.push(H),
            this.logger.warn(`rule ${ae} is not defined`))
        }
        function Y(J) {
            let {metaSchema: H} = J;
            H !== void 0 && (J.$data && this.opts.$data && (H = te(H)),
            J.validateSchema = this.compile(H, !0))
        }
        const W = {
            $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        };
        function te(J) {
            return {
                anyOf: [J, W]
            }
        }
    }
    )(ub);
    var Cg = {}
      , Mg = {}
      , Lg = {};
    Object.defineProperty(Lg, "__esModule", {
        value: !0
    });
    const hD = {
        keyword: "id",
        code() {
            throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID')
        }
    };
    Lg.default = hD;
    var aa = {};
    Object.defineProperty(aa, "__esModule", {
        value: !0
    });
    aa.callRef = aa.getValidate = void 0;
    const pD = Ro
      , vv = at
      , Rn = ot
      , Ja = oi
      , wv = Cn
      , af = Te
      , mD = {
        keyword: "$ref",
        schemaType: "string",
        code(e) {
            const {gen: t, schema: n, it: r} = e
              , {baseId: s, schemaEnv: o, validateName: c, opts: l, self: f} = r
              , {root: d} = o;
            if ((n === "#" || n === "#/") && s === d.baseId)
                return y();
            const h = wv.resolveRef.call(f, d, s, n);
            if (h === void 0)
                throw new pD.default(r.opts.uriResolver,s,n);
            if (h instanceof wv.SchemaEnv)
                return I(h);
            return $(h);
            function y() {
                if (o === d)
                    return bf(e, c, o, o.$async);
                const O = t.scopeValue("root", {
                    ref: d
                });
                return bf(e, (0,
                Rn._)`${O}.validate`, d, d.$async)
            }
            function I(O) {
                const A = Jb(e, O);
                bf(e, A, O, O.$async)
            }
            function $(O) {
                const A = t.scopeValue("schema", l.code.source === !0 ? {
                    ref: O,
                    code: (0,
                    Rn.stringify)(O)
                } : {
                    ref: O
                })
                  , N = t.name("valid")
                  , m = e.subschema({
                    schema: O,
                    dataTypes: [],
                    schemaPath: Rn.nil,
                    topSchemaRef: A,
                    errSchemaPath: n
                }, N);
                e.mergeEvaluated(m),
                e.ok(N)
            }
        }
    };
    function Jb(e, t) {
        const {gen: n} = e;
        return t.validate ? n.scopeValue("validate", {
            ref: t.validate
        }) : (0,
        Rn._)`${n.scopeValue("wrapper", {
            ref: t
        })}.validate`
    }
    aa.getValidate = Jb;
    function bf(e, t, n, r) {
        const {gen: s, it: o} = e
          , {allErrors: c, schemaEnv: l, opts: f} = o
          , d = f.passContext ? Ja.default.this : Rn.nil;
        r ? h() : y();
        function h() {
            if (!l.$async)
                throw new Error("async schema referenced by sync schema");
            const O = s.let("valid");
            s.try( () => {
                s.code((0,
                Rn._)`await ${(0,
                vv.callValidateCode)(e, t, d)}`),
                $(t),
                c || s.assign(O, !0)
            }
            , A => {
                s.if((0,
                Rn._)`!(${A} instanceof ${o.ValidationError})`, () => s.throw(A)),
                I(A),
                c || s.assign(O, !1)
            }
            ),
            e.ok(O)
        }
        function y() {
            e.result((0,
            vv.callValidateCode)(e, t, d), () => $(t), () => I(t))
        }
        function I(O) {
            const A = (0,
            Rn._)`${O}.errors`;
            s.assign(Ja.default.vErrors, (0,
            Rn._)`${Ja.default.vErrors} === null ? ${A} : ${Ja.default.vErrors}.concat(${A})`),
            s.assign(Ja.default.errors, (0,
            Rn._)`${Ja.default.vErrors}.length`)
        }
        function $(O) {
            var A;
            if (!o.opts.unevaluated)
                return;
            const N = (A = n?.validate) === null || A === void 0 ? void 0 : A.evaluated;
            if (o.props !== !0)
                if (N && !N.dynamicProps)
                    N.props !== void 0 && (o.props = af.mergeEvaluated.props(s, N.props, o.props));
                else {
                    const m = s.var("props", (0,
                    Rn._)`${O}.evaluated.props`);
                    o.props = af.mergeEvaluated.props(s, m, o.props, Rn.Name)
                }
            if (o.items !== !0)
                if (N && !N.dynamicItems)
                    N.items !== void 0 && (o.items = af.mergeEvaluated.items(s, N.items, o.items));
                else {
                    const m = s.var("items", (0,
                    Rn._)`${O}.evaluated.items`);
                    o.items = af.mergeEvaluated.items(s, m, o.items, Rn.Name)
                }
        }
    }
    aa.callRef = bf;
    aa.default = mD;
    Object.defineProperty(Mg, "__esModule", {
        value: !0
    });
    const gD = Lg
      , yD = aa
      , _D = ["$schema", "$id", "$defs", "$vocabulary", {
        keyword: "$comment"
    }, "definitions", gD.default, yD.default];
    Mg.default = _D;
    var Dg = {}
      , Ug = {};
    Object.defineProperty(Ug, "__esModule", {
        value: !0
    });
    const kf = ot
      , ls = kf.operators
      , Cf = {
        maximum: {
            okStr: "<=",
            ok: ls.LTE,
            fail: ls.GT
        },
        minimum: {
            okStr: ">=",
            ok: ls.GTE,
            fail: ls.LT
        },
        exclusiveMaximum: {
            okStr: "<",
            ok: ls.LT,
            fail: ls.GTE
        },
        exclusiveMinimum: {
            okStr: ">",
            ok: ls.GT,
            fail: ls.LTE
        }
    }
      , vD = {
        message: ({keyword: e, schemaCode: t}) => (0,
        kf.str)`must be ${Cf[e].okStr} ${t}`,
        params: ({keyword: e, schemaCode: t}) => (0,
        kf._)`{comparison: ${Cf[e].okStr}, limit: ${t}}`
    }
      , wD = {
        keyword: Object.keys(Cf),
        type: "number",
        schemaType: "number",
        $data: !0,
        error: vD,
        code(e) {
            const {keyword: t, data: n, schemaCode: r} = e;
            e.fail$data((0,
            kf._)`${n} ${Cf[t].fail} ${r} || isNaN(${n})`)
        }
    };
    Ug.default = wD;
    var Bg = {};
    Object.defineProperty(Bg, "__esModule", {
        value: !0
    });
    const Qc = ot
      , bD = {
        message: ({schemaCode: e}) => (0,
        Qc.str)`must be multiple of ${e}`,
        params: ({schemaCode: e}) => (0,
        Qc._)`{multipleOf: ${e}}`
    }
      , ED = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: !0,
        error: bD,
        code(e) {
            const {gen: t, data: n, schemaCode: r, it: s} = e
              , o = s.opts.multipleOfPrecision
              , c = t.let("res")
              , l = o ? (0,
            Qc._)`Math.abs(Math.round(${c}) - ${c}) > 1e-${o}` : (0,
            Qc._)`${c} !== parseInt(${c})`;
            e.fail$data((0,
            Qc._)`(${r} === 0 || (${c} = ${n}/${r}, ${l}))`)
        }
    };
    Bg.default = ED;
    var Fg = {}
      , jg = {};
    Object.defineProperty(jg, "__esModule", {
        value: !0
    });
    function Xb(e) {
        const t = e.length;
        let n = 0, r = 0, s;
        for (; r < t; )
            n++,
            s = e.charCodeAt(r++),
            s >= 55296 && s <= 56319 && r < t && (s = e.charCodeAt(r),
            (s & 64512) === 56320 && r++);
        return n
    }
    jg.default = Xb;
    Xb.code = 'require("ajv/dist/runtime/ucs2length").default';
    Object.defineProperty(Fg, "__esModule", {
        value: !0
    });
    const Gs = ot
      , SD = Te
      , TD = jg
      , AD = {
        message({keyword: e, schemaCode: t}) {
            const n = e === "maxLength" ? "more" : "fewer";
            return (0,
            Gs.str)`must NOT have ${n} than ${t} characters`
        },
        params: ({schemaCode: e}) => (0,
        Gs._)`{limit: ${e}}`
    }
      , OD = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: !0,
        error: AD,
        code(e) {
            const {keyword: t, data: n, schemaCode: r, it: s} = e
              , o = t === "maxLength" ? Gs.operators.GT : Gs.operators.LT
              , c = s.opts.unicode === !1 ? (0,
            Gs._)`${n}.length` : (0,
            Gs._)`${(0,
            SD.useFunc)(e.gen, TD.default)}(${n})`;
            e.fail$data((0,
            Gs._)`${c} ${o} ${r}`)
        }
    };
    Fg.default = OD;
    var qg = {};
    Object.defineProperty(qg, "__esModule", {
        value: !0
    });
    const ID = at
      , Mf = ot
      , ND = {
        message: ({schemaCode: e}) => (0,
        Mf.str)`must match pattern "${e}"`,
        params: ({schemaCode: e}) => (0,
        Mf._)`{pattern: ${e}}`
    }
      , xD = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: !0,
        error: ND,
        code(e) {
            const {data: t, $data: n, schema: r, schemaCode: s, it: o} = e
              , c = o.opts.unicodeRegExp ? "u" : ""
              , l = n ? (0,
            Mf._)`(new RegExp(${s}, ${c}))` : (0,
            ID.usePattern)(e, r);
            e.fail$data((0,
            Mf._)`!${l}.test(${t})`)
        }
    };
    qg.default = xD;
    var Hg = {};
    Object.defineProperty(Hg, "__esModule", {
        value: !0
    });
    const eu = ot
      , $D = {
        message({keyword: e, schemaCode: t}) {
            const n = e === "maxProperties" ? "more" : "fewer";
            return (0,
            eu.str)`must NOT have ${n} than ${t} properties`
        },
        params: ({schemaCode: e}) => (0,
        eu._)`{limit: ${e}}`
    }
      , RD = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: !0,
        error: $D,
        code(e) {
            const {keyword: t, data: n, schemaCode: r} = e
              , s = t === "maxProperties" ? eu.operators.GT : eu.operators.LT;
            e.fail$data((0,
            eu._)`Object.keys(${n}).length ${s} ${r}`)
        }
    };
    Hg.default = RD;
    var Yg = {};
    Object.defineProperty(Yg, "__esModule", {
        value: !0
    });
    const $c = at
      , tu = ot
      , PD = Te
      , kD = {
        message: ({params: {missingProperty: e}}) => (0,
        tu.str)`must have required property '${e}'`,
        params: ({params: {missingProperty: e}}) => (0,
        tu._)`{missingProperty: ${e}}`
    }
      , CD = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: !0,
        error: kD,
        code(e) {
            const {gen: t, schema: n, schemaCode: r, data: s, $data: o, it: c} = e
              , {opts: l} = c;
            if (!o && n.length === 0)
                return;
            const f = n.length >= l.loopRequired;
            if (c.allErrors ? d() : h(),
            l.strictRequired) {
                const $ = e.parentSchema.properties
                  , {definedProperties: O} = e.it;
                for (const A of n)
                    if ($?.[A] === void 0 && !O.has(A)) {
                        const N = c.schemaEnv.baseId + c.errSchemaPath
                          , m = `required property "${A}" is not defined at "${N}" (strictRequired)`;
                        (0,
                        PD.checkStrictMode)(c, m, c.opts.strictRequired)
                    }
            }
            function d() {
                if (f || o)
                    e.block$data(tu.nil, y);
                else
                    for (const $ of n)
                        (0,
                        $c.checkReportMissingProp)(e, $)
            }
            function h() {
                const $ = t.let("missing");
                if (f || o) {
                    const O = t.let("valid", !0);
                    e.block$data(O, () => I($, O)),
                    e.ok(O)
                } else
                    t.if((0,
                    $c.checkMissingProp)(e, n, $)),
                    (0,
                    $c.reportMissingProp)(e, $),
                    t.else()
            }
            function y() {
                t.forOf("prop", r, $ => {
                    e.setParams({
                        missingProperty: $
                    }),
                    t.if((0,
                    $c.noPropertyInData)(t, s, $, l.ownProperties), () => e.error())
                }
                )
            }
            function I($, O) {
                e.setParams({
                    missingProperty: $
                }),
                t.forOf($, r, () => {
                    t.assign(O, (0,
                    $c.propertyInData)(t, s, $, l.ownProperties)),
                    t.if((0,
                    tu.not)(O), () => {
                        e.error(),
                        t.break()
                    }
                    )
                }
                , tu.nil)
            }
        }
    };
    Yg.default = CD;
    var Vg = {};
    Object.defineProperty(Vg, "__esModule", {
        value: !0
    });
    const nu = ot
      , MD = {
        message({keyword: e, schemaCode: t}) {
            const n = e === "maxItems" ? "more" : "fewer";
            return (0,
            nu.str)`must NOT have ${n} than ${t} items`
        },
        params: ({schemaCode: e}) => (0,
        nu._)`{limit: ${e}}`
    }
      , LD = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: !0,
        error: MD,
        code(e) {
            const {keyword: t, data: n, schemaCode: r} = e
              , s = t === "maxItems" ? nu.operators.GT : nu.operators.LT;
            e.fail$data((0,
            nu._)`${n}.length ${s} ${r}`)
        }
    };
    Vg.default = LD;
    var Wg = {}
      , ju = {};
    Object.defineProperty(ju, "__esModule", {
        value: !0
    });
    const Qb = Ab;
    Qb.code = 'require("ajv/dist/runtime/equal").default';
    ju.default = Qb;
    Object.defineProperty(Wg, "__esModule", {
        value: !0
    });
    const Ap = Kt
      , cn = ot
      , DD = Te
      , UD = ju
      , BD = {
        message: ({params: {i: e, j: t}}) => (0,
        cn.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
        params: ({params: {i: e, j: t}}) => (0,
        cn._)`{i: ${e}, j: ${t}}`
    }
      , FD = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: !0,
        error: BD,
        code(e) {
            const {gen: t, data: n, $data: r, schema: s, parentSchema: o, schemaCode: c, it: l} = e;
            if (!r && !s)
                return;
            const f = t.let("valid")
              , d = o.items ? (0,
            Ap.getSchemaTypes)(o.items) : [];
            e.block$data(f, h, (0,
            cn._)`${c} === false`),
            e.ok(f);
            function h() {
                const O = t.let("i", (0,
                cn._)`${n}.length`)
                  , A = t.let("j");
                e.setParams({
                    i: O,
                    j: A
                }),
                t.assign(f, !0),
                t.if((0,
                cn._)`${O} > 1`, () => (y() ? I : $)(O, A))
            }
            function y() {
                return d.length > 0 && !d.some(O => O === "object" || O === "array")
            }
            function I(O, A) {
                const N = t.name("item")
                  , m = (0,
                Ap.checkDataTypes)(d, N, l.opts.strictNumbers, Ap.DataType.Wrong)
                  , g = t.const("indices", (0,
                cn._)`{}`);
                t.for((0,
                cn._)`;${O}--;`, () => {
                    t.let(N, (0,
                    cn._)`${n}[${O}]`),
                    t.if(m, (0,
                    cn._)`continue`),
                    d.length > 1 && t.if((0,
                    cn._)`typeof ${N} == "string"`, (0,
                    cn._)`${N} += "_"`),
                    t.if((0,
                    cn._)`typeof ${g}[${N}] == "number"`, () => {
                        t.assign(A, (0,
                        cn._)`${g}[${N}]`),
                        e.error(),
                        t.assign(f, !1).break()
                    }
                    ).code((0,
                    cn._)`${g}[${N}] = ${O}`)
                }
                )
            }
            function $(O, A) {
                const N = (0,
                DD.useFunc)(t, UD.default)
                  , m = t.name("outer");
                t.label(m).for((0,
                cn._)`;${O}--;`, () => t.for((0,
                cn._)`${A} = ${O}; ${A}--;`, () => t.if((0,
                cn._)`${N}(${n}[${O}], ${n}[${A}])`, () => {
                    e.error(),
                    t.assign(f, !1).break(m)
                }
                )))
            }
        }
    };
    Wg.default = FD;
    var zg = {};
    Object.defineProperty(zg, "__esModule", {
        value: !0
    });
    const mm = ot
      , jD = Te
      , qD = ju
      , HD = {
        message: "must be equal to constant",
        params: ({schemaCode: e}) => (0,
        mm._)`{allowedValue: ${e}}`
    }
      , YD = {
        keyword: "const",
        $data: !0,
        error: HD,
        code(e) {
            const {gen: t, data: n, $data: r, schemaCode: s, schema: o} = e;
            r || o && typeof o == "object" ? e.fail$data((0,
            mm._)`!${(0,
            jD.useFunc)(t, qD.default)}(${n}, ${s})`) : e.fail((0,
            mm._)`${o} !== ${n}`)
        }
    };
    zg.default = YD;
    var Gg = {};
    Object.defineProperty(Gg, "__esModule", {
        value: !0
    });
    const Wc = ot
      , VD = Te
      , WD = ju
      , zD = {
        message: "must be equal to one of the allowed values",
        params: ({schemaCode: e}) => (0,
        Wc._)`{allowedValues: ${e}}`
    }
      , GD = {
        keyword: "enum",
        schemaType: "array",
        $data: !0,
        error: zD,
        code(e) {
            const {gen: t, data: n, $data: r, schema: s, schemaCode: o, it: c} = e;
            if (!r && s.length === 0)
                throw new Error("enum must have non-empty array");
            const l = s.length >= c.opts.loopEnum;
            let f;
            const d = () => f ?? (f = (0,
            VD.useFunc)(t, WD.default));
            let h;
            if (l || r)
                h = t.let("valid"),
                e.block$data(h, y);
            else {
                if (!Array.isArray(s))
                    throw new Error("ajv implementation error");
                const $ = t.const("vSchema", o);
                h = (0,
                Wc.or)(...s.map( (O, A) => I($, A)))
            }
            e.pass(h);
            function y() {
                t.assign(h, !1),
                t.forOf("v", o, $ => t.if((0,
                Wc._)`${d()}(${n}, ${$})`, () => t.assign(h, !0).break()))
            }
            function I($, O) {
                const A = s[O];
                return typeof A == "object" && A !== null ? (0,
                Wc._)`${d()}(${n}, ${$}[${O}])` : (0,
                Wc._)`${n} === ${A}`
            }
        }
    };
    Gg.default = GD;
    Object.defineProperty(Dg, "__esModule", {
        value: !0
    });
    const ZD = Ug
      , KD = Bg
      , JD = Fg
      , XD = qg
      , QD = Hg
      , eU = Yg
      , tU = Vg
      , nU = Wg
      , rU = zg
      , iU = Gg
      , sU = [ZD.default, KD.default, JD.default, XD.default, QD.default, eU.default, tU.default, nU.default, {
        keyword: "type",
        schemaType: ["string", "array"]
    }, {
        keyword: "nullable",
        schemaType: "boolean"
    }, rU.default, iU.default];
    Dg.default = sU;
    var Zg = {}
      , Po = {};
    Object.defineProperty(Po, "__esModule", {
        value: !0
    });
    Po.validateAdditionalItems = void 0;
    const Zs = ot
      , gm = Te
      , aU = {
        message: ({params: {len: e}}) => (0,
        Zs.str)`must NOT have more than ${e} items`,
        params: ({params: {len: e}}) => (0,
        Zs._)`{limit: ${e}}`
    }
      , oU = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error: aU,
        code(e) {
            const {parentSchema: t, it: n} = e
              , {items: r} = t;
            if (!Array.isArray(r)) {
                (0,
                gm.checkStrictMode)(n, '"additionalItems" is ignored when "items" is not an array of schemas');
                return
            }
            eE(e, r)
        }
    };
    function eE(e, t) {
        const {gen: n, schema: r, data: s, keyword: o, it: c} = e;
        c.items = !0;
        const l = n.const("len", (0,
        Zs._)`${s}.length`);
        if (r === !1)
            e.setParams({
                len: t.length
            }),
            e.pass((0,
            Zs._)`${l} <= ${t.length}`);
        else if (typeof r == "object" && !(0,
        gm.alwaysValidSchema)(c, r)) {
            const d = n.var("valid", (0,
            Zs._)`${l} <= ${t.length}`);
            n.if((0,
            Zs.not)(d), () => f(d)),
            e.ok(d)
        }
        function f(d) {
            n.forRange("i", t.length, l, h => {
                e.subschema({
                    keyword: o,
                    dataProp: h,
                    dataPropType: gm.Type.Num
                }, d),
                c.allErrors || n.if((0,
                Zs.not)(d), () => n.break())
            }
            )
        }
    }
    Po.validateAdditionalItems = eE;
    Po.default = oU;
    var Kg = {}
      , ko = {};
    Object.defineProperty(ko, "__esModule", {
        value: !0
    });
    ko.validateTuple = void 0;
    const bv = ot
      , Ef = Te
      , cU = at
      , uU = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code(e) {
            const {schema: t, it: n} = e;
            if (Array.isArray(t))
                return tE(e, "additionalItems", t);
            n.items = !0,
            !(0,
            Ef.alwaysValidSchema)(n, t) && e.ok((0,
            cU.validateArray)(e))
        }
    };
    function tE(e, t, n=e.schema) {
        const {gen: r, parentSchema: s, data: o, keyword: c, it: l} = e;
        h(s),
        l.opts.unevaluated && n.length && l.items !== !0 && (l.items = Ef.mergeEvaluated.items(r, n.length, l.items));
        const f = r.name("valid")
          , d = r.const("len", (0,
        bv._)`${o}.length`);
        n.forEach( (y, I) => {
            (0,
            Ef.alwaysValidSchema)(l, y) || (r.if((0,
            bv._)`${d} > ${I}`, () => e.subschema({
                keyword: c,
                schemaProp: I,
                dataProp: I
            }, f)),
            e.ok(f))
        }
        );
        function h(y) {
            const {opts: I, errSchemaPath: $} = l
              , O = n.length
              , A = O === y.minItems && (O === y.maxItems || y[t] === !1);
            if (I.strictTuples && !A) {
                const N = `"${c}" is ${O}-tuple, but minItems or maxItems/${t} are not specified or different at path "${$}"`;
                (0,
                Ef.checkStrictMode)(l, N, I.strictTuples)
            }
        }
    }
    ko.validateTuple = tE;
    ko.default = uU;
    Object.defineProperty(Kg, "__esModule", {
        value: !0
    });
    const lU = ko
      , fU = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: e => (0,
        lU.validateTuple)(e, "items")
    };
    Kg.default = fU;
    var Jg = {};
    Object.defineProperty(Jg, "__esModule", {
        value: !0
    });
    const Ev = ot
      , dU = Te
      , hU = at
      , pU = Po
      , mU = {
        message: ({params: {len: e}}) => (0,
        Ev.str)`must NOT have more than ${e} items`,
        params: ({params: {len: e}}) => (0,
        Ev._)`{limit: ${e}}`
    }
      , gU = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error: mU,
        code(e) {
            const {schema: t, parentSchema: n, it: r} = e
              , {prefixItems: s} = n;
            r.items = !0,
            !(0,
            dU.alwaysValidSchema)(r, t) && (s ? (0,
            pU.validateAdditionalItems)(e, s) : e.ok((0,
            hU.validateArray)(e)))
        }
    };
    Jg.default = gU;
    var Xg = {};
    Object.defineProperty(Xg, "__esModule", {
        value: !0
    });
    const ur = ot
      , of = Te
      , yU = {
        message: ({params: {min: e, max: t}}) => t === void 0 ? (0,
        ur.str)`must contain at least ${e} valid item(s)` : (0,
        ur.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
        params: ({params: {min: e, max: t}}) => t === void 0 ? (0,
        ur._)`{minContains: ${e}}` : (0,
        ur._)`{minContains: ${e}, maxContains: ${t}}`
    }
      , _U = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: !0,
        error: yU,
        code(e) {
            const {gen: t, schema: n, parentSchema: r, data: s, it: o} = e;
            let c, l;
            const {minContains: f, maxContains: d} = r;
            o.opts.next ? (c = f === void 0 ? 1 : f,
            l = d) : c = 1;
            const h = t.const("len", (0,
            ur._)`${s}.length`);
            if (e.setParams({
                min: c,
                max: l
            }),
            l === void 0 && c === 0) {
                (0,
                of.checkStrictMode)(o, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
                return
            }
            if (l !== void 0 && c > l) {
                (0,
                of.checkStrictMode)(o, '"minContains" > "maxContains" is always invalid'),
                e.fail();
                return
            }
            if ((0,
            of.alwaysValidSchema)(o, n)) {
                let A = (0,
                ur._)`${h} >= ${c}`;
                l !== void 0 && (A = (0,
                ur._)`${A} && ${h} <= ${l}`),
                e.pass(A);
                return
            }
            o.items = !0;
            const y = t.name("valid");
            l === void 0 && c === 1 ? $(y, () => t.if(y, () => t.break())) : c === 0 ? (t.let(y, !0),
            l !== void 0 && t.if((0,
            ur._)`${s}.length > 0`, I)) : (t.let(y, !1),
            I()),
            e.result(y, () => e.reset());
            function I() {
                const A = t.name("_valid")
                  , N = t.let("count", 0);
                $(A, () => t.if(A, () => O(N)))
            }
            function $(A, N) {
                t.forRange("i", 0, h, m => {
                    e.subschema({
                        keyword: "contains",
                        dataProp: m,
                        dataPropType: of.Type.Num,
                        compositeRule: !0
                    }, A),
                    N()
                }
                )
            }
            function O(A) {
                t.code((0,
                ur._)`${A}++`),
                l === void 0 ? t.if((0,
                ur._)`${A} >= ${c}`, () => t.assign(y, !0).break()) : (t.if((0,
                ur._)`${A} > ${l}`, () => t.assign(y, !1).break()),
                c === 1 ? t.assign(y, !0) : t.if((0,
                ur._)`${A} >= ${c}`, () => t.assign(y, !0)))
            }
        }
    };
    Xg.default = _U;
    var nE = {};
    (function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
        const t = ot
          , n = Te
          , r = at;
        e.error = {
            message: ({params: {property: f, depsCount: d, deps: h}}) => {
                const y = d === 1 ? "property" : "properties";
                return (0,
                t.str)`must have ${y} ${h} when property ${f} is present`
            }
            ,
            params: ({params: {property: f, depsCount: d, deps: h, missingProperty: y}}) => (0,
            t._)`{property: ${f},
    missingProperty: ${y},
    depsCount: ${d},
    deps: ${h}}`
        };
        const s = {
            keyword: "dependencies",
            type: "object",
            schemaType: "object",
            error: e.error,
            code(f) {
                const [d,h] = o(f);
                c(f, d),
                l(f, h)
            }
        };
        function o({schema: f}) {
            const d = {}
              , h = {};
            for (const y in f) {
                if (y === "__proto__")
                    continue;
                const I = Array.isArray(f[y]) ? d : h;
                I[y] = f[y]
            }
            return [d, h]
        }
        function c(f, d=f.schema) {
            const {gen: h, data: y, it: I} = f;
            if (Object.keys(d).length === 0)
                return;
            const $ = h.let("missing");
            for (const O in d) {
                const A = d[O];
                if (A.length === 0)
                    continue;
                const N = (0,
                r.propertyInData)(h, y, O, I.opts.ownProperties);
                f.setParams({
                    property: O,
                    depsCount: A.length,
                    deps: A.join(", ")
                }),
                I.allErrors ? h.if(N, () => {
                    for (const m of A)
                        (0,
                        r.checkReportMissingProp)(f, m)
                }
                ) : (h.if((0,
                t._)`${N} && (${(0,
                r.checkMissingProp)(f, A, $)})`),
                (0,
                r.reportMissingProp)(f, $),
                h.else())
            }
        }
        e.validatePropertyDeps = c;
        function l(f, d=f.schema) {
            const {gen: h, data: y, keyword: I, it: $} = f
              , O = h.name("valid");
            for (const A in d)
                (0,
                n.alwaysValidSchema)($, d[A]) || (h.if((0,
                r.propertyInData)(h, y, A, $.opts.ownProperties), () => {
                    const N = f.subschema({
                        keyword: I,
                        schemaProp: A
                    }, O);
                    f.mergeValidEvaluated(N, O)
                }
                , () => h.var(O, !0)),
                f.ok(O))
        }
        e.validateSchemaDeps = l,
        e.default = s
    }
    )(nE);
    var Qg = {};
    Object.defineProperty(Qg, "__esModule", {
        value: !0
    });
    const rE = ot
      , vU = Te
      , wU = {
        message: "property name must be valid",
        params: ({params: e}) => (0,
        rE._)`{propertyName: ${e.propertyName}}`
    }
      , bU = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error: wU,
        code(e) {
            const {gen: t, schema: n, data: r, it: s} = e;
            if ((0,
            vU.alwaysValidSchema)(s, n))
                return;
            const o = t.name("valid");
            t.forIn("key", r, c => {
                e.setParams({
                    propertyName: c
                }),
                e.subschema({
                    keyword: "propertyNames",
                    data: c,
                    dataTypes: ["string"],
                    propertyName: c,
                    compositeRule: !0
                }, o),
                t.if((0,
                rE.not)(o), () => {
                    e.error(!0),
                    s.allErrors || t.break()
                }
                )
            }
            ),
            e.ok(o)
        }
    };
    Qg.default = bU;
    var Cd = {};
    Object.defineProperty(Cd, "__esModule", {
        value: !0
    });
    const cf = at
      , Or = ot
      , EU = oi
      , uf = Te
      , SU = {
        message: "must NOT have additional properties",
        params: ({params: e}) => (0,
        Or._)`{additionalProperty: ${e.additionalProperty}}`
    }
      , TU = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: !0,
        trackErrors: !0,
        error: SU,
        code(e) {
            const {gen: t, schema: n, parentSchema: r, data: s, errsCount: o, it: c} = e;
            if (!o)
                throw new Error("ajv implementation error");
            const {allErrors: l, opts: f} = c;
            if (c.props = !0,
            f.removeAdditional !== "all" && (0,
            uf.alwaysValidSchema)(c, n))
                return;
            const d = (0,
            cf.allSchemaProperties)(r.properties)
              , h = (0,
            cf.allSchemaProperties)(r.patternProperties);
            y(),
            e.ok((0,
            Or._)`${o} === ${EU.default.errors}`);
            function y() {
                t.forIn("key", s, N => {
                    !d.length && !h.length ? O(N) : t.if(I(N), () => O(N))
                }
                )
            }
            function I(N) {
                let m;
                if (d.length > 8) {
                    const g = (0,
                    uf.schemaRefOrVal)(c, r.properties, "properties");
                    m = (0,
                    cf.isOwnProperty)(t, g, N)
                } else
                    d.length ? m = (0,
                    Or.or)(...d.map(g => (0,
                    Or._)`${N} === ${g}`)) : m = Or.nil;
                return h.length && (m = (0,
                Or.or)(m, ...h.map(g => (0,
                Or._)`${(0,
                cf.usePattern)(e, g)}.test(${N})`))),
                (0,
                Or.not)(m)
            }
            function $(N) {
                t.code((0,
                Or._)`delete ${s}[${N}]`)
            }
            function O(N) {
                if (f.removeAdditional === "all" || f.removeAdditional && n === !1) {
                    $(N);
                    return
                }
                if (n === !1) {
                    e.setParams({
                        additionalProperty: N
                    }),
                    e.error(),
                    l || t.break();
                    return
                }
                if (typeof n == "object" && !(0,
                uf.alwaysValidSchema)(c, n)) {
                    const m = t.name("valid");
                    f.removeAdditional === "failing" ? (A(N, m, !1),
                    t.if((0,
                    Or.not)(m), () => {
                        e.reset(),
                        $(N)
                    }
                    )) : (A(N, m),
                    l || t.if((0,
                    Or.not)(m), () => t.break()))
                }
            }
            function A(N, m, g) {
                const M = {
                    keyword: "additionalProperties",
                    dataProp: N,
                    dataPropType: uf.Type.Str
                };
                g === !1 && Object.assign(M, {
                    compositeRule: !0,
                    createErrors: !1,
                    allErrors: !1
                }),
                e.subschema(M, m)
            }
        }
    };
    Cd.default = TU;
    var e0 = {};
    Object.defineProperty(e0, "__esModule", {
        value: !0
    });
    const AU = kr
      , Sv = at
      , Op = Te
      , Tv = Cd
      , OU = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code(e) {
            const {gen: t, schema: n, parentSchema: r, data: s, it: o} = e;
            o.opts.removeAdditional === "all" && r.additionalProperties === void 0 && Tv.default.code(new AU.KeywordCxt(o,Tv.default,"additionalProperties"));
            const c = (0,
            Sv.allSchemaProperties)(n);
            for (const y of c)
                o.definedProperties.add(y);
            o.opts.unevaluated && c.length && o.props !== !0 && (o.props = Op.mergeEvaluated.props(t, (0,
            Op.toHash)(c), o.props));
            const l = c.filter(y => !(0,
            Op.alwaysValidSchema)(o, n[y]));
            if (l.length === 0)
                return;
            const f = t.name("valid");
            for (const y of l)
                d(y) ? h(y) : (t.if((0,
                Sv.propertyInData)(t, s, y, o.opts.ownProperties)),
                h(y),
                o.allErrors || t.else().var(f, !0),
                t.endIf()),
                e.it.definedProperties.add(y),
                e.ok(f);
            function d(y) {
                return o.opts.useDefaults && !o.compositeRule && n[y].default !== void 0
            }
            function h(y) {
                e.subschema({
                    keyword: "properties",
                    schemaProp: y,
                    dataProp: y
                }, f)
            }
        }
    };
    e0.default = OU;
    var t0 = {};
    Object.defineProperty(t0, "__esModule", {
        value: !0
    });
    const Av = at
      , lf = ot
      , Ov = Te
      , Iv = Te
      , IU = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code(e) {
            const {gen: t, schema: n, data: r, parentSchema: s, it: o} = e
              , {opts: c} = o
              , l = (0,
            Av.allSchemaProperties)(n)
              , f = l.filter(A => (0,
            Ov.alwaysValidSchema)(o, n[A]));
            if (l.length === 0 || f.length === l.length && (!o.opts.unevaluated || o.props === !0))
                return;
            const d = c.strictSchema && !c.allowMatchingProperties && s.properties
              , h = t.name("valid");
            o.props !== !0 && !(o.props instanceof lf.Name) && (o.props = (0,
            Iv.evaluatedPropsToName)(t, o.props));
            const {props: y} = o;
            I();
            function I() {
                for (const A of l)
                    d && $(A),
                    o.allErrors ? O(A) : (t.var(h, !0),
                    O(A),
                    t.if(h))
            }
            function $(A) {
                for (const N in d)
                    new RegExp(A).test(N) && (0,
                    Ov.checkStrictMode)(o, `property ${N} matches pattern ${A} (use allowMatchingProperties)`)
            }
            function O(A) {
                t.forIn("key", r, N => {
                    t.if((0,
                    lf._)`${(0,
                    Av.usePattern)(e, A)}.test(${N})`, () => {
                        const m = f.includes(A);
                        m || e.subschema({
                            keyword: "patternProperties",
                            schemaProp: A,
                            dataProp: N,
                            dataPropType: Iv.Type.Str
                        }, h),
                        o.opts.unevaluated && y !== !0 ? t.assign((0,
                        lf._)`${y}[${N}]`, !0) : !m && !o.allErrors && t.if((0,
                        lf.not)(h), () => t.break())
                    }
                    )
                }
                )
            }
        }
    };
    t0.default = IU;
    var n0 = {};
    Object.defineProperty(n0, "__esModule", {
        value: !0
    });
    const NU = Te
      , xU = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        code(e) {
            const {gen: t, schema: n, it: r} = e;
            if ((0,
            NU.alwaysValidSchema)(r, n)) {
                e.fail();
                return
            }
            const s = t.name("valid");
            e.subschema({
                keyword: "not",
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1
            }, s),
            e.failResult(s, () => e.reset(), () => e.error())
        },
        error: {
            message: "must NOT be valid"
        }
    };
    n0.default = xU;
    var r0 = {};
    Object.defineProperty(r0, "__esModule", {
        value: !0
    });
    const $U = at
      , RU = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: !0,
        code: $U.validateUnion,
        error: {
            message: "must match a schema in anyOf"
        }
    };
    r0.default = RU;
    var i0 = {};
    Object.defineProperty(i0, "__esModule", {
        value: !0
    });
    const Sf = ot
      , PU = Te
      , kU = {
        message: "must match exactly one schema in oneOf",
        params: ({params: e}) => (0,
        Sf._)`{passingSchemas: ${e.passing}}`
    }
      , CU = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: !0,
        error: kU,
        code(e) {
            const {gen: t, schema: n, parentSchema: r, it: s} = e;
            if (!Array.isArray(n))
                throw new Error("ajv implementation error");
            if (s.opts.discriminator && r.discriminator)
                return;
            const o = n
              , c = t.let("valid", !1)
              , l = t.let("passing", null)
              , f = t.name("_valid");
            e.setParams({
                passing: l
            }),
            t.block(d),
            e.result(c, () => e.reset(), () => e.error(!0));
            function d() {
                o.forEach( (h, y) => {
                    let I;
                    (0,
                    PU.alwaysValidSchema)(s, h) ? t.var(f, !0) : I = e.subschema({
                        keyword: "oneOf",
                        schemaProp: y,
                        compositeRule: !0
                    }, f),
                    y > 0 && t.if((0,
                    Sf._)`${f} && ${c}`).assign(c, !1).assign(l, (0,
                    Sf._)`[${l}, ${y}]`).else(),
                    t.if(f, () => {
                        t.assign(c, !0),
                        t.assign(l, y),
                        I && e.mergeEvaluated(I, Sf.Name)
                    }
                    )
                }
                )
            }
        }
    };
    i0.default = CU;
    var s0 = {};
    Object.defineProperty(s0, "__esModule", {
        value: !0
    });
    const MU = Te
      , LU = {
        keyword: "allOf",
        schemaType: "array",
        code(e) {
            const {gen: t, schema: n, it: r} = e;
            if (!Array.isArray(n))
                throw new Error("ajv implementation error");
            const s = t.name("valid");
            n.forEach( (o, c) => {
                if ((0,
                MU.alwaysValidSchema)(r, o))
                    return;
                const l = e.subschema({
                    keyword: "allOf",
                    schemaProp: c
                }, s);
                e.ok(s),
                e.mergeEvaluated(l)
            }
            )
        }
    };
    s0.default = LU;
    var a0 = {};
    Object.defineProperty(a0, "__esModule", {
        value: !0
    });
    const Lf = ot
      , iE = Te
      , DU = {
        message: ({params: e}) => (0,
        Lf.str)`must match "${e.ifClause}" schema`,
        params: ({params: e}) => (0,
        Lf._)`{failingKeyword: ${e.ifClause}}`
    }
      , UU = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        error: DU,
        code(e) {
            const {gen: t, parentSchema: n, it: r} = e;
            n.then === void 0 && n.else === void 0 && (0,
            iE.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
            const s = Nv(r, "then")
              , o = Nv(r, "else");
            if (!s && !o)
                return;
            const c = t.let("valid", !0)
              , l = t.name("_valid");
            if (f(),
            e.reset(),
            s && o) {
                const h = t.let("ifClause");
                e.setParams({
                    ifClause: h
                }),
                t.if(l, d("then", h), d("else", h))
            } else
                s ? t.if(l, d("then")) : t.if((0,
                Lf.not)(l), d("else"));
            e.pass(c, () => e.error(!0));
            function f() {
                const h = e.subschema({
                    keyword: "if",
                    compositeRule: !0,
                    createErrors: !1,
                    allErrors: !1
                }, l);
                e.mergeEvaluated(h)
            }
            function d(h, y) {
                return () => {
                    const I = e.subschema({
                        keyword: h
                    }, l);
                    t.assign(c, l),
                    e.mergeValidEvaluated(I, c),
                    y ? t.assign(y, (0,
                    Lf._)`${h}`) : e.setParams({
                        ifClause: h
                    })
                }
            }
        }
    };
    function Nv(e, t) {
        const n = e.schema[t];
        return n !== void 0 && !(0,
        iE.alwaysValidSchema)(e, n)
    }
    a0.default = UU;
    var o0 = {};
    Object.defineProperty(o0, "__esModule", {
        value: !0
    });
    const BU = Te
      , FU = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({keyword: e, parentSchema: t, it: n}) {
            t.if === void 0 && (0,
            BU.checkStrictMode)(n, `"${e}" without "if" is ignored`)
        }
    };
    o0.default = FU;
    Object.defineProperty(Zg, "__esModule", {
        value: !0
    });
    const jU = Po
      , qU = Kg
      , HU = ko
      , YU = Jg
      , VU = Xg
      , WU = nE
      , zU = Qg
      , GU = Cd
      , ZU = e0
      , KU = t0
      , JU = n0
      , XU = r0
      , QU = i0
      , eB = s0
      , tB = a0
      , nB = o0;
    function rB(e=!1) {
        const t = [JU.default, XU.default, QU.default, eB.default, tB.default, nB.default, zU.default, GU.default, WU.default, ZU.default, KU.default];
        return e ? t.push(qU.default, YU.default) : t.push(jU.default, HU.default),
        t.push(VU.default),
        t
    }
    Zg.default = rB;
    var c0 = {}
      , u0 = {};
    Object.defineProperty(u0, "__esModule", {
        value: !0
    });
    const Ht = ot
      , iB = {
        message: ({schemaCode: e}) => (0,
        Ht.str)`must match format "${e}"`,
        params: ({schemaCode: e}) => (0,
        Ht._)`{format: ${e}}`
    }
      , sB = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: !0,
        error: iB,
        code(e, t) {
            const {gen: n, data: r, $data: s, schema: o, schemaCode: c, it: l} = e
              , {opts: f, errSchemaPath: d, schemaEnv: h, self: y} = l;
            if (!f.validateFormats)
                return;
            s ? I() : $();
            function I() {
                const O = n.scopeValue("formats", {
                    ref: y.formats,
                    code: f.code.formats
                })
                  , A = n.const("fDef", (0,
                Ht._)`${O}[${c}]`)
                  , N = n.let("fType")
                  , m = n.let("format");
                n.if((0,
                Ht._)`typeof ${A} == "object" && !(${A} instanceof RegExp)`, () => n.assign(N, (0,
                Ht._)`${A}.type || "string"`).assign(m, (0,
                Ht._)`${A}.validate`), () => n.assign(N, (0,
                Ht._)`"string"`).assign(m, A)),
                e.fail$data((0,
                Ht.or)(g(), M()));
                function g() {
                    return f.strictSchema === !1 ? Ht.nil : (0,
                    Ht._)`${c} && !${m}`
                }
                function M() {
                    const G = h.$async ? (0,
                    Ht._)`(${A}.async ? await ${m}(${r}) : ${m}(${r}))` : (0,
                    Ht._)`${m}(${r})`
                      , U = (0,
                    Ht._)`(typeof ${m} == "function" ? ${G} : ${m}.test(${r}))`;
                    return (0,
                    Ht._)`${m} && ${m} !== true && ${N} === ${t} && !${U}`
                }
            }
            function $() {
                const O = y.formats[o];
                if (!O) {
                    g();
                    return
                }
                if (O === !0)
                    return;
                const [A,N,m] = M(O);
                A === t && e.pass(G());
                function g() {
                    if (f.strictSchema === !1) {
                        y.logger.warn(U());
                        return
                    }
                    throw new Error(U());
                    function U() {
                        return `unknown format "${o}" ignored in schema at path "${d}"`
                    }
                }
                function M(U) {
                    const D = U instanceof RegExp ? (0,
                    Ht.regexpCode)(U) : f.code.formats ? (0,
                    Ht._)`${f.code.formats}${(0,
                    Ht.getProperty)(o)}` : void 0
                      , K = n.scopeValue("formats", {
                        key: o,
                        ref: U,
                        code: D
                    });
                    return typeof U == "object" && !(U instanceof RegExp) ? [U.type || "string", U.validate, (0,
                    Ht._)`${K}.validate`] : ["string", U, K]
                }
                function G() {
                    if (typeof O == "object" && !(O instanceof RegExp) && O.async) {
                        if (!h.$async)
                            throw new Error("async format in sync schema");
                        return (0,
                        Ht._)`await ${m}(${r})`
                    }
                    return typeof N == "function" ? (0,
                    Ht._)`${m}(${r})` : (0,
                    Ht._)`${m}.test(${r})`
                }
            }
        }
    };
    u0.default = sB;
    Object.defineProperty(c0, "__esModule", {
        value: !0
    });
    const aB = u0
      , oB = [aB.default];
    c0.default = oB;
    var wo = {};
    Object.defineProperty(wo, "__esModule", {
        value: !0
    });
    wo.contentVocabulary = wo.metadataVocabulary = void 0;
    wo.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
    wo.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
    Object.defineProperty(Cg, "__esModule", {
        value: !0
    });
    const cB = Mg
      , uB = Dg
      , lB = Zg
      , fB = c0
      , xv = wo
      , dB = [cB.default, uB.default, (0,
    lB.default)(), fB.default, xv.metadataVocabulary, xv.contentVocabulary];
    Cg.default = dB;
    var l0 = {}
      , Md = {};
    Object.defineProperty(Md, "__esModule", {
        value: !0
    });
    Md.DiscrError = void 0;
    var $v;
    (function(e) {
        e.Tag = "tag",
        e.Mapping = "mapping"
    }
    )($v || (Md.DiscrError = $v = {}));
    Object.defineProperty(l0, "__esModule", {
        value: !0
    });
    const no = ot
      , ym = Md
      , Rv = Cn
      , hB = Ro
      , pB = Te
      , mB = {
        message: ({params: {discrError: e, tagName: t}}) => e === ym.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
        params: ({params: {discrError: e, tag: t, tagName: n}}) => (0,
        no._)`{error: ${e}, tag: ${n}, tagValue: ${t}}`
    }
      , gB = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error: mB,
        code(e) {
            const {gen: t, data: n, schema: r, parentSchema: s, it: o} = e
              , {oneOf: c} = s;
            if (!o.opts.discriminator)
                throw new Error("discriminator: requires discriminator option");
            const l = r.propertyName;
            if (typeof l != "string")
                throw new Error("discriminator: requires propertyName");
            if (r.mapping)
                throw new Error("discriminator: mapping is not supported");
            if (!c)
                throw new Error("discriminator: requires oneOf keyword");
            const f = t.let("valid", !1)
              , d = t.const("tag", (0,
            no._)`${n}${(0,
            no.getProperty)(l)}`);
            t.if((0,
            no._)`typeof ${d} == "string"`, () => h(), () => e.error(!1, {
                discrError: ym.DiscrError.Tag,
                tag: d,
                tagName: l
            })),
            e.ok(f);
            function h() {
                const $ = I();
                t.if(!1);
                for (const O in $)
                    t.elseIf((0,
                    no._)`${d} === ${O}`),
                    t.assign(f, y($[O]));
                t.else(),
                e.error(!1, {
                    discrError: ym.DiscrError.Mapping,
                    tag: d,
                    tagName: l
                }),
                t.endIf()
            }
            function y($) {
                const O = t.name("valid")
                  , A = e.subschema({
                    keyword: "oneOf",
                    schemaProp: $
                }, O);
                return e.mergeEvaluated(A, no.Name),
                O
            }
            function I() {
                var $;
                const O = {}
                  , A = m(s);
                let N = !0;
                for (let G = 0; G < c.length; G++) {
                    let U = c[G];
                    if (U?.$ref && !(0,
                    pB.schemaHasRulesButRef)(U, o.self.RULES)) {
                        const K = U.$ref;
                        if (U = Rv.resolveRef.call(o.self, o.schemaEnv.root, o.baseId, K),
                        U instanceof Rv.SchemaEnv && (U = U.schema),
                        U === void 0)
                            throw new hB.default(o.opts.uriResolver,o.baseId,K)
                    }
                    const D = ($ = U?.properties) === null || $ === void 0 ? void 0 : $[l];
                    if (typeof D != "object")
                        throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${l}"`);
                    N = N && (A || m(U)),
                    g(D, G)
                }
                if (!N)
                    throw new Error(`discriminator: "${l}" must be required`);
                return O;
                function m({required: G}) {
                    return Array.isArray(G) && G.includes(l)
                }
                function g(G, U) {
                    if (G.const)
                        M(G.const, U);
                    else if (G.enum)
                        for (const D of G.enum)
                            M(D, U);
                    else
                        throw new Error(`discriminator: "properties/${l}" must have "const" or "enum"`)
                }
                function M(G, U) {
                    if (typeof G != "string" || G in O)
                        throw new Error(`discriminator: "${l}" values must be unique strings`);
                    O[G] = U
                }
            }
        }
    };
    l0.default = gB;
    const yB = "http://json-schema.org/draft-07/schema#"
      , _B = "http://json-schema.org/draft-07/schema#"
      , vB = "Core schema meta-schema"
      , wB = {
        schemaArray: {
            type: "array",
            minItems: 1,
            items: {
                $ref: "#"
            }
        },
        nonNegativeInteger: {
            type: "integer",
            minimum: 0
        },
        nonNegativeIntegerDefault0: {
            allOf: [{
                $ref: "#/definitions/nonNegativeInteger"
            }, {
                default: 0
            }]
        },
        simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
            type: "array",
            items: {
                type: "string"
            },
            uniqueItems: !0,
            default: []
        }
    }
      , bB = ["object", "boolean"]
      , EB = {
        $id: {
            type: "string",
            format: "uri-reference"
        },
        $schema: {
            type: "string",
            format: "uri"
        },
        $ref: {
            type: "string",
            format: "uri-reference"
        },
        $comment: {
            type: "string"
        },
        title: {
            type: "string"
        },
        description: {
            type: "string"
        },
        default: !0,
        readOnly: {
            type: "boolean",
            default: !1
        },
        examples: {
            type: "array",
            items: !0
        },
        multipleOf: {
            type: "number",
            exclusiveMinimum: 0
        },
        maximum: {
            type: "number"
        },
        exclusiveMaximum: {
            type: "number"
        },
        minimum: {
            type: "number"
        },
        exclusiveMinimum: {
            type: "number"
        },
        maxLength: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minLength: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        pattern: {
            type: "string",
            format: "regex"
        },
        additionalItems: {
            $ref: "#"
        },
        items: {
            anyOf: [{
                $ref: "#"
            }, {
                $ref: "#/definitions/schemaArray"
            }],
            default: !0
        },
        maxItems: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minItems: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        uniqueItems: {
            type: "boolean",
            default: !1
        },
        contains: {
            $ref: "#"
        },
        maxProperties: {
            $ref: "#/definitions/nonNegativeInteger"
        },
        minProperties: {
            $ref: "#/definitions/nonNegativeIntegerDefault0"
        },
        required: {
            $ref: "#/definitions/stringArray"
        },
        additionalProperties: {
            $ref: "#"
        },
        definitions: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        properties: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            default: {}
        },
        patternProperties: {
            type: "object",
            additionalProperties: {
                $ref: "#"
            },
            propertyNames: {
                format: "regex"
            },
            default: {}
        },
        dependencies: {
            type: "object",
            additionalProperties: {
                anyOf: [{
                    $ref: "#"
                }, {
                    $ref: "#/definitions/stringArray"
                }]
            }
        },
        propertyNames: {
            $ref: "#"
        },
        const: !0,
        enum: {
            type: "array",
            items: !0,
            minItems: 1,
            uniqueItems: !0
        },
        type: {
            anyOf: [{
                $ref: "#/definitions/simpleTypes"
            }, {
                type: "array",
                items: {
                    $ref: "#/definitions/simpleTypes"
                },
                minItems: 1,
                uniqueItems: !0
            }]
        },
        format: {
            type: "string"
        },
        contentMediaType: {
            type: "string"
        },
        contentEncoding: {
            type: "string"
        },
        if: {
            $ref: "#"
        },
        then: {
            $ref: "#"
        },
        else: {
            $ref: "#"
        },
        allOf: {
            $ref: "#/definitions/schemaArray"
        },
        anyOf: {
            $ref: "#/definitions/schemaArray"
        },
        oneOf: {
            $ref: "#/definitions/schemaArray"
        },
        not: {
            $ref: "#"
        }
    }
      , SB = {
        $schema: yB,
        $id: _B,
        title: vB,
        definitions: wB,
        type: bB,
        properties: EB,
        default: !0
    };
    (function(e, t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        }),
        t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
        const n = ub
          , r = Cg
          , s = l0
          , o = SB
          , c = ["/properties"]
          , l = "http://json-schema.org/draft-07/schema";
        class f extends n.default {
            _addVocabularies() {
                super._addVocabularies(),
                r.default.forEach(O => this.addVocabulary(O)),
                this.opts.discriminator && this.addKeyword(s.default)
            }
            _addDefaultMetaSchema() {
                if (super._addDefaultMetaSchema(),
                !this.opts.meta)
                    return;
                const O = this.opts.$data ? this.$dataMetaSchema(o, c) : o;
                this.addMetaSchema(O, l, !1),
                this.refs["http://json-schema.org/schema"] = l
            }
            defaultMeta() {
                return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(l) ? l : void 0)
            }
        }
        t.Ajv = f,
        e.exports = t = f,
        e.exports.Ajv = f,
        Object.defineProperty(t, "__esModule", {
            value: !0
        }),
        t.default = f;
        var d = kr;
        Object.defineProperty(t, "KeywordCxt", {
            enumerable: !0,
            get: function() {
                return d.KeywordCxt
            }
        });
        var h = ot;
        Object.defineProperty(t, "_", {
            enumerable: !0,
            get: function() {
                return h._
            }
        }),
        Object.defineProperty(t, "str", {
            enumerable: !0,
            get: function() {
                return h.str
            }
        }),
        Object.defineProperty(t, "stringify", {
            enumerable: !0,
            get: function() {
                return h.stringify
            }
        }),
        Object.defineProperty(t, "nil", {
            enumerable: !0,
            get: function() {
                return h.nil
            }
        }),
        Object.defineProperty(t, "Name", {
            enumerable: !0,
            get: function() {
                return h.Name
            }
        }),
        Object.defineProperty(t, "CodeGen", {
            enumerable: !0,
            get: function() {
                return h.CodeGen
            }
        });
        var y = Fu;
        Object.defineProperty(t, "ValidationError", {
            enumerable: !0,
            get: function() {
                return y.default
            }
        });
        var I = Ro;
        Object.defineProperty(t, "MissingRefError", {
            enumerable: !0,
            get: function() {
                return I.default
            }
        })
    }
    )(av, av.exports);
    var Df = {
        exports: {}
    };
    /**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
    Df.exports;
    (function(e, t) {
        (function() {
            var n, r = "4.17.21", s = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", c = "Expected a function", l = "Invalid `variable` option passed into `_.template`", f = "__lodash_hash_undefined__", d = 500, h = "__lodash_placeholder__", y = 1, I = 2, $ = 4, O = 1, A = 2, N = 1, m = 2, g = 4, M = 8, G = 16, U = 32, D = 64, K = 128, _ = 256, T = 512, S = 30, q = "...", C = 800, F = 16, X = 1, v = 2, x = 3, Y = 1 / 0, W = 9007199254740991, te = 17976931348623157e292, J = NaN, H = 4294967295, ae = H - 1, Q = H >>> 1, P = [["ary", K], ["bind", N], ["bindKey", m], ["curry", M], ["curryRight", G], ["flip", T], ["partial", U], ["partialRight", D], ["rearg", _]], j = "[object Arguments]", se = "[object Array]", ye = "[object AsyncFunction]", we = "[object Boolean]", De = "[object Date]", Re = "[object DOMException]", tt = "[object Error]", vt = "[object Function]", bt = "[object GeneratorFunction]", st = "[object Map]", ct = "[object Number]", Br = "[object Null]", yn = "[object Object]", Gi = "[object Promise]", Ns = "[object Proxy]", yr = "[object RegExp]", an = "[object Set]", Wn = "[object String]", Fr = "[object Symbol]", pa = "[object Undefined]", oe = "[object WeakMap]", Be = "[object WeakSet]", zn = "[object ArrayBuffer]", Gn = "[object DataView]", Zi = "[object Float32Array]", ui = "[object Float64Array]", ma = "[object Int8Array]", ga = "[object Int16Array]", Mo = "[object Int32Array]", Lo = "[object Uint8Array]", Ki = "[object Uint8ClampedArray]", ya = "[object Uint16Array]", xs = "[object Uint32Array]", Wu = /\b__p \+= '';/g, qd = /\b(__p \+=) '' \+/g, zu = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Gu = /&(?:amp|lt|gt|quot|#39);/g, Do = /[&<>"']/g, Zu = RegExp(Gu.source), Hd = RegExp(Do.source), Yd = /<%-([\s\S]+?)%>/g, Vd = /<%([\s\S]+?)%>/g, Ku = /<%=([\s\S]+?)%>/g, Uo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Bo = /^\w*$/, Wd = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Fo = /[\\^$.*+?()[\]{}|]/g, zd = RegExp(Fo.source), jo = /^\s+/, Xt = /\s/, Gd = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Zd = /\{\n\/\* \[wrapped with (.+)\] \*/, Kd = /,? & /, Ju = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Jd = /[()=,{}\[\]\/\s]/, qo = /\\(\\)?/g, Ho = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Xu = /\w*$/, Xd = /^[-+]0x[0-9a-f]+$/i, Qu = /^0b[01]+$/i, $s = /^\[object .+?Constructor\]$/, _a = /^0o[0-7]+$/i, Qd = /^(?:0|[1-9]\d*)$/, eh = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ji = /($^)/, th = /['\n\r\u2028\u2029\\]/g, va = "\\ud800-\\udfff", wa = "\\u0300-\\u036f", Dn = "\\ufe20-\\ufe2f", Yo = "\\u20d0-\\u20ff", Vo = wa + Dn + Yo, li = "\\u2700-\\u27bf", Wo = "a-z\\xdf-\\xf6\\xf8-\\xff", nh = "\\xac\\xb1\\xd7\\xf7", rh = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ih = "\\u2000-\\u206f", ba = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", zo = "A-Z\\xc0-\\xd6\\xd8-\\xde", Go = "\\ufe0e\\ufe0f", el = nh + rh + ih + ba, Zo = "[']", sh = "[" + va + "]", tl = "[" + el + "]", Rs = "[" + Vo + "]", Ko = "\\d+", fi = "[" + li + "]", Jo = "[" + Wo + "]", ah = "[^" + va + el + Ko + li + Wo + zo + "]", Xo = "\\ud83c[\\udffb-\\udfff]", M0 = "(?:" + Rs + "|" + Xo + ")", nl = "[^" + va + "]", Qo = "(?:\\ud83c[\\udde6-\\uddff]){2}", ec = "[\\ud800-\\udbff][\\udc00-\\udfff]", Xi = "[" + zo + "]", tc = "\\u200d", Ps = "(?:" + Jo + "|" + ah + ")", rl = "(?:" + Xi + "|" + ah + ")", il = "(?:" + Zo + "(?:d|ll|m|re|s|t|ve))?", nc = "(?:" + Zo + "(?:D|LL|M|RE|S|T|VE))?", sl = M0 + "?", rc = "[" + Go + "]?", ic = "(?:" + tc + "(?:" + [nl, Qo, ec].join("|") + ")" + rc + sl + ")*", Ea = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", oh = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", al = rc + sl + ic, ch = "(?:" + [fi, Qo, ec].join("|") + ")" + al, sc = "(?:" + [nl + Rs + "?", Rs, Qo, ec, sh].join("|") + ")", ol = RegExp(Zo, "g"), uh = RegExp(Rs, "g"), Sa = RegExp(Xo + "(?=" + Xo + ")|" + sc + al, "g"), ac = RegExp([Xi + "?" + Jo + "+" + il + "(?=" + [tl, Xi, "$"].join("|") + ")", rl + "+" + nc + "(?=" + [tl, Xi + Ps, "$"].join("|") + ")", Xi + "?" + Ps + "+" + il, Xi + "+" + nc, oh, Ea, Ko, ch].join("|"), "g"), cl = RegExp("[" + tc + va + Vo + Go + "]"), ul = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ta = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], ll = -1, It = {};
            It[Zi] = It[ui] = It[ma] = It[ga] = It[Mo] = It[Lo] = It[Ki] = It[ya] = It[xs] = !0,
            It[j] = It[se] = It[zn] = It[we] = It[Gn] = It[De] = It[tt] = It[vt] = It[st] = It[ct] = It[yn] = It[yr] = It[an] = It[Wn] = It[oe] = !1;
            var yt = {};
            yt[j] = yt[se] = yt[zn] = yt[Gn] = yt[we] = yt[De] = yt[Zi] = yt[ui] = yt[ma] = yt[ga] = yt[Mo] = yt[st] = yt[ct] = yt[yn] = yt[yr] = yt[an] = yt[Wn] = yt[Fr] = yt[Lo] = yt[Ki] = yt[ya] = yt[xs] = !0,
            yt[tt] = yt[vt] = yt[oe] = !1;
            var Zn = {
                : "A",
                : "A",
                : "A",
                : "A",
                : "A",
                : "A",
                : "a",
                : "a",
                : "a",
                : "a",
                : "a",
                : "a",
                : "C",
                : "c",
                : "D",
                : "d",
                : "E",
                : "E",
                : "E",
                : "E",
                : "e",
                : "e",
                : "e",
                : "e",
                : "I",
                : "I",
                : "I",
                : "I",
                : "i",
                : "i",
                : "i",
                : "i",
                : "N",
                : "n",
                : "O",
                : "O",
                : "O",
                : "O",
                : "O",
                : "O",
                : "o",
                : "o",
                : "o",
                : "o",
                : "o",
                : "o",
                : "U",
                : "U",
                : "U",
                : "U",
                : "u",
                : "u",
                : "u",
                : "u",
                : "Y",
                : "y",
                : "y",
                : "Ae",
                : "ae",
                : "Th",
                : "th",
                : "ss",
                : "A",
                : "A",
                : "A",
                : "a",
                : "a",
                : "a",
                : "C",
                : "C",
                : "C",
                : "C",
                : "c",
                : "c",
                : "c",
                : "c",
                : "D",
                : "D",
                : "d",
                : "d",
                : "E",
                : "E",
                : "E",
                : "E",
                : "E",
                : "e",
                : "e",
                : "e",
                : "e",
                : "e",
                : "G",
                : "G",
                : "G",
                : "G",
                : "g",
                : "g",
                : "g",
                : "g",
                : "H",
                : "H",
                : "h",
                : "h",
                : "I",
                : "I",
                : "I",
                : "I",
                : "I",
                : "i",
                : "i",
                : "i",
                : "i",
                : "i",
                : "J",
                : "j",
                : "K",
                : "k",
                : "k",
                : "L",
                : "L",
                : "L",
                : "L",
                : "L",
                : "l",
                : "l",
                : "l",
                : "l",
                : "l",
                : "N",
                : "N",
                : "N",
                : "N",
                : "n",
                : "n",
                : "n",
                : "n",
                : "O",
                : "O",
                : "O",
                : "o",
                : "o",
                : "o",
                : "R",
                : "R",
                : "R",
                : "r",
                : "r",
                : "r",
                : "S",
                : "S",
                : "S",
                : "S",
                : "s",
                : "s",
                : "s",
                : "s",
                : "T",
                : "T",
                : "T",
                : "t",
                : "t",
                : "t",
                : "U",
                : "U",
                : "U",
                : "U",
                : "U",
                : "U",
                : "u",
                : "u",
                : "u",
                : "u",
                : "u",
                : "u",
                : "W",
                : "w",
                : "Y",
                : "y",
                : "Y",
                : "Z",
                : "Z",
                : "Z",
                : "z",
                : "z",
                : "z",
                : "IJ",
                : "ij",
                : "Oe",
                : "oe",
                : "'n",
                : "s"
            }
              , Aa = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            }
              , Oa = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            }
              , oc = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            }
              , lh = parseFloat
              , fh = parseInt
              , fl = typeof Hn == "object" && Hn && Hn.Object === Object && Hn
              , cc = typeof self == "object" && self && self.Object === Object && self
              , zt = fl || cc || Function("return this")()
              , Ia = t && !t.nodeType && t
              , Tt = Ia && !0 && e && !e.nodeType && e
              , w = Tt && Tt.exports === Ia
              , E = w && fl.process
              , L = function() {
                try {
                    var ee = Tt && Tt.require && Tt.require("util").types;
                    return ee || E && E.binding && E.binding("util")
                } catch {}
            }()
              , B = L && L.isArrayBuffer
              , z = L && L.isDate
              , re = L && L.isMap
              , ie = L && L.isRegExp
              , de = L && L.isSet
              , $e = L && L.isTypedArray;
            function pe(ee, ue, ce) {
                switch (ce.length) {
                case 0:
                    return ee.call(ue);
                case 1:
                    return ee.call(ue, ce[0]);
                case 2:
                    return ee.call(ue, ce[0], ce[1]);
                case 3:
                    return ee.call(ue, ce[0], ce[1], ce[2])
                }
                return ee.apply(ue, ce)
            }
            function _e(ee, ue, ce, Ie) {
                for (var Ge = -1, _t = ee == null ? 0 : ee.length; ++Ge < _t; ) {
                    var Gt = ee[Ge];
                    ue(Ie, Gt, ce(Gt), ee)
                }
                return Ie
            }
            function Oe(ee, ue) {
                for (var ce = -1, Ie = ee == null ? 0 : ee.length; ++ce < Ie && ue(ee[ce], ce, ee) !== !1; )
                    ;
                return ee
            }
            function Et(ee, ue) {
                for (var ce = ee == null ? 0 : ee.length; ce-- && ue(ee[ce], ce, ee) !== !1; )
                    ;
                return ee
            }
            function Dt(ee, ue) {
                for (var ce = -1, Ie = ee == null ? 0 : ee.length; ++ce < Ie; )
                    if (!ue(ee[ce], ce, ee))
                        return !1;
                return !0
            }
            function xe(ee, ue) {
                for (var ce = -1, Ie = ee == null ? 0 : ee.length, Ge = 0, _t = []; ++ce < Ie; ) {
                    var Gt = ee[ce];
                    ue(Gt, ce, ee) && (_t[Ge++] = Gt)
                }
                return _t
            }
            function We(ee, ue) {
                var ce = ee == null ? 0 : ee.length;
                return !!ce && xa(ee, ue, 0) > -1
            }
            function Ce(ee, ue, ce) {
                for (var Ie = -1, Ge = ee == null ? 0 : ee.length; ++Ie < Ge; )
                    if (ce(ue, ee[Ie]))
                        return !0;
                return !1
            }
            function Ye(ee, ue) {
                for (var ce = -1, Ie = ee == null ? 0 : ee.length, Ge = Array(Ie); ++ce < Ie; )
                    Ge[ce] = ue(ee[ce], ce, ee);
                return Ge
            }
            function At(ee, ue) {
                for (var ce = -1, Ie = ue.length, Ge = ee.length; ++ce < Ie; )
                    ee[Ge + ce] = ue[ce];
                return ee
            }
            function Ut(ee, ue, ce, Ie) {
                var Ge = -1
                  , _t = ee == null ? 0 : ee.length;
                for (Ie && _t && (ce = ee[++Ge]); ++Ge < _t; )
                    ce = ue(ce, ee[Ge], Ge, ee);
                return ce
            }
            function _r(ee, ue, ce, Ie) {
                var Ge = ee == null ? 0 : ee.length;
                for (Ie && Ge && (ce = ee[--Ge]); Ge--; )
                    ce = ue(ce, ee[Ge], Ge, ee);
                return ce
            }
            function Qt(ee, ue) {
                for (var ce = -1, Ie = ee == null ? 0 : ee.length; ++ce < Ie; )
                    if (ue(ee[ce], ce, ee))
                        return !0;
                return !1
            }
            var jr = dh("length");
            function di(ee) {
                return ee.split("")
            }
            function Na(ee) {
                return ee.match(Ju) || []
            }
            function uc(ee, ue, ce) {
                var Ie;
                return ce(ee, function(Ge, _t, Gt) {
                    if (ue(Ge, _t, Gt))
                        return Ie = _t,
                        !1
                }),
                Ie
            }
            function dl(ee, ue, ce, Ie) {
                for (var Ge = ee.length, _t = ce + (Ie ? 1 : -1); Ie ? _t-- : ++_t < Ge; )
                    if (ue(ee[_t], _t, ee))
                        return _t;
                return -1
            }
            function xa(ee, ue, ce) {
                return ue === ue ? gS(ee, ue, ce) : dl(ee, L0, ce)
            }
            function sS(ee, ue, ce, Ie) {
                for (var Ge = ce - 1, _t = ee.length; ++Ge < _t; )
                    if (Ie(ee[Ge], ue))
                        return Ge;
                return -1
            }
            function L0(ee) {
                return ee !== ee
            }
            function D0(ee, ue) {
                var ce = ee == null ? 0 : ee.length;
                return ce ? ph(ee, ue) / ce : J
            }
            function dh(ee) {
                return function(ue) {
                    return ue == null ? n : ue[ee]
                }
            }
            function hh(ee) {
                return function(ue) {
                    return ee == null ? n : ee[ue]
                }
            }
            function U0(ee, ue, ce, Ie, Ge) {
                return Ge(ee, function(_t, Gt, Nt) {
                    ce = Ie ? (Ie = !1,
                    _t) : ue(ce, _t, Gt, Nt)
                }),
                ce
            }
            function aS(ee, ue) {
                var ce = ee.length;
                for (ee.sort(ue); ce--; )
                    ee[ce] = ee[ce].value;
                return ee
            }
            function ph(ee, ue) {
                for (var ce, Ie = -1, Ge = ee.length; ++Ie < Ge; ) {
                    var _t = ue(ee[Ie]);
                    _t !== n && (ce = ce === n ? _t : ce + _t)
                }
                return ce
            }
            function mh(ee, ue) {
                for (var ce = -1, Ie = Array(ee); ++ce < ee; )
                    Ie[ce] = ue(ce);
                return Ie
            }
            function oS(ee, ue) {
                return Ye(ue, function(ce) {
                    return [ce, ee[ce]]
                })
            }
            function B0(ee) {
                return ee && ee.slice(0, H0(ee) + 1).replace(jo, "")
            }
            function Un(ee) {
                return function(ue) {
                    return ee(ue)
                }
            }
            function gh(ee, ue) {
                return Ye(ue, function(ce) {
                    return ee[ce]
                })
            }
            function lc(ee, ue) {
                return ee.has(ue)
            }
            function F0(ee, ue) {
                for (var ce = -1, Ie = ee.length; ++ce < Ie && xa(ue, ee[ce], 0) > -1; )
                    ;
                return ce
            }
            function j0(ee, ue) {
                for (var ce = ee.length; ce-- && xa(ue, ee[ce], 0) > -1; )
                    ;
                return ce
            }
            function cS(ee, ue) {
                for (var ce = ee.length, Ie = 0; ce--; )
                    ee[ce] === ue && ++Ie;
                return Ie
            }
            var uS = hh(Zn)
              , lS = hh(Aa);
            function fS(ee) {
                return "\\" + oc[ee]
            }
            function dS(ee, ue) {
                return ee == null ? n : ee[ue]
            }
            function $a(ee) {
                return cl.test(ee)
            }
            function hS(ee) {
                return ul.test(ee)
            }
            function pS(ee) {
                for (var ue, ce = []; !(ue = ee.next()).done; )
                    ce.push(ue.value);
                return ce
            }
            function yh(ee) {
                var ue = -1
                  , ce = Array(ee.size);
                return ee.forEach(function(Ie, Ge) {
                    ce[++ue] = [Ge, Ie]
                }),
                ce
            }
            function q0(ee, ue) {
                return function(ce) {
                    return ee(ue(ce))
                }
            }
            function Qi(ee, ue) {
                for (var ce = -1, Ie = ee.length, Ge = 0, _t = []; ++ce < Ie; ) {
                    var Gt = ee[ce];
                    (Gt === ue || Gt === h) && (ee[ce] = h,
                    _t[Ge++] = ce)
                }
                return _t
            }
            function hl(ee) {
                var ue = -1
                  , ce = Array(ee.size);
                return ee.forEach(function(Ie) {
                    ce[++ue] = Ie
                }),
                ce
            }
            function mS(ee) {
                var ue = -1
                  , ce = Array(ee.size);
                return ee.forEach(function(Ie) {
                    ce[++ue] = [Ie, Ie]
                }),
                ce
            }
            function gS(ee, ue, ce) {
                for (var Ie = ce - 1, Ge = ee.length; ++Ie < Ge; )
                    if (ee[Ie] === ue)
                        return Ie;
                return -1
            }
            function yS(ee, ue, ce) {
                for (var Ie = ce + 1; Ie--; )
                    if (ee[Ie] === ue)
                        return Ie;
                return Ie
            }
            function Ra(ee) {
                return $a(ee) ? vS(ee) : jr(ee)
            }
            function vr(ee) {
                return $a(ee) ? wS(ee) : di(ee)
            }
            function H0(ee) {
                for (var ue = ee.length; ue-- && Xt.test(ee.charAt(ue)); )
                    ;
                return ue
            }
            var _S = hh(Oa);
            function vS(ee) {
                for (var ue = Sa.lastIndex = 0; Sa.test(ee); )
                    ++ue;
                return ue
            }
            function wS(ee) {
                return ee.match(Sa) || []
            }
            function bS(ee) {
                return ee.match(ac) || []
            }
            var ES = function ee(ue) {
                ue = ue == null ? zt : Pa.defaults(zt.Object(), ue, Pa.pick(zt, Ta));
                var ce = ue.Array
                  , Ie = ue.Date
                  , Ge = ue.Error
                  , _t = ue.Function
                  , Gt = ue.Math
                  , Nt = ue.Object
                  , _h = ue.RegExp
                  , SS = ue.String
                  , Kn = ue.TypeError
                  , pl = ce.prototype
                  , TS = _t.prototype
                  , ka = Nt.prototype
                  , ml = ue["__core-js_shared__"]
                  , gl = TS.toString
                  , St = ka.hasOwnProperty
                  , AS = 0
                  , Y0 = function() {
                    var i = /[^.]+$/.exec(ml && ml.keys && ml.keys.IE_PROTO || "");
                    return i ? "Symbol(src)_1." + i : ""
                }()
                  , yl = ka.toString
                  , OS = gl.call(Nt)
                  , IS = zt._
                  , NS = _h("^" + gl.call(St).replace(Fo, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
                  , _l = w ? ue.Buffer : n
                  , es = ue.Symbol
                  , vl = ue.Uint8Array
                  , V0 = _l ? _l.allocUnsafe : n
                  , wl = q0(Nt.getPrototypeOf, Nt)
                  , W0 = Nt.create
                  , z0 = ka.propertyIsEnumerable
                  , bl = pl.splice
                  , G0 = es ? es.isConcatSpreadable : n
                  , fc = es ? es.iterator : n
                  , ks = es ? es.toStringTag : n
                  , El = function() {
                    try {
                        var i = Us(Nt, "defineProperty");
                        return i({}, "", {}),
                        i
                    } catch {}
                }()
                  , xS = ue.clearTimeout !== zt.clearTimeout && ue.clearTimeout
                  , $S = Ie && Ie.now !== zt.Date.now && Ie.now
                  , RS = ue.setTimeout !== zt.setTimeout && ue.setTimeout
                  , Sl = Gt.ceil
                  , Tl = Gt.floor
                  , vh = Nt.getOwnPropertySymbols
                  , PS = _l ? _l.isBuffer : n
                  , Z0 = ue.isFinite
                  , kS = pl.join
                  , CS = q0(Nt.keys, Nt)
                  , Zt = Gt.max
                  , fn = Gt.min
                  , MS = Ie.now
                  , LS = ue.parseInt
                  , K0 = Gt.random
                  , DS = pl.reverse
                  , wh = Us(ue, "DataView")
                  , dc = Us(ue, "Map")
                  , bh = Us(ue, "Promise")
                  , Ca = Us(ue, "Set")
                  , hc = Us(ue, "WeakMap")
                  , pc = Us(Nt, "create")
                  , Al = hc && new hc
                  , Ma = {}
                  , US = Bs(wh)
                  , BS = Bs(dc)
                  , FS = Bs(bh)
                  , jS = Bs(Ca)
                  , qS = Bs(hc)
                  , Ol = es ? es.prototype : n
                  , mc = Ol ? Ol.valueOf : n
                  , J0 = Ol ? Ol.toString : n;
                function R(i) {
                    if (Bt(i) && !Ze(i) && !(i instanceof lt)) {
                        if (i instanceof Jn)
                            return i;
                        if (St.call(i, "__wrapped__"))
                            return Xy(i)
                    }
                    return new Jn(i)
                }
                var La = function() {
                    function i() {}
                    return function(a) {
                        if (!Ct(a))
                            return {};
                        if (W0)
                            return W0(a);
                        i.prototype = a;
                        var u = new i;
                        return i.prototype = n,
                        u
                    }
                }();
                function Il() {}
                function Jn(i, a) {
                    this.__wrapped__ = i,
                    this.__actions__ = [],
                    this.__chain__ = !!a,
                    this.__index__ = 0,
                    this.__values__ = n
                }
                R.templateSettings = {
                    escape: Yd,
                    evaluate: Vd,
                    interpolate: Ku,
                    variable: "",
                    imports: {
                        _: R
                    }
                },
                R.prototype = Il.prototype,
                R.prototype.constructor = R,
                Jn.prototype = La(Il.prototype),
                Jn.prototype.constructor = Jn;
                function lt(i) {
                    this.__wrapped__ = i,
                    this.__actions__ = [],
                    this.__dir__ = 1,
                    this.__filtered__ = !1,
                    this.__iteratees__ = [],
                    this.__takeCount__ = H,
                    this.__views__ = []
                }
                function HS() {
                    var i = new lt(this.__wrapped__);
                    return i.__actions__ = An(this.__actions__),
                    i.__dir__ = this.__dir__,
                    i.__filtered__ = this.__filtered__,
                    i.__iteratees__ = An(this.__iteratees__),
                    i.__takeCount__ = this.__takeCount__,
                    i.__views__ = An(this.__views__),
                    i
                }
                function YS() {
                    if (this.__filtered__) {
                        var i = new lt(this);
                        i.__dir__ = -1,
                        i.__filtered__ = !0
                    } else
                        i = this.clone(),
                        i.__dir__ *= -1;
                    return i
                }
                function VS() {
                    var i = this.__wrapped__.value()
                      , a = this.__dir__
                      , u = Ze(i)
                      , p = a < 0
                      , b = u ? i.length : 0
                      , k = rA(0, b, this.__views__)
                      , V = k.start
                      , Z = k.end
                      , ne = Z - V
                      , le = p ? Z : V - 1
                      , fe = this.__iteratees__
                      , he = fe.length
                      , ve = 0
                      , Pe = fn(ne, this.__takeCount__);
                    if (!u || !p && b == ne && Pe == ne)
                        return by(i, this.__actions__);
                    var Fe = [];
                    e: for (; ne-- && ve < Pe; ) {
                        le += a;
                        for (var nt = -1, je = i[le]; ++nt < he; ) {
                            var ut = fe[nt]
                              , dt = ut.iteratee
                              , jn = ut.type
                              , wn = dt(je);
                            if (jn == v)
                                je = wn;
                            else if (!wn) {
                                if (jn == X)
                                    continue e;
                                break e
                            }
                        }
                        Fe[ve++] = je
                    }
                    return Fe
                }
                lt.prototype = La(Il.prototype),
                lt.prototype.constructor = lt;
                function Cs(i) {
                    var a = -1
                      , u = i == null ? 0 : i.length;
                    for (this.clear(); ++a < u; ) {
                        var p = i[a];
                        this.set(p[0], p[1])
                    }
                }
                function WS() {
                    this.__data__ = pc ? pc(null) : {},
                    this.size = 0
                }
                function zS(i) {
                    var a = this.has(i) && delete this.__data__[i];
                    return this.size -= a ? 1 : 0,
                    a
                }
                function GS(i) {
                    var a = this.__data__;
                    if (pc) {
                        var u = a[i];
                        return u === f ? n : u
                    }
                    return St.call(a, i) ? a[i] : n
                }
                function ZS(i) {
                    var a = this.__data__;
                    return pc ? a[i] !== n : St.call(a, i)
                }
                function KS(i, a) {
                    var u = this.__data__;
                    return this.size += this.has(i) ? 0 : 1,
                    u[i] = pc && a === n ? f : a,
                    this
                }
                Cs.prototype.clear = WS,
                Cs.prototype.delete = zS,
                Cs.prototype.get = GS,
                Cs.prototype.has = ZS,
                Cs.prototype.set = KS;
                function hi(i) {
                    var a = -1
                      , u = i == null ? 0 : i.length;
                    for (this.clear(); ++a < u; ) {
                        var p = i[a];
                        this.set(p[0], p[1])
                    }
                }
                function JS() {
                    this.__data__ = [],
                    this.size = 0
                }
                function XS(i) {
                    var a = this.__data__
                      , u = Nl(a, i);
                    if (u < 0)
                        return !1;
                    var p = a.length - 1;
                    return u == p ? a.pop() : bl.call(a, u, 1),
                    --this.size,
                    !0
                }
                function QS(i) {
                    var a = this.__data__
                      , u = Nl(a, i);
                    return u < 0 ? n : a[u][1]
                }
                function eT(i) {
                    return Nl(this.__data__, i) > -1
                }
                function tT(i, a) {
                    var u = this.__data__
                      , p = Nl(u, i);
                    return p < 0 ? (++this.size,
                    u.push([i, a])) : u[p][1] = a,
                    this
                }
                hi.prototype.clear = JS,
                hi.prototype.delete = XS,
                hi.prototype.get = QS,
                hi.prototype.has = eT,
                hi.prototype.set = tT;
                function pi(i) {
                    var a = -1
                      , u = i == null ? 0 : i.length;
                    for (this.clear(); ++a < u; ) {
                        var p = i[a];
                        this.set(p[0], p[1])
                    }
                }
                function nT() {
                    this.size = 0,
                    this.__data__ = {
                        hash: new Cs,
                        map: new (dc || hi),
                        string: new Cs
                    }
                }
                function rT(i) {
                    var a = Fl(this, i).delete(i);
                    return this.size -= a ? 1 : 0,
                    a
                }
                function iT(i) {
                    return Fl(this, i).get(i)
                }
                function sT(i) {
                    return Fl(this, i).has(i)
                }
                function aT(i, a) {
                    var u = Fl(this, i)
                      , p = u.size;
                    return u.set(i, a),
                    this.size += u.size == p ? 0 : 1,
                    this
                }
                pi.prototype.clear = nT,
                pi.prototype.delete = rT,
                pi.prototype.get = iT,
                pi.prototype.has = sT,
                pi.prototype.set = aT;
                function Ms(i) {
                    var a = -1
                      , u = i == null ? 0 : i.length;
                    for (this.__data__ = new pi; ++a < u; )
                        this.add(i[a])
                }
                function oT(i) {
                    return this.__data__.set(i, f),
                    this
                }
                function cT(i) {
                    return this.__data__.has(i)
                }
                Ms.prototype.add = Ms.prototype.push = oT,
                Ms.prototype.has = cT;
                function wr(i) {
                    var a = this.__data__ = new hi(i);
                    this.size = a.size
                }
                function uT() {
                    this.__data__ = new hi,
                    this.size = 0
                }
                function lT(i) {
                    var a = this.__data__
                      , u = a.delete(i);
                    return this.size = a.size,
                    u
                }
                function fT(i) {
                    return this.__data__.get(i)
                }
                function dT(i) {
                    return this.__data__.has(i)
                }
                function hT(i, a) {
                    var u = this.__data__;
                    if (u instanceof hi) {
                        var p = u.__data__;
                        if (!dc || p.length < s - 1)
                            return p.push([i, a]),
                            this.size = ++u.size,
                            this;
                        u = this.__data__ = new pi(p)
                    }
                    return u.set(i, a),
                    this.size = u.size,
                    this
                }
                wr.prototype.clear = uT,
                wr.prototype.delete = lT,
                wr.prototype.get = fT,
                wr.prototype.has = dT,
                wr.prototype.set = hT;
                function X0(i, a) {
                    var u = Ze(i)
                      , p = !u && Fs(i)
                      , b = !u && !p && ss(i)
                      , k = !u && !p && !b && Fa(i)
                      , V = u || p || b || k
                      , Z = V ? mh(i.length, SS) : []
                      , ne = Z.length;
                    for (var le in i)
                        (a || St.call(i, le)) && !(V && (le == "length" || b && (le == "offset" || le == "parent") || k && (le == "buffer" || le == "byteLength" || le == "byteOffset") || _i(le, ne))) && Z.push(le);
                    return Z
                }
                function Q0(i) {
                    var a = i.length;
                    return a ? i[Ph(0, a - 1)] : n
                }
                function pT(i, a) {
                    return jl(An(i), Ls(a, 0, i.length))
                }
                function mT(i) {
                    return jl(An(i))
                }
                function Eh(i, a, u) {
                    (u !== n && !br(i[a], u) || u === n && !(a in i)) && mi(i, a, u)
                }
                function gc(i, a, u) {
                    var p = i[a];
                    (!(St.call(i, a) && br(p, u)) || u === n && !(a in i)) && mi(i, a, u)
                }
                function Nl(i, a) {
                    for (var u = i.length; u--; )
                        if (br(i[u][0], a))
                            return u;
                    return -1
                }
                function gT(i, a, u, p) {
                    return ts(i, function(b, k, V) {
                        a(p, b, u(b), V)
                    }),
                    p
                }
                function ey(i, a) {
                    return i && Hr(a, en(a), i)
                }
                function yT(i, a) {
                    return i && Hr(a, In(a), i)
                }
                function mi(i, a, u) {
                    a == "__proto__" && El ? El(i, a, {
                        configurable: !0,
                        enumerable: !0,
                        value: u,
                        writable: !0
                    }) : i[a] = u
                }
                function Sh(i, a) {
                    for (var u = -1, p = a.length, b = ce(p), k = i == null; ++u < p; )
                        b[u] = k ? n : rp(i, a[u]);
                    return b
                }
                function Ls(i, a, u) {
                    return i === i && (u !== n && (i = i <= u ? i : u),
                    a !== n && (i = i >= a ? i : a)),
                    i
                }
                function Xn(i, a, u, p, b, k) {
                    var V, Z = a & y, ne = a & I, le = a & $;
                    if (u && (V = b ? u(i, p, b, k) : u(i)),
                    V !== n)
                        return V;
                    if (!Ct(i))
                        return i;
                    var fe = Ze(i);
                    if (fe) {
                        if (V = sA(i),
                        !Z)
                            return An(i, V)
                    } else {
                        var he = dn(i)
                          , ve = he == vt || he == bt;
                        if (ss(i))
                            return Ty(i, Z);
                        if (he == yn || he == j || ve && !b) {
                            if (V = ne || ve ? {} : Hy(i),
                            !Z)
                                return ne ? GT(i, yT(V, i)) : zT(i, ey(V, i))
                        } else {
                            if (!yt[he])
                                return b ? i : {};
                            V = aA(i, he, Z)
                        }
                    }
                    k || (k = new wr);
                    var Pe = k.get(i);
                    if (Pe)
                        return Pe;
                    k.set(i, V),
                    __(i) ? i.forEach(function(je) {
                        V.add(Xn(je, a, u, je, i, k))
                    }) : g_(i) && i.forEach(function(je, ut) {
                        V.set(ut, Xn(je, a, u, ut, i, k))
                    });
                    var Fe = le ? ne ? Hh : qh : ne ? In : en
                      , nt = fe ? n : Fe(i);
                    return Oe(nt || i, function(je, ut) {
                        nt && (ut = je,
                        je = i[ut]),
                        gc(V, ut, Xn(je, a, u, ut, i, k))
                    }),
                    V
                }
                function _T(i) {
                    var a = en(i);
                    return function(u) {
                        return ty(u, i, a)
                    }
                }
                function ty(i, a, u) {
                    var p = u.length;
                    if (i == null)
                        return !p;
                    for (i = Nt(i); p--; ) {
                        var b = u[p]
                          , k = a[b]
                          , V = i[b];
                        if (V === n && !(b in i) || !k(V))
                            return !1
                    }
                    return !0
                }
                function ny(i, a, u) {
                    if (typeof i != "function")
                        throw new Kn(c);
                    return Sc(function() {
                        i.apply(n, u)
                    }, a)
                }
                function yc(i, a, u, p) {
                    var b = -1
                      , k = We
                      , V = !0
                      , Z = i.length
                      , ne = []
                      , le = a.length;
                    if (!Z)
                        return ne;
                    u && (a = Ye(a, Un(u))),
                    p ? (k = Ce,
                    V = !1) : a.length >= s && (k = lc,
                    V = !1,
                    a = new Ms(a));
                    e: for (; ++b < Z; ) {
                        var fe = i[b]
                          , he = u == null ? fe : u(fe);
                        if (fe = p || fe !== 0 ? fe : 0,
                        V && he === he) {
                            for (var ve = le; ve--; )
                                if (a[ve] === he)
                                    continue e;
                            ne.push(fe)
                        } else
                            k(a, he, p) || ne.push(fe)
                    }
                    return ne
                }
                var ts = xy(qr)
                  , ry = xy(Ah, !0);
                function vT(i, a) {
                    var u = !0;
                    return ts(i, function(p, b, k) {
                        return u = !!a(p, b, k),
                        u
                    }),
                    u
                }
                function xl(i, a, u) {
                    for (var p = -1, b = i.length; ++p < b; ) {
                        var k = i[p]
                          , V = a(k);
                        if (V != null && (Z === n ? V === V && !Fn(V) : u(V, Z)))
                            var Z = V
                              , ne = k
                    }
                    return ne
                }
                function wT(i, a, u, p) {
                    var b = i.length;
                    for (u = Xe(u),
                    u < 0 && (u = -u > b ? 0 : b + u),
                    p = p === n || p > b ? b : Xe(p),
                    p < 0 && (p += b),
                    p = u > p ? 0 : w_(p); u < p; )
                        i[u++] = a;
                    return i
                }
                function iy(i, a) {
                    var u = [];
                    return ts(i, function(p, b, k) {
                        a(p, b, k) && u.push(p)
                    }),
                    u
                }
                function on(i, a, u, p, b) {
                    var k = -1
                      , V = i.length;
                    for (u || (u = cA),
                    b || (b = []); ++k < V; ) {
                        var Z = i[k];
                        a > 0 && u(Z) ? a > 1 ? on(Z, a - 1, u, p, b) : At(b, Z) : p || (b[b.length] = Z)
                    }
                    return b
                }
                var Th = $y()
                  , sy = $y(!0);
                function qr(i, a) {
                    return i && Th(i, a, en)
                }
                function Ah(i, a) {
                    return i && sy(i, a, en)
                }
                function $l(i, a) {
                    return xe(a, function(u) {
                        return vi(i[u])
                    })
                }
                function Ds(i, a) {
                    a = rs(a, i);
                    for (var u = 0, p = a.length; i != null && u < p; )
                        i = i[Yr(a[u++])];
                    return u && u == p ? i : n
                }
                function ay(i, a, u) {
                    var p = a(i);
                    return Ze(i) ? p : At(p, u(i))
                }
                function _n(i) {
                    return i == null ? i === n ? pa : Br : ks && ks in Nt(i) ? nA(i) : mA(i)
                }
                function Oh(i, a) {
                    return i > a
                }
                function bT(i, a) {
                    return i != null && St.call(i, a)
                }
                function ET(i, a) {
                    return i != null && a in Nt(i)
                }
                function ST(i, a, u) {
                    return i >= fn(a, u) && i < Zt(a, u)
                }
                function Ih(i, a, u) {
                    for (var p = u ? Ce : We, b = i[0].length, k = i.length, V = k, Z = ce(k), ne = 1 / 0, le = []; V--; ) {
                        var fe = i[V];
                        V && a && (fe = Ye(fe, Un(a))),
                        ne = fn(fe.length, ne),
                        Z[V] = !u && (a || b >= 120 && fe.length >= 120) ? new Ms(V && fe) : n
                    }
                    fe = i[0];
                    var he = -1
                      , ve = Z[0];
                    e: for (; ++he < b && le.length < ne; ) {
                        var Pe = fe[he]
                          , Fe = a ? a(Pe) : Pe;
                        if (Pe = u || Pe !== 0 ? Pe : 0,
                        !(ve ? lc(ve, Fe) : p(le, Fe, u))) {
                            for (V = k; --V; ) {
                                var nt = Z[V];
                                if (!(nt ? lc(nt, Fe) : p(i[V], Fe, u)))
                                    continue e
                            }
                            ve && ve.push(Fe),
                            le.push(Pe)
                        }
                    }
                    return le
                }
                function TT(i, a, u, p) {
                    return qr(i, function(b, k, V) {
                        a(p, u(b), k, V)
                    }),
                    p
                }
                function _c(i, a, u) {
                    a = rs(a, i),
                    i = zy(i, a);
                    var p = i == null ? i : i[Yr(er(a))];
                    return p == null ? n : pe(p, i, u)
                }
                function oy(i) {
                    return Bt(i) && _n(i) == j
                }
                function AT(i) {
                    return Bt(i) && _n(i) == zn
                }
                function OT(i) {
                    return Bt(i) && _n(i) == De
                }
                function vc(i, a, u, p, b) {
                    return i === a ? !0 : i == null || a == null || !Bt(i) && !Bt(a) ? i !== i && a !== a : IT(i, a, u, p, vc, b)
                }
                function IT(i, a, u, p, b, k) {
                    var V = Ze(i)
                      , Z = Ze(a)
                      , ne = V ? se : dn(i)
                      , le = Z ? se : dn(a);
                    ne = ne == j ? yn : ne,
                    le = le == j ? yn : le;
                    var fe = ne == yn
                      , he = le == yn
                      , ve = ne == le;
                    if (ve && ss(i)) {
                        if (!ss(a))
                            return !1;
                        V = !0,
                        fe = !1
                    }
                    if (ve && !fe)
                        return k || (k = new wr),
                        V || Fa(i) ? Fy(i, a, u, p, b, k) : eA(i, a, ne, u, p, b, k);
                    if (!(u & O)) {
                        var Pe = fe && St.call(i, "__wrapped__")
                          , Fe = he && St.call(a, "__wrapped__");
                        if (Pe || Fe) {
                            var nt = Pe ? i.value() : i
                              , je = Fe ? a.value() : a;
                            return k || (k = new wr),
                            b(nt, je, u, p, k)
                        }
                    }
                    return ve ? (k || (k = new wr),
                    tA(i, a, u, p, b, k)) : !1
                }
                function NT(i) {
                    return Bt(i) && dn(i) == st
                }
                function Nh(i, a, u, p) {
                    var b = u.length
                      , k = b
                      , V = !p;
                    if (i == null)
                        return !k;
                    for (i = Nt(i); b--; ) {
                        var Z = u[b];
                        if (V && Z[2] ? Z[1] !== i[Z[0]] : !(Z[0]in i))
                            return !1
                    }
                    for (; ++b < k; ) {
                        Z = u[b];
                        var ne = Z[0]
                          , le = i[ne]
                          , fe = Z[1];
                        if (V && Z[2]) {
                            if (le === n && !(ne in i))
                                return !1
                        } else {
                            var he = new wr;
                            if (p)
                                var ve = p(le, fe, ne, i, a, he);
                            if (!(ve === n ? vc(fe, le, O | A, p, he) : ve))
                                return !1
                        }
                    }
                    return !0
                }
                function cy(i) {
                    if (!Ct(i) || lA(i))
                        return !1;
                    var a = vi(i) ? NS : $s;
                    return a.test(Bs(i))
                }
                function xT(i) {
                    return Bt(i) && _n(i) == yr
                }
                function $T(i) {
                    return Bt(i) && dn(i) == an
                }
                function RT(i) {
                    return Bt(i) && zl(i.length) && !!It[_n(i)]
                }
                function uy(i) {
                    return typeof i == "function" ? i : i == null ? Nn : typeof i == "object" ? Ze(i) ? dy(i[0], i[1]) : fy(i) : R_(i)
                }
                function xh(i) {
                    if (!Ec(i))
                        return CS(i);
                    var a = [];
                    for (var u in Nt(i))
                        St.call(i, u) && u != "constructor" && a.push(u);
                    return a
                }
                function PT(i) {
                    if (!Ct(i))
                        return pA(i);
                    var a = Ec(i)
                      , u = [];
                    for (var p in i)
                        p == "constructor" && (a || !St.call(i, p)) || u.push(p);
                    return u
                }
                function $h(i, a) {
                    return i < a
                }
                function ly(i, a) {
                    var u = -1
                      , p = On(i) ? ce(i.length) : [];
                    return ts(i, function(b, k, V) {
                        p[++u] = a(b, k, V)
                    }),
                    p
                }
                function fy(i) {
                    var a = Vh(i);
                    return a.length == 1 && a[0][2] ? Vy(a[0][0], a[0][1]) : function(u) {
                        return u === i || Nh(u, i, a)
                    }
                }
                function dy(i, a) {
                    return zh(i) && Yy(a) ? Vy(Yr(i), a) : function(u) {
                        var p = rp(u, i);
                        return p === n && p === a ? ip(u, i) : vc(a, p, O | A)
                    }
                }
                function Rl(i, a, u, p, b) {
                    i !== a && Th(a, function(k, V) {
                        if (b || (b = new wr),
                        Ct(k))
                            kT(i, a, V, u, Rl, p, b);
                        else {
                            var Z = p ? p(Zh(i, V), k, V + "", i, a, b) : n;
                            Z === n && (Z = k),
                            Eh(i, V, Z)
                        }
                    }, In)
                }
                function kT(i, a, u, p, b, k, V) {
                    var Z = Zh(i, u)
                      , ne = Zh(a, u)
                      , le = V.get(ne);
                    if (le) {
                        Eh(i, u, le);
                        return
                    }
                    var fe = k ? k(Z, ne, u + "", i, a, V) : n
                      , he = fe === n;
                    if (he) {
                        var ve = Ze(ne)
                          , Pe = !ve && ss(ne)
                          , Fe = !ve && !Pe && Fa(ne);
                        fe = ne,
                        ve || Pe || Fe ? Ze(Z) ? fe = Z : Ft(Z) ? fe = An(Z) : Pe ? (he = !1,
                        fe = Ty(ne, !0)) : Fe ? (he = !1,
                        fe = Ay(ne, !0)) : fe = [] : Tc(ne) || Fs(ne) ? (fe = Z,
                        Fs(Z) ? fe = b_(Z) : (!Ct(Z) || vi(Z)) && (fe = Hy(ne))) : he = !1
                    }
                    he && (V.set(ne, fe),
                    b(fe, ne, p, k, V),
                    V.delete(ne)),
                    Eh(i, u, fe)
                }
                function hy(i, a) {
                    var u = i.length;
                    if (u)
                        return a += a < 0 ? u : 0,
                        _i(a, u) ? i[a] : n
                }
                function py(i, a, u) {
                    a.length ? a = Ye(a, function(k) {
                        return Ze(k) ? function(V) {
                            return Ds(V, k.length === 1 ? k[0] : k)
                        }
                        : k
                    }) : a = [Nn];
                    var p = -1;
                    a = Ye(a, Un(Ue()));
                    var b = ly(i, function(k, V, Z) {
                        var ne = Ye(a, function(le) {
                            return le(k)
                        });
                        return {
                            criteria: ne,
                            index: ++p,
                            value: k
                        }
                    });
                    return aS(b, function(k, V) {
                        return WT(k, V, u)
                    })
                }
                function CT(i, a) {
                    return my(i, a, function(u, p) {
                        return ip(i, p)
                    })
                }
                function my(i, a, u) {
                    for (var p = -1, b = a.length, k = {}; ++p < b; ) {
                        var V = a[p]
                          , Z = Ds(i, V);
                        u(Z, V) && wc(k, rs(V, i), Z)
                    }
                    return k
                }
                function MT(i) {
                    return function(a) {
                        return Ds(a, i)
                    }
                }
                function Rh(i, a, u, p) {
                    var b = p ? sS : xa
                      , k = -1
                      , V = a.length
                      , Z = i;
                    for (i === a && (a = An(a)),
                    u && (Z = Ye(i, Un(u))); ++k < V; )
                        for (var ne = 0, le = a[k], fe = u ? u(le) : le; (ne = b(Z, fe, ne, p)) > -1; )
                            Z !== i && bl.call(Z, ne, 1),
                            bl.call(i, ne, 1);
                    return i
                }
                function gy(i, a) {
                    for (var u = i ? a.length : 0, p = u - 1; u--; ) {
                        var b = a[u];
                        if (u == p || b !== k) {
                            var k = b;
                            _i(b) ? bl.call(i, b, 1) : Mh(i, b)
                        }
                    }
                    return i
                }
                function Ph(i, a) {
                    return i + Tl(K0() * (a - i + 1))
                }
                function LT(i, a, u, p) {
                    for (var b = -1, k = Zt(Sl((a - i) / (u || 1)), 0), V = ce(k); k--; )
                        V[p ? k : ++b] = i,
                        i += u;
                    return V
                }
                function kh(i, a) {
                    var u = "";
                    if (!i || a < 1 || a > W)
                        return u;
                    do
                        a % 2 && (u += i),
                        a = Tl(a / 2),
                        a && (i += i);
                    while (a);
                    return u
                }
                function it(i, a) {
                    return Kh(Wy(i, a, Nn), i + "")
                }
                function DT(i) {
                    return Q0(ja(i))
                }
                function UT(i, a) {
                    var u = ja(i);
                    return jl(u, Ls(a, 0, u.length))
                }
                function wc(i, a, u, p) {
                    if (!Ct(i))
                        return i;
                    a = rs(a, i);
                    for (var b = -1, k = a.length, V = k - 1, Z = i; Z != null && ++b < k; ) {
                        var ne = Yr(a[b])
                          , le = u;
                        if (ne === "__proto__" || ne === "constructor" || ne === "prototype")
                            return i;
                        if (b != V) {
                            var fe = Z[ne];
                            le = p ? p(fe, ne, Z) : n,
                            le === n && (le = Ct(fe) ? fe : _i(a[b + 1]) ? [] : {})
                        }
                        gc(Z, ne, le),
                        Z = Z[ne]
                    }
                    return i
                }
                var yy = Al ? function(i, a) {
                    return Al.set(i, a),
                    i
                }
                : Nn
                  , BT = El ? function(i, a) {
                    return El(i, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: ap(a),
                        writable: !0
                    })
                }
                : Nn;
                function FT(i) {
                    return jl(ja(i))
                }
                function Qn(i, a, u) {
                    var p = -1
                      , b = i.length;
                    a < 0 && (a = -a > b ? 0 : b + a),
                    u = u > b ? b : u,
                    u < 0 && (u += b),
                    b = a > u ? 0 : u - a >>> 0,
                    a >>>= 0;
                    for (var k = ce(b); ++p < b; )
                        k[p] = i[p + a];
                    return k
                }
                function jT(i, a) {
                    var u;
                    return ts(i, function(p, b, k) {
                        return u = a(p, b, k),
                        !u
                    }),
                    !!u
                }
                function Pl(i, a, u) {
                    var p = 0
                      , b = i == null ? p : i.length;
                    if (typeof a == "number" && a === a && b <= Q) {
                        for (; p < b; ) {
                            var k = p + b >>> 1
                              , V = i[k];
                            V !== null && !Fn(V) && (u ? V <= a : V < a) ? p = k + 1 : b = k
                        }
                        return b
                    }
                    return Ch(i, a, Nn, u)
                }
                function Ch(i, a, u, p) {
                    var b = 0
                      , k = i == null ? 0 : i.length;
                    if (k === 0)
                        return 0;
                    a = u(a);
                    for (var V = a !== a, Z = a === null, ne = Fn(a), le = a === n; b < k; ) {
                        var fe = Tl((b + k) / 2)
                          , he = u(i[fe])
                          , ve = he !== n
                          , Pe = he === null
                          , Fe = he === he
                          , nt = Fn(he);
                        if (V)
                            var je = p || Fe;
                        else
                            le ? je = Fe && (p || ve) : Z ? je = Fe && ve && (p || !Pe) : ne ? je = Fe && ve && !Pe && (p || !nt) : Pe || nt ? je = !1 : je = p ? he <= a : he < a;
                        je ? b = fe + 1 : k = fe
                    }
                    return fn(k, ae)
                }
                function _y(i, a) {
                    for (var u = -1, p = i.length, b = 0, k = []; ++u < p; ) {
                        var V = i[u]
                          , Z = a ? a(V) : V;
                        if (!u || !br(Z, ne)) {
                            var ne = Z;
                            k[b++] = V === 0 ? 0 : V
                        }
                    }
                    return k
                }
                function vy(i) {
                    return typeof i == "number" ? i : Fn(i) ? J : +i
                }
                function Bn(i) {
                    if (typeof i == "string")
                        return i;
                    if (Ze(i))
                        return Ye(i, Bn) + "";
                    if (Fn(i))
                        return J0 ? J0.call(i) : "";
                    var a = i + "";
                    return a == "0" && 1 / i == -Y ? "-0" : a
                }
                function ns(i, a, u) {
                    var p = -1
                      , b = We
                      , k = i.length
                      , V = !0
                      , Z = []
                      , ne = Z;
                    if (u)
                        V = !1,
                        b = Ce;
                    else if (k >= s) {
                        var le = a ? null : XT(i);
                        if (le)
                            return hl(le);
                        V = !1,
                        b = lc,
                        ne = new Ms
                    } else
                        ne = a ? [] : Z;
                    e: for (; ++p < k; ) {
                        var fe = i[p]
                          , he = a ? a(fe) : fe;
                        if (fe = u || fe !== 0 ? fe : 0,
                        V && he === he) {
                            for (var ve = ne.length; ve--; )
                                if (ne[ve] === he)
                                    continue e;
                            a && ne.push(he),
                            Z.push(fe)
                        } else
                            b(ne, he, u) || (ne !== Z && ne.push(he),
                            Z.push(fe))
                    }
                    return Z
                }
                function Mh(i, a) {
                    return a = rs(a, i),
                    i = zy(i, a),
                    i == null || delete i[Yr(er(a))]
                }
                function wy(i, a, u, p) {
                    return wc(i, a, u(Ds(i, a)), p)
                }
                function kl(i, a, u, p) {
                    for (var b = i.length, k = p ? b : -1; (p ? k-- : ++k < b) && a(i[k], k, i); )
                        ;
                    return u ? Qn(i, p ? 0 : k, p ? k + 1 : b) : Qn(i, p ? k + 1 : 0, p ? b : k)
                }
                function by(i, a) {
                    var u = i;
                    return u instanceof lt && (u = u.value()),
                    Ut(a, function(p, b) {
                        return b.func.apply(b.thisArg, At([p], b.args))
                    }, u)
                }
                function Lh(i, a, u) {
                    var p = i.length;
                    if (p < 2)
                        return p ? ns(i[0]) : [];
                    for (var b = -1, k = ce(p); ++b < p; )
                        for (var V = i[b], Z = -1; ++Z < p; )
                            Z != b && (k[b] = yc(k[b] || V, i[Z], a, u));
                    return ns(on(k, 1), a, u)
                }
                function Ey(i, a, u) {
                    for (var p = -1, b = i.length, k = a.length, V = {}; ++p < b; ) {
                        var Z = p < k ? a[p] : n;
                        u(V, i[p], Z)
                    }
                    return V
                }
                function Dh(i) {
                    return Ft(i) ? i : []
                }
                function Uh(i) {
                    return typeof i == "function" ? i : Nn
                }
                function rs(i, a) {
                    return Ze(i) ? i : zh(i, a) ? [i] : Jy(wt(i))
                }
                var qT = it;
                function is(i, a, u) {
                    var p = i.length;
                    return u = u === n ? p : u,
                    !a && u >= p ? i : Qn(i, a, u)
                }
                var Sy = xS || function(i) {
                    return zt.clearTimeout(i)
                }
                ;
                function Ty(i, a) {
                    if (a)
                        return i.slice();
                    var u = i.length
                      , p = V0 ? V0(u) : new i.constructor(u);
                    return i.copy(p),
                    p
                }
                function Bh(i) {
                    var a = new i.constructor(i.byteLength);
                    return new vl(a).set(new vl(i)),
                    a
                }
                function HT(i, a) {
                    var u = a ? Bh(i.buffer) : i.buffer;
                    return new i.constructor(u,i.byteOffset,i.byteLength)
                }
                function YT(i) {
                    var a = new i.constructor(i.source,Xu.exec(i));
                    return a.lastIndex = i.lastIndex,
                    a
                }
                function VT(i) {
                    return mc ? Nt(mc.call(i)) : {}
                }
                function Ay(i, a) {
                    var u = a ? Bh(i.buffer) : i.buffer;
                    return new i.constructor(u,i.byteOffset,i.length)
                }
                function Oy(i, a) {
                    if (i !== a) {
                        var u = i !== n
                          , p = i === null
                          , b = i === i
                          , k = Fn(i)
                          , V = a !== n
                          , Z = a === null
                          , ne = a === a
                          , le = Fn(a);
                        if (!Z && !le && !k && i > a || k && V && ne && !Z && !le || p && V && ne || !u && ne || !b)
                            return 1;
                        if (!p && !k && !le && i < a || le && u && b && !p && !k || Z && u && b || !V && b || !ne)
                            return -1
                    }
                    return 0
                }
                function WT(i, a, u) {
                    for (var p = -1, b = i.criteria, k = a.criteria, V = b.length, Z = u.length; ++p < V; ) {
                        var ne = Oy(b[p], k[p]);
                        if (ne) {
                            if (p >= Z)
                                return ne;
                            var le = u[p];
                            return ne * (le == "desc" ? -1 : 1)
                        }
                    }
                    return i.index - a.index
                }
                function Iy(i, a, u, p) {
                    for (var b = -1, k = i.length, V = u.length, Z = -1, ne = a.length, le = Zt(k - V, 0), fe = ce(ne + le), he = !p; ++Z < ne; )
                        fe[Z] = a[Z];
                    for (; ++b < V; )
                        (he || b < k) && (fe[u[b]] = i[b]);
                    for (; le--; )
                        fe[Z++] = i[b++];
                    return fe
                }
                function Ny(i, a, u, p) {
                    for (var b = -1, k = i.length, V = -1, Z = u.length, ne = -1, le = a.length, fe = Zt(k - Z, 0), he = ce(fe + le), ve = !p; ++b < fe; )
                        he[b] = i[b];
                    for (var Pe = b; ++ne < le; )
                        he[Pe + ne] = a[ne];
                    for (; ++V < Z; )
                        (ve || b < k) && (he[Pe + u[V]] = i[b++]);
                    return he
                }
                function An(i, a) {
                    var u = -1
                      , p = i.length;
                    for (a || (a = ce(p)); ++u < p; )
                        a[u] = i[u];
                    return a
                }
                function Hr(i, a, u, p) {
                    var b = !u;
                    u || (u = {});
                    for (var k = -1, V = a.length; ++k < V; ) {
                        var Z = a[k]
                          , ne = p ? p(u[Z], i[Z], Z, u, i) : n;
                        ne === n && (ne = i[Z]),
                        b ? mi(u, Z, ne) : gc(u, Z, ne)
                    }
                    return u
                }
                function zT(i, a) {
                    return Hr(i, Wh(i), a)
                }
                function GT(i, a) {
                    return Hr(i, jy(i), a)
                }
                function Cl(i, a) {
                    return function(u, p) {
                        var b = Ze(u) ? _e : gT
                          , k = a ? a() : {};
                        return b(u, i, Ue(p, 2), k)
                    }
                }
                function Da(i) {
                    return it(function(a, u) {
                        var p = -1
                          , b = u.length
                          , k = b > 1 ? u[b - 1] : n
                          , V = b > 2 ? u[2] : n;
                        for (k = i.length > 3 && typeof k == "function" ? (b--,
                        k) : n,
                        V && vn(u[0], u[1], V) && (k = b < 3 ? n : k,
                        b = 1),
                        a = Nt(a); ++p < b; ) {
                            var Z = u[p];
                            Z && i(a, Z, p, k)
                        }
                        return a
                    })
                }
                function xy(i, a) {
                    return function(u, p) {
                        if (u == null)
                            return u;
                        if (!On(u))
                            return i(u, p);
                        for (var b = u.length, k = a ? b : -1, V = Nt(u); (a ? k-- : ++k < b) && p(V[k], k, V) !== !1; )
                            ;
                        return u
                    }
                }
                function $y(i) {
                    return function(a, u, p) {
                        for (var b = -1, k = Nt(a), V = p(a), Z = V.length; Z--; ) {
                            var ne = V[i ? Z : ++b];
                            if (u(k[ne], ne, k) === !1)
                                break
                        }
                        return a
                    }
                }
                function ZT(i, a, u) {
                    var p = a & N
                      , b = bc(i);
                    function k() {
                        var V = this && this !== zt && this instanceof k ? b : i;
                        return V.apply(p ? u : this, arguments)
                    }
                    return k
                }
                function Ry(i) {
                    return function(a) {
                        a = wt(a);
                        var u = $a(a) ? vr(a) : n
                          , p = u ? u[0] : a.charAt(0)
                          , b = u ? is(u, 1).join("") : a.slice(1);
                        return p[i]() + b
                    }
                }
                function Ua(i) {
                    return function(a) {
                        return Ut(x_(N_(a).replace(ol, "")), i, "")
                    }
                }
                function bc(i) {
                    return function() {
                        var a = arguments;
                        switch (a.length) {
                        case 0:
                            return new i;
                        case 1:
                            return new i(a[0]);
                        case 2:
                            return new i(a[0],a[1]);
                        case 3:
                            return new i(a[0],a[1],a[2]);
                        case 4:
                            return new i(a[0],a[1],a[2],a[3]);
                        case 5:
                            return new i(a[0],a[1],a[2],a[3],a[4]);
                        case 6:
                            return new i(a[0],a[1],a[2],a[3],a[4],a[5]);
                        case 7:
                            return new i(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
                        }
                        var u = La(i.prototype)
                          , p = i.apply(u, a);
                        return Ct(p) ? p : u
                    }
                }
                function KT(i, a, u) {
                    var p = bc(i);
                    function b() {
                        for (var k = arguments.length, V = ce(k), Z = k, ne = Ba(b); Z--; )
                            V[Z] = arguments[Z];
                        var le = k < 3 && V[0] !== ne && V[k - 1] !== ne ? [] : Qi(V, ne);
                        if (k -= le.length,
                        k < u)
                            return Ly(i, a, Ml, b.placeholder, n, V, le, n, n, u - k);
                        var fe = this && this !== zt && this instanceof b ? p : i;
                        return pe(fe, this, V)
                    }
                    return b
                }
                function Py(i) {
                    return function(a, u, p) {
                        var b = Nt(a);
                        if (!On(a)) {
                            var k = Ue(u, 3);
                            a = en(a),
                            u = function(Z) {
                                return k(b[Z], Z, b)
                            }
                        }
                        var V = i(a, u, p);
                        return V > -1 ? b[k ? a[V] : V] : n
                    }
                }
                function ky(i) {
                    return yi(function(a) {
                        var u = a.length
                          , p = u
                          , b = Jn.prototype.thru;
                        for (i && a.reverse(); p--; ) {
                            var k = a[p];
                            if (typeof k != "function")
                                throw new Kn(c);
                            if (b && !V && Bl(k) == "wrapper")
                                var V = new Jn([],!0)
                        }
                        for (p = V ? p : u; ++p < u; ) {
                            k = a[p];
                            var Z = Bl(k)
                              , ne = Z == "wrapper" ? Yh(k) : n;
                            ne && Gh(ne[0]) && ne[1] == (K | M | U | _) && !ne[4].length && ne[9] == 1 ? V = V[Bl(ne[0])].apply(V, ne[3]) : V = k.length == 1 && Gh(k) ? V[Z]() : V.thru(k)
                        }
                        return function() {
                            var le = arguments
                              , fe = le[0];
                            if (V && le.length == 1 && Ze(fe))
                                return V.plant(fe).value();
                            for (var he = 0, ve = u ? a[he].apply(this, le) : fe; ++he < u; )
                                ve = a[he].call(this, ve);
                            return ve
                        }
                    })
                }
                function Ml(i, a, u, p, b, k, V, Z, ne, le) {
                    var fe = a & K
                      , he = a & N
                      , ve = a & m
                      , Pe = a & (M | G)
                      , Fe = a & T
                      , nt = ve ? n : bc(i);
                    function je() {
                        for (var ut = arguments.length, dt = ce(ut), jn = ut; jn--; )
                            dt[jn] = arguments[jn];
                        if (Pe)
                            var wn = Ba(je)
                              , qn = cS(dt, wn);
                        if (p && (dt = Iy(dt, p, b, Pe)),
                        k && (dt = Ny(dt, k, V, Pe)),
                        ut -= qn,
                        Pe && ut < le) {
                            var jt = Qi(dt, wn);
                            return Ly(i, a, Ml, je.placeholder, u, dt, jt, Z, ne, le - ut)
                        }
                        var Er = he ? u : this
                          , bi = ve ? Er[i] : i;
                        return ut = dt.length,
                        Z ? dt = gA(dt, Z) : Fe && ut > 1 && dt.reverse(),
                        fe && ne < ut && (dt.length = ne),
                        this && this !== zt && this instanceof je && (bi = nt || bc(bi)),
                        bi.apply(Er, dt)
                    }
                    return je
                }
                function Cy(i, a) {
                    return function(u, p) {
                        return TT(u, i, a(p), {})
                    }
                }
                function Ll(i, a) {
                    return function(u, p) {
                        var b;
                        if (u === n && p === n)
                            return a;
                        if (u !== n && (b = u),
                        p !== n) {
                            if (b === n)
                                return p;
                            typeof u == "string" || typeof p == "string" ? (u = Bn(u),
                            p = Bn(p)) : (u = vy(u),
                            p = vy(p)),
                            b = i(u, p)
                        }
                        return b
                    }
                }
                function Fh(i) {
                    return yi(function(a) {
                        return a = Ye(a, Un(Ue())),
                        it(function(u) {
                            var p = this;
                            return i(a, function(b) {
                                return pe(b, p, u)
                            })
                        })
                    })
                }
                function Dl(i, a) {
                    a = a === n ? " " : Bn(a);
                    var u = a.length;
                    if (u < 2)
                        return u ? kh(a, i) : a;
                    var p = kh(a, Sl(i / Ra(a)));
                    return $a(a) ? is(vr(p), 0, i).join("") : p.slice(0, i)
                }
                function JT(i, a, u, p) {
                    var b = a & N
                      , k = bc(i);
                    function V() {
                        for (var Z = -1, ne = arguments.length, le = -1, fe = p.length, he = ce(fe + ne), ve = this && this !== zt && this instanceof V ? k : i; ++le < fe; )
                            he[le] = p[le];
                        for (; ne--; )
                            he[le++] = arguments[++Z];
                        return pe(ve, b ? u : this, he)
                    }
                    return V
                }
                function My(i) {
                    return function(a, u, p) {
                        return p && typeof p != "number" && vn(a, u, p) && (u = p = n),
                        a = wi(a),
                        u === n ? (u = a,
                        a = 0) : u = wi(u),
                        p = p === n ? a < u ? 1 : -1 : wi(p),
                        LT(a, u, p, i)
                    }
                }
                function Ul(i) {
                    return function(a, u) {
                        return typeof a == "string" && typeof u == "string" || (a = tr(a),
                        u = tr(u)),
                        i(a, u)
                    }
                }
                function Ly(i, a, u, p, b, k, V, Z, ne, le) {
                    var fe = a & M
                      , he = fe ? V : n
                      , ve = fe ? n : V
                      , Pe = fe ? k : n
                      , Fe = fe ? n : k;
                    a |= fe ? U : D,
                    a &= ~(fe ? D : U),
                    a & g || (a &= ~(N | m));
                    var nt = [i, a, b, Pe, he, Fe, ve, Z, ne, le]
                      , je = u.apply(n, nt);
                    return Gh(i) && Gy(je, nt),
                    je.placeholder = p,
                    Zy(je, i, a)
                }
                function jh(i) {
                    var a = Gt[i];
                    return function(u, p) {
                        if (u = tr(u),
                        p = p == null ? 0 : fn(Xe(p), 292),
                        p && Z0(u)) {
                            var b = (wt(u) + "e").split("e")
                              , k = a(b[0] + "e" + (+b[1] + p));
                            return b = (wt(k) + "e").split("e"),
                            +(b[0] + "e" + (+b[1] - p))
                        }
                        return a(u)
                    }
                }
                var XT = Ca && 1 / hl(new Ca([, -0]))[1] == Y ? function(i) {
                    return new Ca(i)
                }
                : up;
                function Dy(i) {
                    return function(a) {
                        var u = dn(a);
                        return u == st ? yh(a) : u == an ? mS(a) : oS(a, i(a))
                    }
                }
                function gi(i, a, u, p, b, k, V, Z) {
                    var ne = a & m;
                    if (!ne && typeof i != "function")
                        throw new Kn(c);
                    var le = p ? p.length : 0;
                    if (le || (a &= ~(U | D),
                    p = b = n),
                    V = V === n ? V : Zt(Xe(V), 0),
                    Z = Z === n ? Z : Xe(Z),
                    le -= b ? b.length : 0,
                    a & D) {
                        var fe = p
                          , he = b;
                        p = b = n
                    }
                    var ve = ne ? n : Yh(i)
                      , Pe = [i, a, u, p, b, fe, he, k, V, Z];
                    if (ve && hA(Pe, ve),
                    i = Pe[0],
                    a = Pe[1],
                    u = Pe[2],
                    p = Pe[3],
                    b = Pe[4],
                    Z = Pe[9] = Pe[9] === n ? ne ? 0 : i.length : Zt(Pe[9] - le, 0),
                    !Z && a & (M | G) && (a &= ~(M | G)),
                    !a || a == N)
                        var Fe = ZT(i, a, u);
                    else
                        a == M || a == G ? Fe = KT(i, a, Z) : (a == U || a == (N | U)) && !b.length ? Fe = JT(i, a, u, p) : Fe = Ml.apply(n, Pe);
                    var nt = ve ? yy : Gy;
                    return Zy(nt(Fe, Pe), i, a)
                }
                function Uy(i, a, u, p) {
                    return i === n || br(i, ka[u]) && !St.call(p, u) ? a : i
                }
                function By(i, a, u, p, b, k) {
                    return Ct(i) && Ct(a) && (k.set(a, i),
                    Rl(i, a, n, By, k),
                    k.delete(a)),
                    i
                }
                function QT(i) {
                    return Tc(i) ? n : i
                }
                function Fy(i, a, u, p, b, k) {
                    var V = u & O
                      , Z = i.length
                      , ne = a.length;
                    if (Z != ne && !(V && ne > Z))
                        return !1;
                    var le = k.get(i)
                      , fe = k.get(a);
                    if (le && fe)
                        return le == a && fe == i;
                    var he = -1
                      , ve = !0
                      , Pe = u & A ? new Ms : n;
                    for (k.set(i, a),
                    k.set(a, i); ++he < Z; ) {
                        var Fe = i[he]
                          , nt = a[he];
                        if (p)
                            var je = V ? p(nt, Fe, he, a, i, k) : p(Fe, nt, he, i, a, k);
                        if (je !== n) {
                            if (je)
                                continue;
                            ve = !1;
                            break
                        }
                        if (Pe) {
                            if (!Qt(a, function(ut, dt) {
                                if (!lc(Pe, dt) && (Fe === ut || b(Fe, ut, u, p, k)))
                                    return Pe.push(dt)
                            })) {
                                ve = !1;
                                break
                            }
                        } else if (!(Fe === nt || b(Fe, nt, u, p, k))) {
                            ve = !1;
                            break
                        }
                    }
                    return k.delete(i),
                    k.delete(a),
                    ve
                }
                function eA(i, a, u, p, b, k, V) {
                    switch (u) {
                    case Gn:
                        if (i.byteLength != a.byteLength || i.byteOffset != a.byteOffset)
                            return !1;
                        i = i.buffer,
                        a = a.buffer;
                    case zn:
                        return !(i.byteLength != a.byteLength || !k(new vl(i), new vl(a)));
                    case we:
                    case De:
                    case ct:
                        return br(+i, +a);
                    case tt:
                        return i.name == a.name && i.message == a.message;
                    case yr:
                    case Wn:
                        return i == a + "";
                    case st:
                        var Z = yh;
                    case an:
                        var ne = p & O;
                        if (Z || (Z = hl),
                        i.size != a.size && !ne)
                            return !1;
                        var le = V.get(i);
                        if (le)
                            return le == a;
                        p |= A,
                        V.set(i, a);
                        var fe = Fy(Z(i), Z(a), p, b, k, V);
                        return V.delete(i),
                        fe;
                    case Fr:
                        if (mc)
                            return mc.call(i) == mc.call(a)
                    }
                    return !1
                }
                function tA(i, a, u, p, b, k) {
                    var V = u & O
                      , Z = qh(i)
                      , ne = Z.length
                      , le = qh(a)
                      , fe = le.length;
                    if (ne != fe && !V)
                        return !1;
                    for (var he = ne; he--; ) {
                        var ve = Z[he];
                        if (!(V ? ve in a : St.call(a, ve)))
                            return !1
                    }
                    var Pe = k.get(i)
                      , Fe = k.get(a);
                    if (Pe && Fe)
                        return Pe == a && Fe == i;
                    var nt = !0;
                    k.set(i, a),
                    k.set(a, i);
                    for (var je = V; ++he < ne; ) {
                        ve = Z[he];
                        var ut = i[ve]
                          , dt = a[ve];
                        if (p)
                            var jn = V ? p(dt, ut, ve, a, i, k) : p(ut, dt, ve, i, a, k);
                        if (!(jn === n ? ut === dt || b(ut, dt, u, p, k) : jn)) {
                            nt = !1;
                            break
                        }
                        je || (je = ve == "constructor")
                    }
                    if (nt && !je) {
                        var wn = i.constructor
                          , qn = a.constructor;
                        wn != qn && "constructor"in i && "constructor"in a && !(typeof wn == "function" && wn instanceof wn && typeof qn == "function" && qn instanceof qn) && (nt = !1)
                    }
                    return k.delete(i),
                    k.delete(a),
                    nt
                }
                function yi(i) {
                    return Kh(Wy(i, n, t_), i + "")
                }
                function qh(i) {
                    return ay(i, en, Wh)
                }
                function Hh(i) {
                    return ay(i, In, jy)
                }
                var Yh = Al ? function(i) {
                    return Al.get(i)
                }
                : up;
                function Bl(i) {
                    for (var a = i.name + "", u = Ma[a], p = St.call(Ma, a) ? u.length : 0; p--; ) {
                        var b = u[p]
                          , k = b.func;
                        if (k == null || k == i)
                            return b.name
                    }
                    return a
                }
                function Ba(i) {
                    var a = St.call(R, "placeholder") ? R : i;
                    return a.placeholder
                }
                function Ue() {
                    var i = R.iteratee || op;
                    return i = i === op ? uy : i,
                    arguments.length ? i(arguments[0], arguments[1]) : i
                }
                function Fl(i, a) {
                    var u = i.__data__;
                    return uA(a) ? u[typeof a == "string" ? "string" : "hash"] : u.map
                }
                function Vh(i) {
                    for (var a = en(i), u = a.length; u--; ) {
                        var p = a[u]
                          , b = i[p];
                        a[u] = [p, b, Yy(b)]
                    }
                    return a
                }
                function Us(i, a) {
                    var u = dS(i, a);
                    return cy(u) ? u : n
                }
                function nA(i) {
                    var a = St.call(i, ks)
                      , u = i[ks];
                    try {
                        i[ks] = n;
                        var p = !0
                    } catch {}
                    var b = yl.call(i);
                    return p && (a ? i[ks] = u : delete i[ks]),
                    b
                }
                var Wh = vh ? function(i) {
                    return i == null ? [] : (i = Nt(i),
                    xe(vh(i), function(a) {
                        return z0.call(i, a)
                    }))
                }
                : lp
                  , jy = vh ? function(i) {
                    for (var a = []; i; )
                        At(a, Wh(i)),
                        i = wl(i);
                    return a
                }
                : lp
                  , dn = _n;
                (wh && dn(new wh(new ArrayBuffer(1))) != Gn || dc && dn(new dc) != st || bh && dn(bh.resolve()) != Gi || Ca && dn(new Ca) != an || hc && dn(new hc) != oe) && (dn = function(i) {
                    var a = _n(i)
                      , u = a == yn ? i.constructor : n
                      , p = u ? Bs(u) : "";
                    if (p)
                        switch (p) {
                        case US:
                            return Gn;
                        case BS:
                            return st;
                        case FS:
                            return Gi;
                        case jS:
                            return an;
                        case qS:
                            return oe
                        }
                    return a
                }
                );
                function rA(i, a, u) {
                    for (var p = -1, b = u.length; ++p < b; ) {
                        var k = u[p]
                          , V = k.size;
                        switch (k.type) {
                        case "drop":
                            i += V;
                            break;
                        case "dropRight":
                            a -= V;
                            break;
                        case "take":
                            a = fn(a, i + V);
                            break;
                        case "takeRight":
                            i = Zt(i, a - V);
                            break
                        }
                    }
                    return {
                        start: i,
                        end: a
                    }
                }
                function iA(i) {
                    var a = i.match(Zd);
                    return a ? a[1].split(Kd) : []
                }
                function qy(i, a, u) {
                    a = rs(a, i);
                    for (var p = -1, b = a.length, k = !1; ++p < b; ) {
                        var V = Yr(a[p]);
                        if (!(k = i != null && u(i, V)))
                            break;
                        i = i[V]
                    }
                    return k || ++p != b ? k : (b = i == null ? 0 : i.length,
                    !!b && zl(b) && _i(V, b) && (Ze(i) || Fs(i)))
                }
                function sA(i) {
                    var a = i.length
                      , u = new i.constructor(a);
                    return a && typeof i[0] == "string" && St.call(i, "index") && (u.index = i.index,
                    u.input = i.input),
                    u
                }
                function Hy(i) {
                    return typeof i.constructor == "function" && !Ec(i) ? La(wl(i)) : {}
                }
                function aA(i, a, u) {
                    var p = i.constructor;
                    switch (a) {
                    case zn:
                        return Bh(i);
                    case we:
                    case De:
                        return new p(+i);
                    case Gn:
                        return HT(i, u);
                    case Zi:
                    case ui:
                    case ma:
                    case ga:
                    case Mo:
                    case Lo:
                    case Ki:
                    case ya:
                    case xs:
                        return Ay(i, u);
                    case st:
                        return new p;
                    case ct:
                    case Wn:
                        return new p(i);
                    case yr:
                        return YT(i);
                    case an:
                        return new p;
                    case Fr:
                        return VT(i)
                    }
                }
                function oA(i, a) {
                    var u = a.length;
                    if (!u)
                        return i;
                    var p = u - 1;
                    return a[p] = (u > 1 ? "& " : "") + a[p],
                    a = a.join(u > 2 ? ", " : " "),
                    i.replace(Gd, `{
/* [wrapped with ` + a + `] */
`)
                }
                function cA(i) {
                    return Ze(i) || Fs(i) || !!(G0 && i && i[G0])
                }
                function _i(i, a) {
                    var u = typeof i;
                    return a = a ?? W,
                    !!a && (u == "number" || u != "symbol" && Qd.test(i)) && i > -1 && i % 1 == 0 && i < a
                }
                function vn(i, a, u) {
                    if (!Ct(u))
                        return !1;
                    var p = typeof a;
                    return (p == "number" ? On(u) && _i(a, u.length) : p == "string" && a in u) ? br(u[a], i) : !1
                }
                function zh(i, a) {
                    if (Ze(i))
                        return !1;
                    var u = typeof i;
                    return u == "number" || u == "symbol" || u == "boolean" || i == null || Fn(i) ? !0 : Bo.test(i) || !Uo.test(i) || a != null && i in Nt(a)
                }
                function uA(i) {
                    var a = typeof i;
                    return a == "string" || a == "number" || a == "symbol" || a == "boolean" ? i !== "__proto__" : i === null
                }
                function Gh(i) {
                    var a = Bl(i)
                      , u = R[a];
                    if (typeof u != "function" || !(a in lt.prototype))
                        return !1;
                    if (i === u)
                        return !0;
                    var p = Yh(u);
                    return !!p && i === p[0]
                }
                function lA(i) {
                    return !!Y0 && Y0 in i
                }
                var fA = ml ? vi : fp;
                function Ec(i) {
                    var a = i && i.constructor
                      , u = typeof a == "function" && a.prototype || ka;
                    return i === u
                }
                function Yy(i) {
                    return i === i && !Ct(i)
                }
                function Vy(i, a) {
                    return function(u) {
                        return u == null ? !1 : u[i] === a && (a !== n || i in Nt(u))
                    }
                }
                function dA(i) {
                    var a = Vl(i, function(p) {
                        return u.size === d && u.clear(),
                        p
                    })
                      , u = a.cache;
                    return a
                }
                function hA(i, a) {
                    var u = i[1]
                      , p = a[1]
                      , b = u | p
                      , k = b < (N | m | K)
                      , V = p == K && u == M || p == K && u == _ && i[7].length <= a[8] || p == (K | _) && a[7].length <= a[8] && u == M;
                    if (!(k || V))
                        return i;
                    p & N && (i[2] = a[2],
                    b |= u & N ? 0 : g);
                    var Z = a[3];
                    if (Z) {
                        var ne = i[3];
                        i[3] = ne ? Iy(ne, Z, a[4]) : Z,
                        i[4] = ne ? Qi(i[3], h) : a[4]
                    }
                    return Z = a[5],
                    Z && (ne = i[5],
                    i[5] = ne ? Ny(ne, Z, a[6]) : Z,
                    i[6] = ne ? Qi(i[5], h) : a[6]),
                    Z = a[7],
                    Z && (i[7] = Z),
                    p & K && (i[8] = i[8] == null ? a[8] : fn(i[8], a[8])),
                    i[9] == null && (i[9] = a[9]),
                    i[0] = a[0],
                    i[1] = b,
                    i
                }
                function pA(i) {
                    var a = [];
                    if (i != null)
                        for (var u in Nt(i))
                            a.push(u);
                    return a
                }
                function mA(i) {
                    return yl.call(i)
                }
                function Wy(i, a, u) {
                    return a = Zt(a === n ? i.length - 1 : a, 0),
                    function() {
                        for (var p = arguments, b = -1, k = Zt(p.length - a, 0), V = ce(k); ++b < k; )
                            V[b] = p[a + b];
                        b = -1;
                        for (var Z = ce(a + 1); ++b < a; )
                            Z[b] = p[b];
                        return Z[a] = u(V),
                        pe(i, this, Z)
                    }
                }
                function zy(i, a) {
                    return a.length < 2 ? i : Ds(i, Qn(a, 0, -1))
                }
                function gA(i, a) {
                    for (var u = i.length, p = fn(a.length, u), b = An(i); p--; ) {
                        var k = a[p];
                        i[p] = _i(k, u) ? b[k] : n
                    }
                    return i
                }
                function Zh(i, a) {
                    if (!(a === "constructor" && typeof i[a] == "function") && a != "__proto__")
                        return i[a]
                }
                var Gy = Ky(yy)
                  , Sc = RS || function(i, a) {
                    return zt.setTimeout(i, a)
                }
                  , Kh = Ky(BT);
                function Zy(i, a, u) {
                    var p = a + "";
                    return Kh(i, oA(p, yA(iA(p), u)))
                }
                function Ky(i) {
                    var a = 0
                      , u = 0;
                    return function() {
                        var p = MS()
                          , b = F - (p - u);
                        if (u = p,
                        b > 0) {
                            if (++a >= C)
                                return arguments[0]
                        } else
                            a = 0;
                        return i.apply(n, arguments)
                    }
                }
                function jl(i, a) {
                    var u = -1
                      , p = i.length
                      , b = p - 1;
                    for (a = a === n ? p : a; ++u < a; ) {
                        var k = Ph(u, b)
                          , V = i[k];
                        i[k] = i[u],
                        i[u] = V
                    }
                    return i.length = a,
                    i
                }
                var Jy = dA(function(i) {
                    var a = [];
                    return i.charCodeAt(0) === 46 && a.push(""),
                    i.replace(Wd, function(u, p, b, k) {
                        a.push(b ? k.replace(qo, "$1") : p || u)
                    }),
                    a
                });
                function Yr(i) {
                    if (typeof i == "string" || Fn(i))
                        return i;
                    var a = i + "";
                    return a == "0" && 1 / i == -Y ? "-0" : a
                }
                function Bs(i) {
                    if (i != null) {
                        try {
                            return gl.call(i)
                        } catch {}
                        try {
                            return i + ""
                        } catch {}
                    }
                    return ""
                }
                function yA(i, a) {
                    return Oe(P, function(u) {
                        var p = "_." + u[0];
                        a & u[1] && !We(i, p) && i.push(p)
                    }),
                    i.sort()
                }
                function Xy(i) {
                    if (i instanceof lt)
                        return i.clone();
                    var a = new Jn(i.__wrapped__,i.__chain__);
                    return a.__actions__ = An(i.__actions__),
                    a.__index__ = i.__index__,
                    a.__values__ = i.__values__,
                    a
                }
                function _A(i, a, u) {
                    (u ? vn(i, a, u) : a === n) ? a = 1 : a = Zt(Xe(a), 0);
                    var p = i == null ? 0 : i.length;
                    if (!p || a < 1)
                        return [];
                    for (var b = 0, k = 0, V = ce(Sl(p / a)); b < p; )
                        V[k++] = Qn(i, b, b += a);
                    return V
                }
                function vA(i) {
                    for (var a = -1, u = i == null ? 0 : i.length, p = 0, b = []; ++a < u; ) {
                        var k = i[a];
                        k && (b[p++] = k)
                    }
                    return b
                }
                function wA() {
                    var i = arguments.length;
                    if (!i)
                        return [];
                    for (var a = ce(i - 1), u = arguments[0], p = i; p--; )
                        a[p - 1] = arguments[p];
                    return At(Ze(u) ? An(u) : [u], on(a, 1))
                }
                var bA = it(function(i, a) {
                    return Ft(i) ? yc(i, on(a, 1, Ft, !0)) : []
                })
                  , EA = it(function(i, a) {
                    var u = er(a);
                    return Ft(u) && (u = n),
                    Ft(i) ? yc(i, on(a, 1, Ft, !0), Ue(u, 2)) : []
                })
                  , SA = it(function(i, a) {
                    var u = er(a);
                    return Ft(u) && (u = n),
                    Ft(i) ? yc(i, on(a, 1, Ft, !0), n, u) : []
                });
                function TA(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    return p ? (a = u || a === n ? 1 : Xe(a),
                    Qn(i, a < 0 ? 0 : a, p)) : []
                }
                function AA(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    return p ? (a = u || a === n ? 1 : Xe(a),
                    a = p - a,
                    Qn(i, 0, a < 0 ? 0 : a)) : []
                }
                function OA(i, a) {
                    return i && i.length ? kl(i, Ue(a, 3), !0, !0) : []
                }
                function IA(i, a) {
                    return i && i.length ? kl(i, Ue(a, 3), !0) : []
                }
                function NA(i, a, u, p) {
                    var b = i == null ? 0 : i.length;
                    return b ? (u && typeof u != "number" && vn(i, a, u) && (u = 0,
                    p = b),
                    wT(i, a, u, p)) : []
                }
                function Qy(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    if (!p)
                        return -1;
                    var b = u == null ? 0 : Xe(u);
                    return b < 0 && (b = Zt(p + b, 0)),
                    dl(i, Ue(a, 3), b)
                }
                function e_(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    if (!p)
                        return -1;
                    var b = p - 1;
                    return u !== n && (b = Xe(u),
                    b = u < 0 ? Zt(p + b, 0) : fn(b, p - 1)),
                    dl(i, Ue(a, 3), b, !0)
                }
                function t_(i) {
                    var a = i == null ? 0 : i.length;
                    return a ? on(i, 1) : []
                }
                function xA(i) {
                    var a = i == null ? 0 : i.length;
                    return a ? on(i, Y) : []
                }
                function $A(i, a) {
                    var u = i == null ? 0 : i.length;
                    return u ? (a = a === n ? 1 : Xe(a),
                    on(i, a)) : []
                }
                function RA(i) {
                    for (var a = -1, u = i == null ? 0 : i.length, p = {}; ++a < u; ) {
                        var b = i[a];
                        p[b[0]] = b[1]
                    }
                    return p
                }
                function n_(i) {
                    return i && i.length ? i[0] : n
                }
                function PA(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    if (!p)
                        return -1;
                    var b = u == null ? 0 : Xe(u);
                    return b < 0 && (b = Zt(p + b, 0)),
                    xa(i, a, b)
                }
                function kA(i) {
                    var a = i == null ? 0 : i.length;
                    return a ? Qn(i, 0, -1) : []
                }
                var CA = it(function(i) {
                    var a = Ye(i, Dh);
                    return a.length && a[0] === i[0] ? Ih(a) : []
                })
                  , MA = it(function(i) {
                    var a = er(i)
                      , u = Ye(i, Dh);
                    return a === er(u) ? a = n : u.pop(),
                    u.length && u[0] === i[0] ? Ih(u, Ue(a, 2)) : []
                })
                  , LA = it(function(i) {
                    var a = er(i)
                      , u = Ye(i, Dh);
                    return a = typeof a == "function" ? a : n,
                    a && u.pop(),
                    u.length && u[0] === i[0] ? Ih(u, n, a) : []
                });
                function DA(i, a) {
                    return i == null ? "" : kS.call(i, a)
                }
                function er(i) {
                    var a = i == null ? 0 : i.length;
                    return a ? i[a - 1] : n
                }
                function UA(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    if (!p)
                        return -1;
                    var b = p;
                    return u !== n && (b = Xe(u),
                    b = b < 0 ? Zt(p + b, 0) : fn(b, p - 1)),
                    a === a ? yS(i, a, b) : dl(i, L0, b, !0)
                }
                function BA(i, a) {
                    return i && i.length ? hy(i, Xe(a)) : n
                }
                var FA = it(r_);
                function r_(i, a) {
                    return i && i.length && a && a.length ? Rh(i, a) : i
                }
                function jA(i, a, u) {
                    return i && i.length && a && a.length ? Rh(i, a, Ue(u, 2)) : i
                }
                function qA(i, a, u) {
                    return i && i.length && a && a.length ? Rh(i, a, n, u) : i
                }
                var HA = yi(function(i, a) {
                    var u = i == null ? 0 : i.length
                      , p = Sh(i, a);
                    return gy(i, Ye(a, function(b) {
                        return _i(b, u) ? +b : b
                    }).sort(Oy)),
                    p
                });
                function YA(i, a) {
                    var u = [];
                    if (!(i && i.length))
                        return u;
                    var p = -1
                      , b = []
                      , k = i.length;
                    for (a = Ue(a, 3); ++p < k; ) {
                        var V = i[p];
                        a(V, p, i) && (u.push(V),
                        b.push(p))
                    }
                    return gy(i, b),
                    u
                }
                function Jh(i) {
                    return i == null ? i : DS.call(i)
                }
                function VA(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    return p ? (u && typeof u != "number" && vn(i, a, u) ? (a = 0,
                    u = p) : (a = a == null ? 0 : Xe(a),
                    u = u === n ? p : Xe(u)),
                    Qn(i, a, u)) : []
                }
                function WA(i, a) {
                    return Pl(i, a)
                }
                function zA(i, a, u) {
                    return Ch(i, a, Ue(u, 2))
                }
                function GA(i, a) {
                    var u = i == null ? 0 : i.length;
                    if (u) {
                        var p = Pl(i, a);
                        if (p < u && br(i[p], a))
                            return p
                    }
                    return -1
                }
                function ZA(i, a) {
                    return Pl(i, a, !0)
                }
                function KA(i, a, u) {
                    return Ch(i, a, Ue(u, 2), !0)
                }
                function JA(i, a) {
                    var u = i == null ? 0 : i.length;
                    if (u) {
                        var p = Pl(i, a, !0) - 1;
                        if (br(i[p], a))
                            return p
                    }
                    return -1
                }
                function XA(i) {
                    return i && i.length ? _y(i) : []
                }
                function QA(i, a) {
                    return i && i.length ? _y(i, Ue(a, 2)) : []
                }
                function eO(i) {
                    var a = i == null ? 0 : i.length;
                    return a ? Qn(i, 1, a) : []
                }
                function tO(i, a, u) {
                    return i && i.length ? (a = u || a === n ? 1 : Xe(a),
                    Qn(i, 0, a < 0 ? 0 : a)) : []
                }
                function nO(i, a, u) {
                    var p = i == null ? 0 : i.length;
                    return p ? (a = u || a === n ? 1 : Xe(a),
                    a = p - a,
                    Qn(i, a < 0 ? 0 : a, p)) : []
                }
                function rO(i, a) {
                    return i && i.length ? kl(i, Ue(a, 3), !1, !0) : []
                }
                function iO(i, a) {
                    return i && i.length ? kl(i, Ue(a, 3)) : []
                }
                var sO = it(function(i) {
                    return ns(on(i, 1, Ft, !0))
                })
                  , aO = it(function(i) {
                    var a = er(i);
                    return Ft(a) && (a = n),
                    ns(on(i, 1, Ft, !0), Ue(a, 2))
                })
                  , oO = it(function(i) {
                    var a = er(i);
                    return a = typeof a == "function" ? a : n,
                    ns(on(i, 1, Ft, !0), n, a)
                });
                function cO(i) {
                    return i && i.length ? ns(i) : []
                }
                function uO(i, a) {
                    return i && i.length ? ns(i, Ue(a, 2)) : []
                }
                function lO(i, a) {
                    return a = typeof a == "function" ? a : n,
                    i && i.length ? ns(i, n, a) : []
                }
                function Xh(i) {
                    if (!(i && i.length))
                        return [];
                    var a = 0;
                    return i = xe(i, function(u) {
                        if (Ft(u))
                            return a = Zt(u.length, a),
                            !0
                    }),
                    mh(a, function(u) {
                        return Ye(i, dh(u))
                    })
                }
                function i_(i, a) {
                    if (!(i && i.length))
                        return [];
                    var u = Xh(i);
                    return a == null ? u : Ye(u, function(p) {
                        return pe(a, n, p)
                    })
                }
                var fO = it(function(i, a) {
                    return Ft(i) ? yc(i, a) : []
                })
                  , dO = it(function(i) {
                    return Lh(xe(i, Ft))
                })
                  , hO = it(function(i) {
                    var a = er(i);
                    return Ft(a) && (a = n),
                    Lh(xe(i, Ft), Ue(a, 2))
                })
                  , pO = it(function(i) {
                    var a = er(i);
                    return a = typeof a == "function" ? a : n,
                    Lh(xe(i, Ft), n, a)
                })
                  , mO = it(Xh);
                function gO(i, a) {
                    return Ey(i || [], a || [], gc)
                }
                function yO(i, a) {
                    return Ey(i || [], a || [], wc)
                }
                var _O = it(function(i) {
                    var a = i.length
                      , u = a > 1 ? i[a - 1] : n;
                    return u = typeof u == "function" ? (i.pop(),
                    u) : n,
                    i_(i, u)
                });
                function s_(i) {
                    var a = R(i);
                    return a.__chain__ = !0,
                    a
                }
                function vO(i, a) {
                    return a(i),
                    i
                }
                function ql(i, a) {
                    return a(i)
                }
                var wO = yi(function(i) {
                    var a = i.length
                      , u = a ? i[0] : 0
                      , p = this.__wrapped__
                      , b = function(k) {
                        return Sh(k, i)
                    };
                    return a > 1 || this.__actions__.length || !(p instanceof lt) || !_i(u) ? this.thru(b) : (p = p.slice(u, +u + (a ? 1 : 0)),
                    p.__actions__.push({
                        func: ql,
                        args: [b],
                        thisArg: n
                    }),
                    new Jn(p,this.__chain__).thru(function(k) {
                        return a && !k.length && k.push(n),
                        k
                    }))
                });
                function bO() {
                    return s_(this)
                }
                function EO() {
                    return new Jn(this.value(),this.__chain__)
                }
                function SO() {
                    this.__values__ === n && (this.__values__ = v_(this.value()));
                    var i = this.__index__ >= this.__values__.length
                      , a = i ? n : this.__values__[this.__index__++];
                    return {
                        done: i,
                        value: a
                    }
                }
                function TO() {
                    return this
                }
                function AO(i) {
                    for (var a, u = this; u instanceof Il; ) {
                        var p = Xy(u);
                        p.__index__ = 0,
                        p.__values__ = n,
                        a ? b.__wrapped__ = p : a = p;
                        var b = p;
                        u = u.__wrapped__
                    }
                    return b.__wrapped__ = i,
                    a
                }
                function OO() {
                    var i = this.__wrapped__;
                    if (i instanceof lt) {
                        var a = i;
                        return this.__actions__.length && (a = new lt(this)),
                        a = a.reverse(),
                        a.__actions__.push({
                            func: ql,
                            args: [Jh],
                            thisArg: n
                        }),
                        new Jn(a,this.__chain__)
                    }
                    return this.thru(Jh)
                }
                function IO() {
                    return by(this.__wrapped__, this.__actions__)
                }
                var NO = Cl(function(i, a, u) {
                    St.call(i, u) ? ++i[u] : mi(i, u, 1)
                });
                function xO(i, a, u) {
                    var p = Ze(i) ? Dt : vT;
                    return u && vn(i, a, u) && (a = n),
                    p(i, Ue(a, 3))
                }
                function $O(i, a) {
                    var u = Ze(i) ? xe : iy;
                    return u(i, Ue(a, 3))
                }
                var RO = Py(Qy)
                  , PO = Py(e_);
                function kO(i, a) {
                    return on(Hl(i, a), 1)
                }
                function CO(i, a) {
                    return on(Hl(i, a), Y)
                }
                function MO(i, a, u) {
                    return u = u === n ? 1 : Xe(u),
                    on(Hl(i, a), u)
                }
                function a_(i, a) {
                    var u = Ze(i) ? Oe : ts;
                    return u(i, Ue(a, 3))
                }
                function o_(i, a) {
                    var u = Ze(i) ? Et : ry;
                    return u(i, Ue(a, 3))
                }
                var LO = Cl(function(i, a, u) {
                    St.call(i, u) ? i[u].push(a) : mi(i, u, [a])
                });
                function DO(i, a, u, p) {
                    i = On(i) ? i : ja(i),
                    u = u && !p ? Xe(u) : 0;
                    var b = i.length;
                    return u < 0 && (u = Zt(b + u, 0)),
                    Gl(i) ? u <= b && i.indexOf(a, u) > -1 : !!b && xa(i, a, u) > -1
                }
                var UO = it(function(i, a, u) {
                    var p = -1
                      , b = typeof a == "function"
                      , k = On(i) ? ce(i.length) : [];
                    return ts(i, function(V) {
                        k[++p] = b ? pe(a, V, u) : _c(V, a, u)
                    }),
                    k
                })
                  , BO = Cl(function(i, a, u) {
                    mi(i, u, a)
                });
                function Hl(i, a) {
                    var u = Ze(i) ? Ye : ly;
                    return u(i, Ue(a, 3))
                }
                function FO(i, a, u, p) {
                    return i == null ? [] : (Ze(a) || (a = a == null ? [] : [a]),
                    u = p ? n : u,
                    Ze(u) || (u = u == null ? [] : [u]),
                    py(i, a, u))
                }
                var jO = Cl(function(i, a, u) {
                    i[u ? 0 : 1].push(a)
                }, function() {
                    return [[], []]
                });
                function qO(i, a, u) {
                    var p = Ze(i) ? Ut : U0
                      , b = arguments.length < 3;
                    return p(i, Ue(a, 4), u, b, ts)
                }
                function HO(i, a, u) {
                    var p = Ze(i) ? _r : U0
                      , b = arguments.length < 3;
                    return p(i, Ue(a, 4), u, b, ry)
                }
                function YO(i, a) {
                    var u = Ze(i) ? xe : iy;
                    return u(i, Wl(Ue(a, 3)))
                }
                function VO(i) {
                    var a = Ze(i) ? Q0 : DT;
                    return a(i)
                }
                function WO(i, a, u) {
                    (u ? vn(i, a, u) : a === n) ? a = 1 : a = Xe(a);
                    var p = Ze(i) ? pT : UT;
                    return p(i, a)
                }
                function zO(i) {
                    var a = Ze(i) ? mT : FT;
                    return a(i)
                }
                function GO(i) {
                    if (i == null)
                        return 0;
                    if (On(i))
                        return Gl(i) ? Ra(i) : i.length;
                    var a = dn(i);
                    return a == st || a == an ? i.size : xh(i).length
                }
                function ZO(i, a, u) {
                    var p = Ze(i) ? Qt : jT;
                    return u && vn(i, a, u) && (a = n),
                    p(i, Ue(a, 3))
                }
                var KO = it(function(i, a) {
                    if (i == null)
                        return [];
                    var u = a.length;
                    return u > 1 && vn(i, a[0], a[1]) ? a = [] : u > 2 && vn(a[0], a[1], a[2]) && (a = [a[0]]),
                    py(i, on(a, 1), [])
                })
                  , Yl = $S || function() {
                    return zt.Date.now()
                }
                ;
                function JO(i, a) {
                    if (typeof a != "function")
                        throw new Kn(c);
                    return i = Xe(i),
                    function() {
                        if (--i < 1)
                            return a.apply(this, arguments)
                    }
                }
                function c_(i, a, u) {
                    return a = u ? n : a,
                    a = i && a == null ? i.length : a,
                    gi(i, K, n, n, n, n, a)
                }
                function u_(i, a) {
                    var u;
                    if (typeof a != "function")
                        throw new Kn(c);
                    return i = Xe(i),
                    function() {
                        return --i > 0 && (u = a.apply(this, arguments)),
                        i <= 1 && (a = n),
                        u
                    }
                }
                var Qh = it(function(i, a, u) {
                    var p = N;
                    if (u.length) {
                        var b = Qi(u, Ba(Qh));
                        p |= U
                    }
                    return gi(i, p, a, u, b)
                })
                  , l_ = it(function(i, a, u) {
                    var p = N | m;
                    if (u.length) {
                        var b = Qi(u, Ba(l_));
                        p |= U
                    }
                    return gi(a, p, i, u, b)
                });
                function f_(i, a, u) {
                    a = u ? n : a;
                    var p = gi(i, M, n, n, n, n, n, a);
                    return p.placeholder = f_.placeholder,
                    p
                }
                function d_(i, a, u) {
                    a = u ? n : a;
                    var p = gi(i, G, n, n, n, n, n, a);
                    return p.placeholder = d_.placeholder,
                    p
                }
                function h_(i, a, u) {
                    var p, b, k, V, Z, ne, le = 0, fe = !1, he = !1, ve = !0;
                    if (typeof i != "function")
                        throw new Kn(c);
                    a = tr(a) || 0,
                    Ct(u) && (fe = !!u.leading,
                    he = "maxWait"in u,
                    k = he ? Zt(tr(u.maxWait) || 0, a) : k,
                    ve = "trailing"in u ? !!u.trailing : ve);
                    function Pe(jt) {
                        var Er = p
                          , bi = b;
                        return p = b = n,
                        le = jt,
                        V = i.apply(bi, Er),
                        V
                    }
                    function Fe(jt) {
                        return le = jt,
                        Z = Sc(ut, a),
                        fe ? Pe(jt) : V
                    }
                    function nt(jt) {
                        var Er = jt - ne
                          , bi = jt - le
                          , P_ = a - Er;
                        return he ? fn(P_, k - bi) : P_
                    }
                    function je(jt) {
                        var Er = jt - ne
                          , bi = jt - le;
                        return ne === n || Er >= a || Er < 0 || he && bi >= k
                    }
                    function ut() {
                        var jt = Yl();
                        if (je(jt))
                            return dt(jt);
                        Z = Sc(ut, nt(jt))
                    }
                    function dt(jt) {
                        return Z = n,
                        ve && p ? Pe(jt) : (p = b = n,
                        V)
                    }
                    function jn() {
                        Z !== n && Sy(Z),
                        le = 0,
                        p = ne = b = Z = n
                    }
                    function wn() {
                        return Z === n ? V : dt(Yl())
                    }
                    function qn() {
                        var jt = Yl()
                          , Er = je(jt);
                        if (p = arguments,
                        b = this,
                        ne = jt,
                        Er) {
                            if (Z === n)
                                return Fe(ne);
                            if (he)
                                return Sy(Z),
                                Z = Sc(ut, a),
                                Pe(ne)
                        }
                        return Z === n && (Z = Sc(ut, a)),
                        V
                    }
                    return qn.cancel = jn,
                    qn.flush = wn,
                    qn
                }
                var XO = it(function(i, a) {
                    return ny(i, 1, a)
                })
                  , QO = it(function(i, a, u) {
                    return ny(i, tr(a) || 0, u)
                });
                function eI(i) {
                    return gi(i, T)
                }
                function Vl(i, a) {
                    if (typeof i != "function" || a != null && typeof a != "function")
                        throw new Kn(c);
                    var u = function() {
                        var p = arguments
                          , b = a ? a.apply(this, p) : p[0]
                          , k = u.cache;
                        if (k.has(b))
                            return k.get(b);
                        var V = i.apply(this, p);
                        return u.cache = k.set(b, V) || k,
                        V
                    };
                    return u.cache = new (Vl.Cache || pi),
                    u
                }
                Vl.Cache = pi;
                function Wl(i) {
                    if (typeof i != "function")
                        throw new Kn(c);
                    return function() {
                        var a = arguments;
                        switch (a.length) {
                        case 0:
                            return !i.call(this);
                        case 1:
                            return !i.call(this, a[0]);
                        case 2:
                            return !i.call(this, a[0], a[1]);
                        case 3:
                            return !i.call(this, a[0], a[1], a[2])
                        }
                        return !i.apply(this, a)
                    }
                }
                function tI(i) {
                    return u_(2, i)
                }
                var nI = qT(function(i, a) {
                    a = a.length == 1 && Ze(a[0]) ? Ye(a[0], Un(Ue())) : Ye(on(a, 1), Un(Ue()));
                    var u = a.length;
                    return it(function(p) {
                        for (var b = -1, k = fn(p.length, u); ++b < k; )
                            p[b] = a[b].call(this, p[b]);
                        return pe(i, this, p)
                    })
                })
                  , ep = it(function(i, a) {
                    var u = Qi(a, Ba(ep));
                    return gi(i, U, n, a, u)
                })
                  , p_ = it(function(i, a) {
                    var u = Qi(a, Ba(p_));
                    return gi(i, D, n, a, u)
                })
                  , rI = yi(function(i, a) {
                    return gi(i, _, n, n, n, a)
                });
                function iI(i, a) {
                    if (typeof i != "function")
                        throw new Kn(c);
                    return a = a === n ? a : Xe(a),
                    it(i, a)
                }
                function sI(i, a) {
                    if (typeof i != "function")
                        throw new Kn(c);
                    return a = a == null ? 0 : Zt(Xe(a), 0),
                    it(function(u) {
                        var p = u[a]
                          , b = is(u, 0, a);
                        return p && At(b, p),
                        pe(i, this, b)
                    })
                }
                function aI(i, a, u) {
                    var p = !0
                      , b = !0;
                    if (typeof i != "function")
                        throw new Kn(c);
                    return Ct(u) && (p = "leading"in u ? !!u.leading : p,
                    b = "trailing"in u ? !!u.trailing : b),
                    h_(i, a, {
                        leading: p,
                        maxWait: a,
                        trailing: b
                    })
                }
                function oI(i) {
                    return c_(i, 1)
                }
                function cI(i, a) {
                    return ep(Uh(a), i)
                }
                function uI() {
                    if (!arguments.length)
                        return [];
                    var i = arguments[0];
                    return Ze(i) ? i : [i]
                }
                function lI(i) {
                    return Xn(i, $)
                }
                function fI(i, a) {
                    return a = typeof a == "function" ? a : n,
                    Xn(i, $, a)
                }
                function dI(i) {
                    return Xn(i, y | $)
                }
                function hI(i, a) {
                    return a = typeof a == "function" ? a : n,
                    Xn(i, y | $, a)
                }
                function pI(i, a) {
                    return a == null || ty(i, a, en(a))
                }
                function br(i, a) {
                    return i === a || i !== i && a !== a
                }
                var mI = Ul(Oh)
                  , gI = Ul(function(i, a) {
                    return i >= a
                })
                  , Fs = oy(function() {
                    return arguments
                }()) ? oy : function(i) {
                    return Bt(i) && St.call(i, "callee") && !z0.call(i, "callee")
                }
                  , Ze = ce.isArray
                  , yI = B ? Un(B) : AT;
                function On(i) {
                    return i != null && zl(i.length) && !vi(i)
                }
                function Ft(i) {
                    return Bt(i) && On(i)
                }
                function _I(i) {
                    return i === !0 || i === !1 || Bt(i) && _n(i) == we
                }
                var ss = PS || fp
                  , vI = z ? Un(z) : OT;
                function wI(i) {
                    return Bt(i) && i.nodeType === 1 && !Tc(i)
                }
                function bI(i) {
                    if (i == null)
                        return !0;
                    if (On(i) && (Ze(i) || typeof i == "string" || typeof i.splice == "function" || ss(i) || Fa(i) || Fs(i)))
                        return !i.length;
                    var a = dn(i);
                    if (a == st || a == an)
                        return !i.size;
                    if (Ec(i))
                        return !xh(i).length;
                    for (var u in i)
                        if (St.call(i, u))
                            return !1;
                    return !0
                }
                function EI(i, a) {
                    return vc(i, a)
                }
                function SI(i, a, u) {
                    u = typeof u == "function" ? u : n;
                    var p = u ? u(i, a) : n;
                    return p === n ? vc(i, a, n, u) : !!p
                }
                function tp(i) {
                    if (!Bt(i))
                        return !1;
                    var a = _n(i);
                    return a == tt || a == Re || typeof i.message == "string" && typeof i.name == "string" && !Tc(i)
                }
                function TI(i) {
                    return typeof i == "number" && Z0(i)
                }
                function vi(i) {
                    if (!Ct(i))
                        return !1;
                    var a = _n(i);
                    return a == vt || a == bt || a == ye || a == Ns
                }
                function m_(i) {
                    return typeof i == "number" && i == Xe(i)
                }
                function zl(i) {
                    return typeof i == "number" && i > -1 && i % 1 == 0 && i <= W
                }
                function Ct(i) {
                    var a = typeof i;
                    return i != null && (a == "object" || a == "function")
                }
                function Bt(i) {
                    return i != null && typeof i == "object"
                }
                var g_ = re ? Un(re) : NT;
                function AI(i, a) {
                    return i === a || Nh(i, a, Vh(a))
                }
                function OI(i, a, u) {
                    return u = typeof u == "function" ? u : n,
                    Nh(i, a, Vh(a), u)
                }
                function II(i) {
                    return y_(i) && i != +i
                }
                function NI(i) {
                    if (fA(i))
                        throw new Ge(o);
                    return cy(i)
                }
                function xI(i) {
                    return i === null
                }
                function $I(i) {
                    return i == null
                }
                function y_(i) {
                    return typeof i == "number" || Bt(i) && _n(i) == ct
                }
                function Tc(i) {
                    if (!Bt(i) || _n(i) != yn)
                        return !1;
                    var a = wl(i);
                    if (a === null)
                        return !0;
                    var u = St.call(a, "constructor") && a.constructor;
                    return typeof u == "function" && u instanceof u && gl.call(u) == OS
                }
                var np = ie ? Un(ie) : xT;
                function RI(i) {
                    return m_(i) && i >= -W && i <= W
                }
                var __ = de ? Un(de) : $T;
                function Gl(i) {
                    return typeof i == "string" || !Ze(i) && Bt(i) && _n(i) == Wn
                }
                function Fn(i) {
                    return typeof i == "symbol" || Bt(i) && _n(i) == Fr
                }
                var Fa = $e ? Un($e) : RT;
                function PI(i) {
                    return i === n
                }
                function kI(i) {
                    return Bt(i) && dn(i) == oe
                }
                function CI(i) {
                    return Bt(i) && _n(i) == Be
                }
                var MI = Ul($h)
                  , LI = Ul(function(i, a) {
                    return i <= a
                });
                function v_(i) {
                    if (!i)
                        return [];
                    if (On(i))
                        return Gl(i) ? vr(i) : An(i);
                    if (fc && i[fc])
                        return pS(i[fc]());
                    var a = dn(i)
                      , u = a == st ? yh : a == an ? hl : ja;
                    return u(i)
                }
                function wi(i) {
                    if (!i)
                        return i === 0 ? i : 0;
                    if (i = tr(i),
                    i === Y || i === -Y) {
                        var a = i < 0 ? -1 : 1;
                        return a * te
                    }
                    return i === i ? i : 0
                }
                function Xe(i) {
                    var a = wi(i)
                      , u = a % 1;
                    return a === a ? u ? a - u : a : 0
                }
                function w_(i) {
                    return i ? Ls(Xe(i), 0, H) : 0
                }
                function tr(i) {
                    if (typeof i == "number")
                        return i;
                    if (Fn(i))
                        return J;
                    if (Ct(i)) {
                        var a = typeof i.valueOf == "function" ? i.valueOf() : i;
                        i = Ct(a) ? a + "" : a
                    }
                    if (typeof i != "string")
                        return i === 0 ? i : +i;
                    i = B0(i);
                    var u = Qu.test(i);
                    return u || _a.test(i) ? fh(i.slice(2), u ? 2 : 8) : Xd.test(i) ? J : +i
                }
                function b_(i) {
                    return Hr(i, In(i))
                }
                function DI(i) {
                    return i ? Ls(Xe(i), -W, W) : i === 0 ? i : 0
                }
                function wt(i) {
                    return i == null ? "" : Bn(i)
                }
                var UI = Da(function(i, a) {
                    if (Ec(a) || On(a)) {
                        Hr(a, en(a), i);
                        return
                    }
                    for (var u in a)
                        St.call(a, u) && gc(i, u, a[u])
                })
                  , E_ = Da(function(i, a) {
                    Hr(a, In(a), i)
                })
                  , Zl = Da(function(i, a, u, p) {
                    Hr(a, In(a), i, p)
                })
                  , BI = Da(function(i, a, u, p) {
                    Hr(a, en(a), i, p)
                })
                  , FI = yi(Sh);
                function jI(i, a) {
                    var u = La(i);
                    return a == null ? u : ey(u, a)
                }
                var qI = it(function(i, a) {
                    i = Nt(i);
                    var u = -1
                      , p = a.length
                      , b = p > 2 ? a[2] : n;
                    for (b && vn(a[0], a[1], b) && (p = 1); ++u < p; )
                        for (var k = a[u], V = In(k), Z = -1, ne = V.length; ++Z < ne; ) {
                            var le = V[Z]
                              , fe = i[le];
                            (fe === n || br(fe, ka[le]) && !St.call(i, le)) && (i[le] = k[le])
                        }
                    return i
                })
                  , HI = it(function(i) {
                    return i.push(n, By),
                    pe(S_, n, i)
                });
                function YI(i, a) {
                    return uc(i, Ue(a, 3), qr)
                }
                function VI(i, a) {
                    return uc(i, Ue(a, 3), Ah)
                }
                function WI(i, a) {
                    return i == null ? i : Th(i, Ue(a, 3), In)
                }
                function zI(i, a) {
                    return i == null ? i : sy(i, Ue(a, 3), In)
                }
                function GI(i, a) {
                    return i && qr(i, Ue(a, 3))
                }
                function ZI(i, a) {
                    return i && Ah(i, Ue(a, 3))
                }
                function KI(i) {
                    return i == null ? [] : $l(i, en(i))
                }
                function JI(i) {
                    return i == null ? [] : $l(i, In(i))
                }
                function rp(i, a, u) {
                    var p = i == null ? n : Ds(i, a);
                    return p === n ? u : p
                }
                function XI(i, a) {
                    return i != null && qy(i, a, bT)
                }
                function ip(i, a) {
                    return i != null && qy(i, a, ET)
                }
                var QI = Cy(function(i, a, u) {
                    a != null && typeof a.toString != "function" && (a = yl.call(a)),
                    i[a] = u
                }, ap(Nn))
                  , eN = Cy(function(i, a, u) {
                    a != null && typeof a.toString != "function" && (a = yl.call(a)),
                    St.call(i, a) ? i[a].push(u) : i[a] = [u]
                }, Ue)
                  , tN = it(_c);
                function en(i) {
                    return On(i) ? X0(i) : xh(i)
                }
                function In(i) {
                    return On(i) ? X0(i, !0) : PT(i)
                }
                function nN(i, a) {
                    var u = {};
                    return a = Ue(a, 3),
                    qr(i, function(p, b, k) {
                        mi(u, a(p, b, k), p)
                    }),
                    u
                }
                function rN(i, a) {
                    var u = {};
                    return a = Ue(a, 3),
                    qr(i, function(p, b, k) {
                        mi(u, b, a(p, b, k))
                    }),
                    u
                }
                var iN = Da(function(i, a, u) {
                    Rl(i, a, u)
                })
                  , S_ = Da(function(i, a, u, p) {
                    Rl(i, a, u, p)
                })
                  , sN = yi(function(i, a) {
                    var u = {};
                    if (i == null)
                        return u;
                    var p = !1;
                    a = Ye(a, function(k) {
                        return k = rs(k, i),
                        p || (p = k.length > 1),
                        k
                    }),
                    Hr(i, Hh(i), u),
                    p && (u = Xn(u, y | I | $, QT));
                    for (var b = a.length; b--; )
                        Mh(u, a[b]);
                    return u
                });
                function aN(i, a) {
                    return T_(i, Wl(Ue(a)))
                }
                var oN = yi(function(i, a) {
                    return i == null ? {} : CT(i, a)
                });
                function T_(i, a) {
                    if (i == null)
                        return {};
                    var u = Ye(Hh(i), function(p) {
                        return [p]
                    });
                    return a = Ue(a),
                    my(i, u, function(p, b) {
                        return a(p, b[0])
                    })
                }
                function cN(i, a, u) {
                    a = rs(a, i);
                    var p = -1
                      , b = a.length;
                    for (b || (b = 1,
                    i = n); ++p < b; ) {
                        var k = i == null ? n : i[Yr(a[p])];
                        k === n && (p = b,
                        k = u),
                        i = vi(k) ? k.call(i) : k
                    }
                    return i
                }
                function uN(i, a, u) {
                    return i == null ? i : wc(i, a, u)
                }
                function lN(i, a, u, p) {
                    return p = typeof p == "function" ? p : n,
                    i == null ? i : wc(i, a, u, p)
                }
                var A_ = Dy(en)
                  , O_ = Dy(In);
                function fN(i, a, u) {
                    var p = Ze(i)
                      , b = p || ss(i) || Fa(i);
                    if (a = Ue(a, 4),
                    u == null) {
                        var k = i && i.constructor;
                        b ? u = p ? new k : [] : Ct(i) ? u = vi(k) ? La(wl(i)) : {} : u = {}
                    }
                    return (b ? Oe : qr)(i, function(V, Z, ne) {
                        return a(u, V, Z, ne)
                    }),
                    u
                }
                function dN(i, a) {
                    return i == null ? !0 : Mh(i, a)
                }
                function hN(i, a, u) {
                    return i == null ? i : wy(i, a, Uh(u))
                }
                function pN(i, a, u, p) {
                    return p = typeof p == "function" ? p : n,
                    i == null ? i : wy(i, a, Uh(u), p)
                }
                function ja(i) {
                    return i == null ? [] : gh(i, en(i))
                }
                function mN(i) {
                    return i == null ? [] : gh(i, In(i))
                }
                function gN(i, a, u) {
                    return u === n && (u = a,
                    a = n),
                    u !== n && (u = tr(u),
                    u = u === u ? u : 0),
                    a !== n && (a = tr(a),
                    a = a === a ? a : 0),
                    Ls(tr(i), a, u)
                }
                function yN(i, a, u) {
                    return a = wi(a),
                    u === n ? (u = a,
                    a = 0) : u = wi(u),
                    i = tr(i),
                    ST(i, a, u)
                }
                function _N(i, a, u) {
                    if (u && typeof u != "boolean" && vn(i, a, u) && (a = u = n),
                    u === n && (typeof a == "boolean" ? (u = a,
                    a = n) : typeof i == "boolean" && (u = i,
                    i = n)),
                    i === n && a === n ? (i = 0,
                    a = 1) : (i = wi(i),
                    a === n ? (a = i,
                    i = 0) : a = wi(a)),
                    i > a) {
                        var p = i;
                        i = a,
                        a = p
                    }
                    if (u || i % 1 || a % 1) {
                        var b = K0();
                        return fn(i + b * (a - i + lh("1e-" + ((b + "").length - 1))), a)
                    }
                    return Ph(i, a)
                }
                var vN = Ua(function(i, a, u) {
                    return a = a.toLowerCase(),
                    i + (u ? I_(a) : a)
                });
                function I_(i) {
                    return sp(wt(i).toLowerCase())
                }
                function N_(i) {
                    return i = wt(i),
                    i && i.replace(eh, uS).replace(uh, "")
                }
                function wN(i, a, u) {
                    i = wt(i),
                    a = Bn(a);
                    var p = i.length;
                    u = u === n ? p : Ls(Xe(u), 0, p);
                    var b = u;
                    return u -= a.length,
                    u >= 0 && i.slice(u, b) == a
                }
                function bN(i) {
                    return i = wt(i),
                    i && Hd.test(i) ? i.replace(Do, lS) : i
                }
                function EN(i) {
                    return i = wt(i),
                    i && zd.test(i) ? i.replace(Fo, "\\$&") : i
                }
                var SN = Ua(function(i, a, u) {
                    return i + (u ? "-" : "") + a.toLowerCase()
                })
                  , TN = Ua(function(i, a, u) {
                    return i + (u ? " " : "") + a.toLowerCase()
                })
                  , AN = Ry("toLowerCase");
                function ON(i, a, u) {
                    i = wt(i),
                    a = Xe(a);
                    var p = a ? Ra(i) : 0;
                    if (!a || p >= a)
                        return i;
                    var b = (a - p) / 2;
                    return Dl(Tl(b), u) + i + Dl(Sl(b), u)
                }
                function IN(i, a, u) {
                    i = wt(i),
                    a = Xe(a);
                    var p = a ? Ra(i) : 0;
                    return a && p < a ? i + Dl(a - p, u) : i
                }
                function NN(i, a, u) {
                    i = wt(i),
                    a = Xe(a);
                    var p = a ? Ra(i) : 0;
                    return a && p < a ? Dl(a - p, u) + i : i
                }
                function xN(i, a, u) {
                    return u || a == null ? a = 0 : a && (a = +a),
                    LS(wt(i).replace(jo, ""), a || 0)
                }
                function $N(i, a, u) {
                    return (u ? vn(i, a, u) : a === n) ? a = 1 : a = Xe(a),
                    kh(wt(i), a)
                }
                function RN() {
                    var i = arguments
                      , a = wt(i[0]);
                    return i.length < 3 ? a : a.replace(i[1], i[2])
                }
                var PN = Ua(function(i, a, u) {
                    return i + (u ? "_" : "") + a.toLowerCase()
                });
                function kN(i, a, u) {
                    return u && typeof u != "number" && vn(i, a, u) && (a = u = n),
                    u = u === n ? H : u >>> 0,
                    u ? (i = wt(i),
                    i && (typeof a == "string" || a != null && !np(a)) && (a = Bn(a),
                    !a && $a(i)) ? is(vr(i), 0, u) : i.split(a, u)) : []
                }
                var CN = Ua(function(i, a, u) {
                    return i + (u ? " " : "") + sp(a)
                });
                function MN(i, a, u) {
                    return i = wt(i),
                    u = u == null ? 0 : Ls(Xe(u), 0, i.length),
                    a = Bn(a),
                    i.slice(u, u + a.length) == a
                }
                function LN(i, a, u) {
                    var p = R.templateSettings;
                    u && vn(i, a, u) && (a = n),
                    i = wt(i),
                    a = Zl({}, a, p, Uy);
                    var b = Zl({}, a.imports, p.imports, Uy), k = en(b), V = gh(b, k), Z, ne, le = 0, fe = a.interpolate || Ji, he = "__p += '", ve = _h((a.escape || Ji).source + "|" + fe.source + "|" + (fe === Ku ? Ho : Ji).source + "|" + (a.evaluate || Ji).source + "|$", "g"), Pe = "//# sourceURL=" + (St.call(a, "sourceURL") ? (a.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ll + "]") + `
`;
                    i.replace(ve, function(je, ut, dt, jn, wn, qn) {
                        return dt || (dt = jn),
                        he += i.slice(le, qn).replace(th, fS),
                        ut && (Z = !0,
                        he += `' +
__e(` + ut + `) +
'`),
                        wn && (ne = !0,
                        he += `';
` + wn + `;
__p += '`),
                        dt && (he += `' +
((__t = (` + dt + `)) == null ? '' : __t) +
'`),
                        le = qn + je.length,
                        je
                    }),
                    he += `';
`;
                    var Fe = St.call(a, "variable") && a.variable;
                    if (!Fe)
                        he = `with (obj) {
` + he + `
}
`;
                    else if (Jd.test(Fe))
                        throw new Ge(l);
                    he = (ne ? he.replace(Wu, "") : he).replace(qd, "$1").replace(zu, "$1;"),
                    he = "function(" + (Fe || "obj") + `) {
` + (Fe ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Z ? ", __e = _.escape" : "") + (ne ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + he + `return __p
}`;
                    var nt = $_(function() {
                        return _t(k, Pe + "return " + he).apply(n, V)
                    });
                    if (nt.source = he,
                    tp(nt))
                        throw nt;
                    return nt
                }
                function DN(i) {
                    return wt(i).toLowerCase()
                }
                function UN(i) {
                    return wt(i).toUpperCase()
                }
                function BN(i, a, u) {
                    if (i = wt(i),
                    i && (u || a === n))
                        return B0(i);
                    if (!i || !(a = Bn(a)))
                        return i;
                    var p = vr(i)
                      , b = vr(a)
                      , k = F0(p, b)
                      , V = j0(p, b) + 1;
                    return is(p, k, V).join("")
                }
                function FN(i, a, u) {
                    if (i = wt(i),
                    i && (u || a === n))
                        return i.slice(0, H0(i) + 1);
                    if (!i || !(a = Bn(a)))
                        return i;
                    var p = vr(i)
                      , b = j0(p, vr(a)) + 1;
                    return is(p, 0, b).join("")
                }
                function jN(i, a, u) {
                    if (i = wt(i),
                    i && (u || a === n))
                        return i.replace(jo, "");
                    if (!i || !(a = Bn(a)))
                        return i;
                    var p = vr(i)
                      , b = F0(p, vr(a));
                    return is(p, b).join("")
                }
                function qN(i, a) {
                    var u = S
                      , p = q;
                    if (Ct(a)) {
                        var b = "separator"in a ? a.separator : b;
                        u = "length"in a ? Xe(a.length) : u,
                        p = "omission"in a ? Bn(a.omission) : p
                    }
                    i = wt(i);
                    var k = i.length;
                    if ($a(i)) {
                        var V = vr(i);
                        k = V.length
                    }
                    if (u >= k)
                        return i;
                    var Z = u - Ra(p);
                    if (Z < 1)
                        return p;
                    var ne = V ? is(V, 0, Z).join("") : i.slice(0, Z);
                    if (b === n)
                        return ne + p;
                    if (V && (Z += ne.length - Z),
                    np(b)) {
                        if (i.slice(Z).search(b)) {
                            var le, fe = ne;
                            for (b.global || (b = _h(b.source, wt(Xu.exec(b)) + "g")),
                            b.lastIndex = 0; le = b.exec(fe); )
                                var he = le.index;
                            ne = ne.slice(0, he === n ? Z : he)
                        }
                    } else if (i.indexOf(Bn(b), Z) != Z) {
                        var ve = ne.lastIndexOf(b);
                        ve > -1 && (ne = ne.slice(0, ve))
                    }
                    return ne + p
                }
                function HN(i) {
                    return i = wt(i),
                    i && Zu.test(i) ? i.replace(Gu, _S) : i
                }
                var YN = Ua(function(i, a, u) {
                    return i + (u ? " " : "") + a.toUpperCase()
                })
                  , sp = Ry("toUpperCase");
                function x_(i, a, u) {
                    return i = wt(i),
                    a = u ? n : a,
                    a === n ? hS(i) ? bS(i) : Na(i) : i.match(a) || []
                }
                var $_ = it(function(i, a) {
                    try {
                        return pe(i, n, a)
                    } catch (u) {
                        return tp(u) ? u : new Ge(u)
                    }
                })
                  , VN = yi(function(i, a) {
                    return Oe(a, function(u) {
                        u = Yr(u),
                        mi(i, u, Qh(i[u], i))
                    }),
                    i
                });
                function WN(i) {
                    var a = i == null ? 0 : i.length
                      , u = Ue();
                    return i = a ? Ye(i, function(p) {
                        if (typeof p[1] != "function")
                            throw new Kn(c);
                        return [u(p[0]), p[1]]
                    }) : [],
                    it(function(p) {
                        for (var b = -1; ++b < a; ) {
                            var k = i[b];
                            if (pe(k[0], this, p))
                                return pe(k[1], this, p)
                        }
                    })
                }
                function zN(i) {
                    return _T(Xn(i, y))
                }
                function ap(i) {
                    return function() {
                        return i
                    }
                }
                function GN(i, a) {
                    return i == null || i !== i ? a : i
                }
                var ZN = ky()
                  , KN = ky(!0);
                function Nn(i) {
                    return i
                }
                function op(i) {
                    return uy(typeof i == "function" ? i : Xn(i, y))
                }
                function JN(i) {
                    return fy(Xn(i, y))
                }
                function XN(i, a) {
                    return dy(i, Xn(a, y))
                }
                var QN = it(function(i, a) {
                    return function(u) {
                        return _c(u, i, a)
                    }
                })
                  , ex = it(function(i, a) {
                    return function(u) {
                        return _c(i, u, a)
                    }
                });
                function cp(i, a, u) {
                    var p = en(a)
                      , b = $l(a, p);
                    u == null && !(Ct(a) && (b.length || !p.length)) && (u = a,
                    a = i,
                    i = this,
                    b = $l(a, en(a)));
                    var k = !(Ct(u) && "chain"in u) || !!u.chain
                      , V = vi(i);
                    return Oe(b, function(Z) {
                        var ne = a[Z];
                        i[Z] = ne,
                        V && (i.prototype[Z] = function() {
                            var le = this.__chain__;
                            if (k || le) {
                                var fe = i(this.__wrapped__)
                                  , he = fe.__actions__ = An(this.__actions__);
                                return he.push({
                                    func: ne,
                                    args: arguments,
                                    thisArg: i
                                }),
                                fe.__chain__ = le,
                                fe
                            }
                            return ne.apply(i, At([this.value()], arguments))
                        }
                        )
                    }),
                    i
                }
                function tx() {
                    return zt._ === this && (zt._ = IS),
                    this
                }
                function up() {}
                function nx(i) {
                    return i = Xe(i),
                    it(function(a) {
                        return hy(a, i)
                    })
                }
                var rx = Fh(Ye)
                  , ix = Fh(Dt)
                  , sx = Fh(Qt);
                function R_(i) {
                    return zh(i) ? dh(Yr(i)) : MT(i)
                }
                function ax(i) {
                    return function(a) {
                        return i == null ? n : Ds(i, a)
                    }
                }
                var ox = My()
                  , cx = My(!0);
                function lp() {
                    return []
                }
                function fp() {
                    return !1
                }
                function ux() {
                    return {}
                }
                function lx() {
                    return ""
                }
                function fx() {
                    return !0
                }
                function dx(i, a) {
                    if (i = Xe(i),
                    i < 1 || i > W)
                        return [];
                    var u = H
                      , p = fn(i, H);
                    a = Ue(a),
                    i -= H;
                    for (var b = mh(p, a); ++u < i; )
                        a(u);
                    return b
                }
                function hx(i) {
                    return Ze(i) ? Ye(i, Yr) : Fn(i) ? [i] : An(Jy(wt(i)))
                }
                function px(i) {
                    var a = ++AS;
                    return wt(i) + a
                }
                var mx = Ll(function(i, a) {
                    return i + a
                }, 0)
                  , gx = jh("ceil")
                  , yx = Ll(function(i, a) {
                    return i / a
                }, 1)
                  , _x = jh("floor");
                function vx(i) {
                    return i && i.length ? xl(i, Nn, Oh) : n
                }
                function wx(i, a) {
                    return i && i.length ? xl(i, Ue(a, 2), Oh) : n
                }
                function bx(i) {
                    return D0(i, Nn)
                }
                function Ex(i, a) {
                    return D0(i, Ue(a, 2))
                }
                function Sx(i) {
                    return i && i.length ? xl(i, Nn, $h) : n
                }
                function Tx(i, a) {
                    return i && i.length ? xl(i, Ue(a, 2), $h) : n
                }
                var Ax = Ll(function(i, a) {
                    return i * a
                }, 1)
                  , Ox = jh("round")
                  , Ix = Ll(function(i, a) {
                    return i - a
                }, 0);
                function Nx(i) {
                    return i && i.length ? ph(i, Nn) : 0
                }
                function xx(i, a) {
                    return i && i.length ? ph(i, Ue(a, 2)) : 0
                }
                return R.after = JO,
                R.ary = c_,
                R.assign = UI,
                R.assignIn = E_,
                R.assignInWith = Zl,
                R.assignWith = BI,
                R.at = FI,
                R.before = u_,
                R.bind = Qh,
                R.bindAll = VN,
                R.bindKey = l_,
                R.castArray = uI,
                R.chain = s_,
                R.chunk = _A,
                R.compact = vA,
                R.concat = wA,
                R.cond = WN,
                R.conforms = zN,
                R.constant = ap,
                R.countBy = NO,
                R.create = jI,
                R.curry = f_,
                R.curryRight = d_,
                R.debounce = h_,
                R.defaults = qI,
                R.defaultsDeep = HI,
                R.defer = XO,
                R.delay = QO,
                R.difference = bA,
                R.differenceBy = EA,
                R.differenceWith = SA,
                R.drop = TA,
                R.dropRight = AA,
                R.dropRightWhile = OA,
                R.dropWhile = IA,
                R.fill = NA,
                R.filter = $O,
                R.flatMap = kO,
                R.flatMapDeep = CO,
                R.flatMapDepth = MO,
                R.flatten = t_,
                R.flattenDeep = xA,
                R.flattenDepth = $A,
                R.flip = eI,
                R.flow = ZN,
                R.flowRight = KN,
                R.fromPairs = RA,
                R.functions = KI,
                R.functionsIn = JI,
                R.groupBy = LO,
                R.initial = kA,
                R.intersection = CA,
                R.intersectionBy = MA,
                R.intersectionWith = LA,
                R.invert = QI,
                R.invertBy = eN,
                R.invokeMap = UO,
                R.iteratee = op,
                R.keyBy = BO,
                R.keys = en,
                R.keysIn = In,
                R.map = Hl,
                R.mapKeys = nN,
                R.mapValues = rN,
                R.matches = JN,
                R.matchesProperty = XN,
                R.memoize = Vl,
                R.merge = iN,
                R.mergeWith = S_,
                R.method = QN,
                R.methodOf = ex,
                R.mixin = cp,
                R.negate = Wl,
                R.nthArg = nx,
                R.omit = sN,
                R.omitBy = aN,
                R.once = tI,
                R.orderBy = FO,
                R.over = rx,
                R.overArgs = nI,
                R.overEvery = ix,
                R.overSome = sx,
                R.partial = ep,
                R.partialRight = p_,
                R.partition = jO,
                R.pick = oN,
                R.pickBy = T_,
                R.property = R_,
                R.propertyOf = ax,
                R.pull = FA,
                R.pullAll = r_,
                R.pullAllBy = jA,
                R.pullAllWith = qA,
                R.pullAt = HA,
                R.range = ox,
                R.rangeRight = cx,
                R.rearg = rI,
                R.reject = YO,
                R.remove = YA,
                R.rest = iI,
                R.reverse = Jh,
                R.sampleSize = WO,
                R.set = uN,
                R.setWith = lN,
                R.shuffle = zO,
                R.slice = VA,
                R.sortBy = KO,
                R.sortedUniq = XA,
                R.sortedUniqBy = QA,
                R.split = kN,
                R.spread = sI,
                R.tail = eO,
                R.take = tO,
                R.takeRight = nO,
                R.takeRightWhile = rO,
                R.takeWhile = iO,
                R.tap = vO,
                R.throttle = aI,
                R.thru = ql,
                R.toArray = v_,
                R.toPairs = A_,
                R.toPairsIn = O_,
                R.toPath = hx,
                R.toPlainObject = b_,
                R.transform = fN,
                R.unary = oI,
                R.union = sO,
                R.unionBy = aO,
                R.unionWith = oO,
                R.uniq = cO,
                R.uniqBy = uO,
                R.uniqWith = lO,
                R.unset = dN,
                R.unzip = Xh,
                R.unzipWith = i_,
                R.update = hN,
                R.updateWith = pN,
                R.values = ja,
                R.valuesIn = mN,
                R.without = fO,
                R.words = x_,
                R.wrap = cI,
                R.xor = dO,
                R.xorBy = hO,
                R.xorWith = pO,
                R.zip = mO,
                R.zipObject = gO,
                R.zipObjectDeep = yO,
                R.zipWith = _O,
                R.entries = A_,
                R.entriesIn = O_,
                R.extend = E_,
                R.extendWith = Zl,
                cp(R, R),
                R.add = mx,
                R.attempt = $_,
                R.camelCase = vN,
                R.capitalize = I_,
                R.ceil = gx,
                R.clamp = gN,
                R.clone = lI,
                R.cloneDeep = dI,
                R.cloneDeepWith = hI,
                R.cloneWith = fI,
                R.conformsTo = pI,
                R.deburr = N_,
                R.defaultTo = GN,
                R.divide = yx,
                R.endsWith = wN,
                R.eq = br,
                R.escape = bN,
                R.escapeRegExp = EN,
                R.every = xO,
                R.find = RO,
                R.findIndex = Qy,
                R.findKey = YI,
                R.findLast = PO,
                R.findLastIndex = e_,
                R.findLastKey = VI,
                R.floor = _x,
                R.forEach = a_,
                R.forEachRight = o_,
                R.forIn = WI,
                R.forInRight = zI,
                R.forOwn = GI,
                R.forOwnRight = ZI,
                R.get = rp,
                R.gt = mI,
                R.gte = gI,
                R.has = XI,
                R.hasIn = ip,
                R.head = n_,
                R.identity = Nn,
                R.includes = DO,
                R.indexOf = PA,
                R.inRange = yN,
                R.invoke = tN,
                R.isArguments = Fs,
                R.isArray = Ze,
                R.isArrayBuffer = yI,
                R.isArrayLike = On,
                R.isArrayLikeObject = Ft,
                R.isBoolean = _I,
                R.isBuffer = ss,
                R.isDate = vI,
                R.isElement = wI,
                R.isEmpty = bI,
                R.isEqual = EI,
                R.isEqualWith = SI,
                R.isError = tp,
                R.isFinite = TI,
                R.isFunction = vi,
                R.isInteger = m_,
                R.isLength = zl,
                R.isMap = g_,
                R.isMatch = AI,
                R.isMatchWith = OI,
                R.isNaN = II,
                R.isNative = NI,
                R.isNil = $I,
                R.isNull = xI,
                R.isNumber = y_,
                R.isObject = Ct,
                R.isObjectLike = Bt,
                R.isPlainObject = Tc,
                R.isRegExp = np,
                R.isSafeInteger = RI,
                R.isSet = __,
                R.isString = Gl,
                R.isSymbol = Fn,
                R.isTypedArray = Fa,
                R.isUndefined = PI,
                R.isWeakMap = kI,
                R.isWeakSet = CI,
                R.join = DA,
                R.kebabCase = SN,
                R.last = er,
                R.lastIndexOf = UA,
                R.lowerCase = TN,
                R.lowerFirst = AN,
                R.lt = MI,
                R.lte = LI,
                R.max = vx,
                R.maxBy = wx,
                R.mean = bx,
                R.meanBy = Ex,
                R.min = Sx,
                R.minBy = Tx,
                R.stubArray = lp,
                R.stubFalse = fp,
                R.stubObject = ux,
                R.stubString = lx,
                R.stubTrue = fx,
                R.multiply = Ax,
                R.nth = BA,
                R.noConflict = tx,
                R.noop = up,
                R.now = Yl,
                R.pad = ON,
                R.padEnd = IN,
                R.padStart = NN,
                R.parseInt = xN,
                R.random = _N,
                R.reduce = qO,
                R.reduceRight = HO,
                R.repeat = $N,
                R.replace = RN,
                R.result = cN,
                R.round = Ox,
                R.runInContext = ee,
                R.sample = VO,
                R.size = GO,
                R.snakeCase = PN,
                R.some = ZO,
                R.sortedIndex = WA,
                R.sortedIndexBy = zA,
                R.sortedIndexOf = GA,
                R.sortedLastIndex = ZA,
                R.sortedLastIndexBy = KA,
                R.sortedLastIndexOf = JA,
                R.startCase = CN,
                R.startsWith = MN,
                R.subtract = Ix,
                R.sum = Nx,
                R.sumBy = xx,
                R.template = LN,
                R.times = dx,
                R.toFinite = wi,
                R.toInteger = Xe,
                R.toLength = w_,
                R.toLower = DN,
                R.toNumber = tr,
                R.toSafeInteger = DI,
                R.toString = wt,
                R.toUpper = UN,
                R.trim = BN,
                R.trimEnd = FN,
                R.trimStart = jN,
                R.truncate = qN,
                R.unescape = HN,
                R.uniqueId = px,
                R.upperCase = YN,
                R.upperFirst = sp,
                R.each = a_,
                R.eachRight = o_,
                R.first = n_,
                cp(R, function() {
                    var i = {};
                    return qr(R, function(a, u) {
                        St.call(R.prototype, u) || (i[u] = a)
                    }),
                    i
                }(), {
                    chain: !1
                }),
                R.VERSION = r,
                Oe(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(i) {
                    R[i].placeholder = R
                }),
                Oe(["drop", "take"], function(i, a) {
                    lt.prototype[i] = function(u) {
                        u = u === n ? 1 : Zt(Xe(u), 0);
                        var p = this.__filtered__ && !a ? new lt(this) : this.clone();
                        return p.__filtered__ ? p.__takeCount__ = fn(u, p.__takeCount__) : p.__views__.push({
                            size: fn(u, H),
                            type: i + (p.__dir__ < 0 ? "Right" : "")
                        }),
                        p
                    }
                    ,
                    lt.prototype[i + "Right"] = function(u) {
                        return this.reverse()[i](u).reverse()
                    }
                }),
                Oe(["filter", "map", "takeWhile"], function(i, a) {
                    var u = a + 1
                      , p = u == X || u == x;
                    lt.prototype[i] = function(b) {
                        var k = this.clone();
                        return k.__iteratees__.push({
                            iteratee: Ue(b, 3),
                            type: u
                        }),
                        k.__filtered__ = k.__filtered__ || p,
                        k
                    }
                }),
                Oe(["head", "last"], function(i, a) {
                    var u = "take" + (a ? "Right" : "");
                    lt.prototype[i] = function() {
                        return this[u](1).value()[0]
                    }
                }),
                Oe(["initial", "tail"], function(i, a) {
                    var u = "drop" + (a ? "" : "Right");
                    lt.prototype[i] = function() {
                        return this.__filtered__ ? new lt(this) : this[u](1)
                    }
                }),
                lt.prototype.compact = function() {
                    return this.filter(Nn)
                }
                ,
                lt.prototype.find = function(i) {
                    return this.filter(i).head()
                }
                ,
                lt.prototype.findLast = function(i) {
                    return this.reverse().find(i)
                }
                ,
                lt.prototype.invokeMap = it(function(i, a) {
                    return typeof i == "function" ? new lt(this) : this.map(function(u) {
                        return _c(u, i, a)
                    })
                }),
                lt.prototype.reject = function(i) {
                    return this.filter(Wl(Ue(i)))
                }
                ,
                lt.prototype.slice = function(i, a) {
                    i = Xe(i);
                    var u = this;
                    return u.__filtered__ && (i > 0 || a < 0) ? new lt(u) : (i < 0 ? u = u.takeRight(-i) : i && (u = u.drop(i)),
                    a !== n && (a = Xe(a),
                    u = a < 0 ? u.dropRight(-a) : u.take(a - i)),
                    u)
                }
                ,
                lt.prototype.takeRightWhile = function(i) {
                    return this.reverse().takeWhile(i).reverse()
                }
                ,
                lt.prototype.toArray = function() {
                    return this.take(H)
                }
                ,
                qr(lt.prototype, function(i, a) {
                    var u = /^(?:filter|find|map|reject)|While$/.test(a)
                      , p = /^(?:head|last)$/.test(a)
                      , b = R[p ? "take" + (a == "last" ? "Right" : "") : a]
                      , k = p || /^find/.test(a);
                    b && (R.prototype[a] = function() {
                        var V = this.__wrapped__
                          , Z = p ? [1] : arguments
                          , ne = V instanceof lt
                          , le = Z[0]
                          , fe = ne || Ze(V)
                          , he = function(ut) {
                            var dt = b.apply(R, At([ut], Z));
                            return p && ve ? dt[0] : dt
                        };
                        fe && u && typeof le == "function" && le.length != 1 && (ne = fe = !1);
                        var ve = this.__chain__
                          , Pe = !!this.__actions__.length
                          , Fe = k && !ve
                          , nt = ne && !Pe;
                        if (!k && fe) {
                            V = nt ? V : new lt(this);
                            var je = i.apply(V, Z);
                            return je.__actions__.push({
                                func: ql,
                                args: [he],
                                thisArg: n
                            }),
                            new Jn(je,ve)
                        }
                        return Fe && nt ? i.apply(this, Z) : (je = this.thru(he),
                        Fe ? p ? je.value()[0] : je.value() : je)
                    }
                    )
                }),
                Oe(["pop", "push", "shift", "sort", "splice", "unshift"], function(i) {
                    var a = pl[i]
                      , u = /^(?:push|sort|unshift)$/.test(i) ? "tap" : "thru"
                      , p = /^(?:pop|shift)$/.test(i);
                    R.prototype[i] = function() {
                        var b = arguments;
                        if (p && !this.__chain__) {
                            var k = this.value();
                            return a.apply(Ze(k) ? k : [], b)
                        }
                        return this[u](function(V) {
                            return a.apply(Ze(V) ? V : [], b)
                        })
                    }
                }),
                qr(lt.prototype, function(i, a) {
                    var u = R[a];
                    if (u) {
                        var p = u.name + "";
                        St.call(Ma, p) || (Ma[p] = []),
                        Ma[p].push({
                            name: a,
                            func: u
                        })
                    }
                }),
                Ma[Ml(n, m).name] = [{
                    name: "wrapper",
                    func: n
                }],
                lt.prototype.clone = HS,
                lt.prototype.reverse = YS,
                lt.prototype.value = VS,
                R.prototype.at = wO,
                R.prototype.chain = bO,
                R.prototype.commit = EO,
                R.prototype.next = SO,
                R.prototype.plant = AO,
                R.prototype.reverse = OO,
                R.prototype.toJSON = R.prototype.valueOf = R.prototype.value = IO,
                R.prototype.first = R.prototype.head,
                fc && (R.prototype[fc] = TO),
                R
            }
              , Pa = ES();
            Tt ? ((Tt.exports = Pa)._ = Pa,
            Ia._ = Pa) : zt._ = Pa
        }
        ).call(Hn)
    }
    )(Df, Df.exports);
    Df.exports;
    function un(e) {
        return JSON.stringify(e, (t, n) => typeof n == "bigint" ? n.toString() : n)
    }
    function TB(e, t) {
        return Object.entries(t).reduce( (n, [r,s]) => n.replace(r, s), e)
    }
    function mu(e) {
        if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`positive integer expected, not ${e}`)
    }
    function AB(e) {
        if (typeof e != "boolean")
            throw new Error(`boolean expected, not ${e}`)
    }
    function OB(e) {
        return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array"
    }
    function Co(e, ...t) {
        if (!OB(e))
            throw new Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
            throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)
    }
    function sE(e) {
        if (typeof e != "function" || typeof e.create != "function")
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
        mu(e.outputLen),
        mu(e.blockLen)
    }
    function oa(e, t=!0) {
        if (e.destroyed)
            throw new Error("Hash instance has been destroyed");
        if (t && e.finished)
            throw new Error("Hash#digest() has already been called")
    }
    function f0(e, t) {
        Co(e);
        const n = t.outputLen;
        if (e.length < n)
            throw new Error(`digestInto() expects output buffer of length at least ${n}`)
    }
    const IB = {
        number: mu,
        bool: AB,
        bytes: Co,
        hash: sE,
        exists: oa,
        output: f0
    }
      , d0 = IB
      , ff = BigInt(2 ** 32 - 1)
      , Pv = BigInt(32);
    function NB(e, t=!1) {
        return t ? {
            h: Number(e & ff),
            l: Number(e >> Pv & ff)
        } : {
            h: Number(e >> Pv & ff) | 0,
            l: Number(e & ff) | 0
        }
    }
    function xB(e, t=!1) {
        let n = new Uint32Array(e.length)
          , r = new Uint32Array(e.length);
        for (let s = 0; s < e.length; s++) {
            const {h: o, l: c} = NB(e[s], t);
            [n[s],r[s]] = [o, c]
        }
        return [n, r]
    }
    const $B = (e, t, n) => e << n | t >>> 32 - n
      , RB = (e, t, n) => t << n | e >>> 32 - n
      , PB = (e, t, n) => t << n - 32 | e >>> 64 - n
      , kB = (e, t, n) => e << n - 32 | t >>> 64 - n
      , Ip = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const CB = e => new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength / 4))
      , Np = e => new DataView(e.buffer,e.byteOffset,e.byteLength)
      , zr = (e, t) => e << 32 - t | e >>> t
      , kv = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68
      , MB = e => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
    function Cv(e) {
        for (let t = 0; t < e.length; t++)
            e[t] = MB(e[t])
    }
    function h0(e) {
        if (typeof e != "string")
            throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
        return new Uint8Array(new TextEncoder().encode(e))
    }
    function Ld(e) {
        return typeof e == "string" && (e = h0(e)),
        Co(e),
        e
    }
    function LB(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
            const s = e[r];
            Co(s),
            t += s.length
        }
        const n = new Uint8Array(t);
        for (let r = 0, s = 0; r < e.length; r++) {
            const o = e[r];
            n.set(o, s),
            s += o.length
        }
        return n
    }
    class p0 {
        clone() {
            return this._cloneInto()
        }
    }
    function aE(e) {
        const t = r => e().update(Ld(r)).digest()
          , n = e();
        return t.outputLen = n.outputLen,
        t.blockLen = n.blockLen,
        t.create = () => e(),
        t
    }
    function oE(e=32) {
        if (Ip && typeof Ip.getRandomValues == "function")
            return Ip.getRandomValues(new Uint8Array(e));
        throw new Error("crypto.getRandomValues must be defined")
    }
    const cE = []
      , uE = []
      , lE = []
      , DB = BigInt(0)
      , Rc = BigInt(1)
      , UB = BigInt(2)
      , BB = BigInt(7)
      , FB = BigInt(256)
      , jB = BigInt(113);
    for (let e = 0, t = Rc, n = 1, r = 0; e < 24; e++) {
        [n,r] = [r, (2 * n + 3 * r) % 5],
        cE.push(2 * (5 * r + n)),
        uE.push((e + 1) * (e + 2) / 2 % 64);
        let s = DB;
        for (let o = 0; o < 7; o++)
            t = (t << Rc ^ (t >> BB) * jB) % FB,
            t & UB && (s ^= Rc << (Rc << BigInt(o)) - Rc);
        lE.push(s)
    }
    const [qB,HB] = xB(lE, !0)
      , Mv = (e, t, n) => n > 32 ? PB(e, t, n) : $B(e, t, n)
      , Lv = (e, t, n) => n > 32 ? kB(e, t, n) : RB(e, t, n);
    function YB(e, t=24) {
        const n = new Uint32Array(10);
        for (let r = 24 - t; r < 24; r++) {
            for (let c = 0; c < 10; c++)
                n[c] = e[c] ^ e[c + 10] ^ e[c + 20] ^ e[c + 30] ^ e[c + 40];
            for (let c = 0; c < 10; c += 2) {
                const l = (c + 8) % 10
                  , f = (c + 2) % 10
                  , d = n[f]
                  , h = n[f + 1]
                  , y = Mv(d, h, 1) ^ n[l]
                  , I = Lv(d, h, 1) ^ n[l + 1];
                for (let $ = 0; $ < 50; $ += 10)
                    e[c + $] ^= y,
                    e[c + $ + 1] ^= I
            }
            let s = e[2]
              , o = e[3];
            for (let c = 0; c < 24; c++) {
                const l = uE[c]
                  , f = Mv(s, o, l)
                  , d = Lv(s, o, l)
                  , h = cE[c];
                s = e[h],
                o = e[h + 1],
                e[h] = f,
                e[h + 1] = d
            }
            for (let c = 0; c < 50; c += 10) {
                for (let l = 0; l < 10; l++)
                    n[l] = e[c + l];
                for (let l = 0; l < 10; l++)
                    e[c + l] ^= ~n[(l + 2) % 10] & n[(l + 4) % 10]
            }
            e[0] ^= qB[r],
            e[1] ^= HB[r]
        }
        n.fill(0)
    }
    class m0 extends p0 {
        constructor(t, n, r, s=!1, o=24) {
            if (super(),
            this.blockLen = t,
            this.suffix = n,
            this.outputLen = r,
            this.enableXOF = s,
            this.rounds = o,
            this.pos = 0,
            this.posOut = 0,
            this.finished = !1,
            this.destroyed = !1,
            mu(r),
            0 >= this.blockLen || this.blockLen >= 200)
                throw new Error("Sha3 supports only keccak-f1600 function");
            this.state = new Uint8Array(200),
            this.state32 = CB(this.state)
        }
        keccak() {
            kv || Cv(this.state32),
            YB(this.state32, this.rounds),
            kv || Cv(this.state32),
            this.posOut = 0,
            this.pos = 0
        }
        update(t) {
            oa(this);
            const {blockLen: n, state: r} = this;
            t = Ld(t);
            const s = t.length;
            for (let o = 0; o < s; ) {
                const c = Math.min(n - this.pos, s - o);
                for (let l = 0; l < c; l++)
                    r[this.pos++] ^= t[o++];
                this.pos === n && this.keccak()
            }
            return this
        }
        finish() {
            if (this.finished)
                return;
            this.finished = !0;
            const {state: t, suffix: n, pos: r, blockLen: s} = this;
            t[r] ^= n,
            n & 128 && r === s - 1 && this.keccak(),
            t[s - 1] ^= 128,
            this.keccak()
        }
        writeInto(t) {
            oa(this, !1),
            Co(t),
            this.finish();
            const n = this.state
              , {blockLen: r} = this;
            for (let s = 0, o = t.length; s < o; ) {
                this.posOut >= r && this.keccak();
                const c = Math.min(r - this.posOut, o - s);
                t.set(n.subarray(this.posOut, this.posOut + c), s),
                this.posOut += c,
                s += c
            }
            return t
        }
        xofInto(t) {
            if (!this.enableXOF)
                throw new Error("XOF is not possible for this instance");
            return this.writeInto(t)
        }
        xof(t) {
            return mu(t),
            this.xofInto(new Uint8Array(t))
        }
        digestInto(t) {
            if (f0(t, this),
            this.finished)
                throw new Error("digest() was already called");
            return this.writeInto(t),
            this.destroy(),
            t
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen))
        }
        destroy() {
            this.destroyed = !0,
            this.state.fill(0)
        }
        _cloneInto(t) {
            const {blockLen: n, suffix: r, outputLen: s, rounds: o, enableXOF: c} = this;
            return t || (t = new m0(n,r,s,c,o)),
            t.state32.set(this.state32),
            t.pos = this.pos,
            t.posOut = this.posOut,
            t.finished = this.finished,
            t.rounds = o,
            t.suffix = r,
            t.outputLen = s,
            t.enableXOF = c,
            t.destroyed = this.destroyed,
            t
        }
    }
    const VB = (e, t, n) => aE( () => new m0(t,e,n))
      , Dv = VB(1, 136, 256 / 8);
    d0.bool;
    d0.bytes;
    function WB(e) {
        return t => (d0.bytes(t),
        e(t))
    }
    ( () => {
        const e = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0
          , t = typeof ws < "u" && typeof ws.require == "function" && ws.require.bind(ws);
        return {
            node: t && !e ? t("crypto") : void 0,
            web: e
        }
    }
    )();
    const fE = ( () => {
        const e = WB(Dv);
        return e.create = Dv.create,
        e
    }
    )()
      , zB = 100
      , GB = 101
      , ZB = 202
      , KB = 203
      , JB = 208
      , XB = 500
      , QB = 503
      , eF = 505
      , tF = 506
      , nF = 507
      , rF = 602
      , iF = 604
      , sF = 4001
      , aF = 4100
      , oF = 4200
      , cF = 4900
      , uF = 4901
      , lF = 1002
      , fF = 1003
      , dF = 1005
      , hF = 1100
      , pF = 1200
      , Uf = -32700
      , Bf = -32600
      , Ff = -32601
      , jf = -32602
      , qf = -32603
      , Hf = -32e3
      , Yf = -32001
      , Vf = -32002
      , Wf = -32003
      , zf = -32004
      , Gf = -32005
      , Zf = -32006;
    class Sn extends Error {
        get innerError() {
            return this.cause instanceof ru ? this.cause.errors : this.cause
        }
        set innerError(t) {
            Array.isArray(t) ? this.cause = new ru(t) : this.cause = t
        }
        constructor(t, n) {
            super(t),
            Array.isArray(n) ? this.cause = new ru(n) : this.cause = n,
            this.name = this.constructor.name,
            typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(new.target.constructor) : this.stack = new Error().stack
        }
        static convertToString(t, n=!1) {
            if (t == null)
                return "undefined";
            const r = JSON.stringify(t, (s, o) => typeof o == "bigint" ? o.toString() : o);
            return n && ["bigint", "string"].includes(typeof t) ? r.replace(/['\\"]+/g, "") : r
        }
        toJSON() {
            return {
                name: this.name,
                code: this.code,
                message: this.message,
                cause: this.cause,
                innerError: this.cause
            }
        }
    }
    class ru extends Sn {
        constructor(t) {
            super(`Multiple errors occurred: [${t.map(n => n.message).join("], [")}]`),
            this.code = JB,
            this.errors = t
        }
    }
    class g0 extends Sn {
        constructor(t, n) {
            super(`Invalid value given "${Sn.convertToString(t, !0)}". Error: ${n}.`),
            this.name = this.constructor.name
        }
    }
    class qu extends Sn {
        constructor(t, n) {
            super(t),
            this.code = XB,
            n && (this.errorCode = n.code,
            this.errorReason = n.reason)
        }
        toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
                errorCode: this.errorCode,
                errorReason: this.errorReason
            })
        }
    }
    class _m extends qu {
        constructor(t) {
            super("Connection not open", t),
            this.code = QB
        }
    }
    class mF extends qu {
        constructor(t) {
            super(`Maximum number of reconnect attempts reached! (${t})`),
            this.code = eF
        }
    }
    class gF extends qu {
        constructor() {
            super("CONNECTION ERROR: Provider started to reconnect before the response got received!"),
            this.code = tF
        }
    }
    class yF extends qu {
        constructor(t) {
            super(`Request already sent with following id: ${t}`),
            this.code = nF
        }
    }
    class Ai extends Sn {
        constructor() {
            super("The method you're trying to call is not implemented."),
            this.code = ZB
        }
    }
    class _F extends Sn {
        constructor() {
            super(...arguments),
            this.code = KB
        }
    }
    class vm extends Sn {
        constructor(t) {
            super(`Client URL "${t}" is invalid.`),
            this.code = rF
        }
    }
    class vF extends Sn {
        constructor() {
            super(...arguments),
            this.code = iF
        }
    }
    class wm extends g0 {
        constructor(t) {
            super(t, "can not parse as byte data"),
            this.code = lF
        }
    }
    class wF extends g0 {
        constructor(t) {
            super(t, "can not parse as number data"),
            this.code = fF
        }
    }
    class dE extends g0 {
        constructor(t) {
            super(t, "invalid ethereum address"),
            this.code = dF
        }
    }
    const bF = e => !Array.isArray(e) && e.jsonrpc === "2.0" && !!e && (e.result === void 0 || e.result === null) && "error"in e && (typeof e.id == "number" || typeof e.id == "string")
      , Uv = e => bF(e) ? e.error.message : "";
    class y0 extends Sn {
        constructor(t, n, r, s) {
            var o;
            super(n ?? `Returned error: ${Array.isArray(t) ? t.map(l => Uv(l)).join(",") : Uv(t)}`),
            this.code = zB,
            n || (this.data = Array.isArray(t) ? t.map(l => {
                var f;
                return (f = l.error) === null || f === void 0 ? void 0 : f.data
            }
            ) : (o = t?.error) === null || o === void 0 ? void 0 : o.data),
            this.statusCode = s,
            this.request = r;
            let c;
            "error"in t ? c = t.error : t instanceof Array && (c = t.filter(l => l.error).map(l => l.error)),
            Array.isArray(c) && c.length > 0 ? this.cause = new ru(c) : this.cause = c
        }
        toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
                data: this.data,
                request: this.request,
                statusCode: this.statusCode
            })
        }
    }
    class EF extends y0 {
        constructor(t, n) {
            super(t, void 0, n),
            this.code = GB;
            let r;
            "error"in t ? r = t.error : t instanceof Array && (r = t.map(s => s.error)),
            Array.isArray(r) ? this.cause = new ru(r) : this.cause = r
        }
    }
    const hE = "An Rpc error has occured with a code of *code*"
      , pn = {
        [Uf]: {
            message: "Parse error",
            description: "Invalid JSON"
        },
        [Bf]: {
            message: "Invalid request",
            description: "JSON is not a valid request object	"
        },
        [Ff]: {
            message: "Method not found",
            description: "Method does not exist	"
        },
        [jf]: {
            message: "Invalid params",
            description: "Invalid method parameters"
        },
        [qf]: {
            message: "Internal error",
            description: "Internal JSON-RPC error"
        },
        [Hf]: {
            message: "Invalid input",
            description: "Missing or invalid parameters"
        },
        [Yf]: {
            message: "Resource not found",
            description: "Requested resource not found"
        },
        [Vf]: {
            message: "Resource unavailable",
            description: "Requested resource not available"
        },
        [Wf]: {
            message: "Transaction rejected",
            description: "Transaction creation failed"
        },
        [zf]: {
            message: "Method not supported",
            description: "Method is not implemented"
        },
        [Gf]: {
            message: "Limit exceeded",
            description: "Request exceeds defined limit"
        },
        [Zf]: {
            message: "JSON-RPC version not supported",
            description: "Version of JSON-RPC protocol is not supported"
        },
        [sF]: {
            name: "User Rejected Request",
            message: "The user rejected the request."
        },
        [aF]: {
            name: "Unauthorized",
            message: "The requested method and/or account has not been authorized by the user."
        },
        [oF]: {
            name: "Unsupported Method",
            message: "The Provider does not support the requested method."
        },
        [cF]: {
            name: "Disconnected",
            message: "The Provider is disconnected from all chains."
        },
        [uF]: {
            name: "Chain Disconnected",
            message: "The Provider is not connected to the requested chain."
        },
        "0-999": {
            name: "",
            message: "Not used."
        },
        1e3: {
            name: "Normal Closure",
            message: "The connection successfully completed the purpose for which it was created."
        },
        1001: {
            name: "Going Away",
            message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
        },
        1002: {
            name: "Protocol error",
            message: "The endpoint is terminating the connection due to a protocol error."
        },
        1003: {
            name: "Unsupported Data",
            message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
        },
        1004: {
            name: "Reserved",
            message: "Reserved. A meaning might be defined in the future."
        },
        1005: {
            name: "No Status Rcvd",
            message: "Reserved. Indicates that no status code was provided even though one was expected."
        },
        1006: {
            name: "Abnormal Closure",
            message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
        },
        1007: {
            name: "Invalid frame payload data",
            message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
        },
        1008: {
            name: "Policy Violation",
            message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
        },
        1009: {
            name: "Message Too Big",
            message: "The endpoint is terminating the connection because a data frame was received that is too large."
        },
        1010: {
            name: "Mandatory Ext.",
            message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
        },
        1011: {
            name: "Internal Error",
            message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
        },
        1012: {
            name: "Service Restart",
            message: "The server is terminating the connection because it is restarting."
        },
        1013: {
            name: "Try Again Later",
            message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
        },
        1014: {
            name: "Bad Gateway",
            message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
        },
        1015: {
            name: "TLS handshake",
            message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
        },
        "1016-2999": {
            name: "",
            message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
        },
        "3000-3999": {
            name: "",
            message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
        },
        "4000-4999": {
            name: "",
            message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
        }
    };
    class mr extends Sn {
        constructor(t, n) {
            super(n ?? hE.replace("*code*", t.error.code.toString())),
            this.code = t.error.code,
            this.id = t.id,
            this.jsonrpc = t.jsonrpc,
            this.jsonRpcError = t.error
        }
        toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
                error: this.jsonRpcError,
                id: this.id,
                jsonRpc: this.jsonrpc
            })
        }
    }
    class SF extends Sn {
        constructor(t, n) {
            var r, s, o, c;
            if (!t)
                super();
            else if (!((r = pn[t]) === null || r === void 0) && r.message)
                super(pn[t].message);
            else {
                const l = Object.keys(pn).find(f => typeof f == "string" && t >= parseInt(f.split("-")[0], 10) && t <= parseInt(f.split("-")[1], 10));
                super((o = (s = pn[l ?? ""]) === null || s === void 0 ? void 0 : s.message) !== null && o !== void 0 ? o : hE.replace("*code*", (c = t?.toString()) !== null && c !== void 0 ? c : '""'))
            }
            this.code = t,
            this.data = n
        }
    }
    class TF extends mr {
        constructor(t) {
            super(t, pn[Uf].message),
            this.code = Uf
        }
    }
    class AF extends mr {
        constructor(t) {
            super(t, pn[Bf].message),
            this.code = Bf
        }
    }
    class OF extends mr {
        constructor(t) {
            super(t, pn[Ff].message),
            this.code = Ff
        }
    }
    class IF extends mr {
        constructor(t) {
            super(t, pn[jf].message),
            this.code = jf
        }
    }
    class NF extends mr {
        constructor(t) {
            super(t, pn[qf].message),
            this.code = qf
        }
    }
    class xF extends mr {
        constructor(t) {
            super(t, pn[Hf].message),
            this.code = Hf
        }
    }
    class $F extends mr {
        constructor(t) {
            super(t, pn[zf].message),
            this.code = zf
        }
    }
    class RF extends mr {
        constructor(t) {
            super(t, pn[Vf].message),
            this.code = Vf
        }
    }
    class PF extends mr {
        constructor(t) {
            super(t, pn[Yf].message),
            this.code = Yf
        }
    }
    class kF extends mr {
        constructor(t) {
            super(t, pn[Zf].message),
            this.code = Zf
        }
    }
    class CF extends mr {
        constructor(t) {
            super(t, pn[Wf].message),
            this.code = Wf
        }
    }
    class MF extends mr {
        constructor(t) {
            super(t, pn[Gf].message),
            this.code = Gf
        }
    }
    const gr = new Map;
    gr.set(Uf, {
        error: TF
    });
    gr.set(Bf, {
        error: AF
    });
    gr.set(Ff, {
        error: OF
    });
    gr.set(jf, {
        error: IF
    });
    gr.set(qf, {
        error: NF
    });
    gr.set(Hf, {
        error: xF
    });
    gr.set(zf, {
        error: $F
    });
    gr.set(Vf, {
        error: RF
    });
    gr.set(Wf, {
        error: CF
    });
    gr.set(Yf, {
        error: PF
    });
    gr.set(Zf, {
        error: kF
    });
    gr.set(Gf, {
        error: MF
    });
    class LF extends Sn {
        constructor(t) {
            super(`Format for the type ${t} is unsupported`),
            this.type = t,
            this.code = pF
        }
        toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
                type: this.type
            })
        }
    }
    var ht;
    (function(e) {
        e.assertEqual = s => s;
        function t(s) {}
        e.assertIs = t;
        function n(s) {
            throw new Error
        }
        e.assertNever = n,
        e.arrayToEnum = s => {
            const o = {};
            for (const c of s)
                o[c] = c;
            return o
        }
        ,
        e.getValidEnumValues = s => {
            const o = e.objectKeys(s).filter(l => typeof s[s[l]] != "number")
              , c = {};
            for (const l of o)
                c[l] = s[l];
            return e.objectValues(c)
        }
        ,
        e.objectValues = s => e.objectKeys(s).map(function(o) {
            return s[o]
        }),
        e.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
            const o = [];
            for (const c in s)
                Object.prototype.hasOwnProperty.call(s, c) && o.push(c);
            return o
        }
        ,
        e.find = (s, o) => {
            for (const c of s)
                if (o(c))
                    return c
        }
        ,
        e.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
        function r(s, o=" | ") {
            return s.map(c => typeof c == "string" ? `'${c}'` : c).join(o)
        }
        e.joinValues = r,
        e.jsonStringifyReplacer = (s, o) => typeof o == "bigint" ? o.toString() : o
    }
    )(ht || (ht = {}));
    var bm;
    (function(e) {
        e.mergeShapes = (t, n) => ({
            ...t,
            ...n
        })
    }
    )(bm || (bm = {}));
    const Ae = ht.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
      , gs = e => {
        switch (typeof e) {
        case "undefined":
            return Ae.undefined;
        case "string":
            return Ae.string;
        case "number":
            return isNaN(e) ? Ae.nan : Ae.number;
        case "boolean":
            return Ae.boolean;
        case "function":
            return Ae.function;
        case "bigint":
            return Ae.bigint;
        case "symbol":
            return Ae.symbol;
        case "object":
            return Array.isArray(e) ? Ae.array : e === null ? Ae.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Ae.promise : typeof Map < "u" && e instanceof Map ? Ae.map : typeof Set < "u" && e instanceof Set ? Ae.set : typeof Date < "u" && e instanceof Date ? Ae.date : Ae.object;
        default:
            return Ae.unknown
        }
    }
      , me = ht.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
      , DF = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
    class Yn extends Error {
        constructor(t) {
            super(),
            this.issues = [],
            this.addIssue = r => {
                this.issues = [...this.issues, r]
            }
            ,
            this.addIssues = (r=[]) => {
                this.issues = [...this.issues, ...r]
            }
            ;
            const n = new.target.prototype;
            Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n,
            this.name = "ZodError",
            this.issues = t
        }
        get errors() {
            return this.issues
        }
        format(t) {
            const n = t || function(o) {
                return o.message
            }
              , r = {
                _errors: []
            }
              , s = o => {
                for (const c of o.issues)
                    if (c.code === "invalid_union")
                        c.unionErrors.map(s);
                    else if (c.code === "invalid_return_type")
                        s(c.returnTypeError);
                    else if (c.code === "invalid_arguments")
                        s(c.argumentsError);
                    else if (c.path.length === 0)
                        r._errors.push(n(c));
                    else {
                        let l = r
                          , f = 0;
                        for (; f < c.path.length; ) {
                            const d = c.path[f];
                            f === c.path.length - 1 ? (l[d] = l[d] || {
                                _errors: []
                            },
                            l[d]._errors.push(n(c))) : l[d] = l[d] || {
                                _errors: []
                            },
                            l = l[d],
                            f++
                        }
                    }
            }
            ;
            return s(this),
            r
        }
        static assert(t) {
            if (!(t instanceof Yn))
                throw new Error(`Not a ZodError: ${t}`)
        }
        toString() {
            return this.message
        }
        get message() {
            return JSON.stringify(this.issues, ht.jsonStringifyReplacer, 2)
        }
        get isEmpty() {
            return this.issues.length === 0
        }
        flatten(t=n => n.message) {
            const n = {}
              , r = [];
            for (const s of this.issues)
                s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [],
                n[s.path[0]].push(t(s))) : r.push(t(s));
            return {
                formErrors: r,
                fieldErrors: n
            }
        }
        get formErrors() {
            return this.flatten()
        }
    }
    Yn.create = e => new Yn(e);
    const bo = (e, t) => {
        let n;
        switch (e.code) {
        case me.invalid_type:
            e.received === Ae.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
            break;
        case me.invalid_literal:
            n = `Invalid literal value, expected ${JSON.stringify(e.expected, ht.jsonStringifyReplacer)}`;
            break;
        case me.unrecognized_keys:
            n = `Unrecognized key(s) in object: ${ht.joinValues(e.keys, ", ")}`;
            break;
        case me.invalid_union:
            n = "Invalid input";
            break;
        case me.invalid_union_discriminator:
            n = `Invalid discriminator value. Expected ${ht.joinValues(e.options)}`;
            break;
        case me.invalid_enum_value:
            n = `Invalid enum value. Expected ${ht.joinValues(e.options)}, received '${e.received}'`;
            break;
        case me.invalid_arguments:
            n = "Invalid function arguments";
            break;
        case me.invalid_return_type:
            n = "Invalid function return type";
            break;
        case me.invalid_date:
            n = "Invalid date";
            break;
        case me.invalid_string:
            typeof e.validation == "object" ? "includes"in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`,
            typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith"in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith"in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : ht.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
            break;
        case me.too_small:
            e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
            break;
        case me.too_big:
            e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
            break;
        case me.custom:
            n = "Invalid input";
            break;
        case me.invalid_intersection_types:
            n = "Intersection results could not be merged";
            break;
        case me.not_multiple_of:
            n = `Number must be a multiple of ${e.multipleOf}`;
            break;
        case me.not_finite:
            n = "Number must be finite";
            break;
        default:
            n = t.defaultError,
            ht.assertNever(e)
        }
        return {
            message: n
        }
    }
    ;
    let pE = bo;
    function UF(e) {
        pE = e
    }
    function Kf() {
        return pE
    }
    const Jf = e => {
        const {data: t, path: n, errorMaps: r, issueData: s} = e
          , o = [...n, ...s.path || []]
          , c = {
            ...s,
            path: o
        };
        if (s.message !== void 0)
            return {
                ...s,
                path: o,
                message: s.message
            };
        let l = "";
        const f = r.filter(d => !!d).slice().reverse();
        for (const d of f)
            l = d(c, {
                data: t,
                defaultError: l
            }).message;
        return {
            ...s,
            path: o,
            message: l
        }
    }
      , BF = [];
    function be(e, t) {
        const n = Kf()
          , r = Jf({
            issueData: t,
            data: e.data,
            path: e.path,
            errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, n, n === bo ? void 0 : bo].filter(s => !!s)
        });
        e.common.issues.push(r)
    }
    class gn {
        constructor() {
            this.value = "valid"
        }
        dirty() {
            this.value === "valid" && (this.value = "dirty")
        }
        abort() {
            this.value !== "aborted" && (this.value = "aborted")
        }
        static mergeArray(t, n) {
            const r = [];
            for (const s of n) {
                if (s.status === "aborted")
                    return He;
                s.status === "dirty" && t.dirty(),
                r.push(s.value)
            }
            return {
                status: t.value,
                value: r
            }
        }
        static async mergeObjectAsync(t, n) {
            const r = [];
            for (const s of n) {
                const o = await s.key
                  , c = await s.value;
                r.push({
                    key: o,
                    value: c
                })
            }
            return gn.mergeObjectSync(t, r)
        }
        static mergeObjectSync(t, n) {
            const r = {};
            for (const s of n) {
                const {key: o, value: c} = s;
                if (o.status === "aborted" || c.status === "aborted")
                    return He;
                o.status === "dirty" && t.dirty(),
                c.status === "dirty" && t.dirty(),
                o.value !== "__proto__" && (typeof c.value < "u" || s.alwaysSet) && (r[o.value] = c.value)
            }
            return {
                status: t.value,
                value: r
            }
        }
    }
    const He = Object.freeze({
        status: "aborted"
    })
      , ao = e => ({
        status: "dirty",
        value: e
    })
      , Tn = e => ({
        status: "valid",
        value: e
    })
      , Em = e => e.status === "aborted"
      , Sm = e => e.status === "dirty"
      , gu = e => e.status === "valid"
      , yu = e => typeof Promise < "u" && e instanceof Promise;
    function Xf(e, t, n, r) {
        if (typeof t == "function" ? e !== t || !r : !t.has(e))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t.get(e)
    }
    function mE(e, t, n, r, s) {
        if (typeof t == "function" ? e !== t || !s : !t.has(e))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return t.set(e, n),
        n
    }
    var Me;
    (function(e) {
        e.errToObj = t => typeof t == "string" ? {
            message: t
        } : t || {},
        e.toString = t => typeof t == "string" ? t : t?.message
    }
    )(Me || (Me = {}));
    var zc, Gc;
    class ri {
        constructor(t, n, r, s) {
            this._cachedPath = [],
            this.parent = t,
            this.data = n,
            this._path = r,
            this._key = s
        }
        get path() {
            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
        }
    }
    const Bv = (e, t) => {
        if (gu(t))
            return {
                success: !0,
                data: t.value
            };
        if (!e.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error)
                    return this._error;
                const n = new Yn(e.common.issues);
                return this._error = n,
                this._error
            }
        }
    }
    ;
    function Je(e) {
        if (!e)
            return {};
        const {errorMap: t, invalid_type_error: n, required_error: r, description: s} = e;
        if (t && (n || r))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return t ? {
            errorMap: t,
            description: s
        } : {
            errorMap: (c, l) => {
                var f, d;
                const {message: h} = e;
                return c.code === "invalid_enum_value" ? {
                    message: h ?? l.defaultError
                } : typeof l.data > "u" ? {
                    message: (f = h ?? r) !== null && f !== void 0 ? f : l.defaultError
                } : c.code !== "invalid_type" ? {
                    message: l.defaultError
                } : {
                    message: (d = h ?? n) !== null && d !== void 0 ? d : l.defaultError
                }
            }
            ,
            description: s
        }
    }
    class rt {
        constructor(t) {
            this.spa = this.safeParseAsync,
            this._def = t,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this)
        }
        get description() {
            return this._def.description
        }
        _getType(t) {
            return gs(t.data)
        }
        _getOrReturnCtx(t, n) {
            return n || {
                common: t.parent.common,
                data: t.data,
                parsedType: gs(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        }
        _processInputParams(t) {
            return {
                status: new gn,
                ctx: {
                    common: t.parent.common,
                    data: t.data,
                    parsedType: gs(t.data),
                    schemaErrorMap: this._def.errorMap,
                    path: t.path,
                    parent: t.parent
                }
            }
        }
        _parseSync(t) {
            const n = this._parse(t);
            if (yu(n))
                throw new Error("Synchronous parse encountered promise.");
            return n
        }
        _parseAsync(t) {
            const n = this._parse(t);
            return Promise.resolve(n)
        }
        parse(t, n) {
            const r = this.safeParse(t, n);
            if (r.success)
                return r.data;
            throw r.error
        }
        safeParse(t, n) {
            var r;
            const s = {
                common: {
                    issues: [],
                    async: (r = n?.async) !== null && r !== void 0 ? r : !1,
                    contextualErrorMap: n?.errorMap
                },
                path: n?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: t,
                parsedType: gs(t)
            }
              , o = this._parseSync({
                data: t,
                path: s.path,
                parent: s
            });
            return Bv(s, o)
        }
        async parseAsync(t, n) {
            const r = await this.safeParseAsync(t, n);
            if (r.success)
                return r.data;
            throw r.error
        }
        async safeParseAsync(t, n) {
            const r = {
                common: {
                    issues: [],
                    contextualErrorMap: n?.errorMap,
                    async: !0
                },
                path: n?.path || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: t,
                parsedType: gs(t)
            }
              , s = this._parse({
                data: t,
                path: r.path,
                parent: r
            })
              , o = await (yu(s) ? s : Promise.resolve(s));
            return Bv(r, o)
        }
        refine(t, n) {
            const r = s => typeof n == "string" || typeof n > "u" ? {
                message: n
            } : typeof n == "function" ? n(s) : n;
            return this._refinement( (s, o) => {
                const c = t(s)
                  , l = () => o.addIssue({
                    code: me.custom,
                    ...r(s)
                });
                return typeof Promise < "u" && c instanceof Promise ? c.then(f => f ? !0 : (l(),
                !1)) : c ? !0 : (l(),
                !1)
            }
            )
        }
        refinement(t, n) {
            return this._refinement( (r, s) => t(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n),
            !1))
        }
        _refinement(t) {
            return new Dr({
                schema: this,
                typeName: qe.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement: t
                }
            })
        }
        superRefine(t) {
            return this._refinement(t)
        }
        optional() {
            return ti.create(this, this._def)
        }
        nullable() {
            return Os.create(this, this._def)
        }
        nullish() {
            return this.nullable().optional()
        }
        array() {
            return Cr.create(this, this._def)
        }
        promise() {
            return So.create(this, this._def)
        }
        or(t) {
            return bu.create([this, t], this._def)
        }
        and(t) {
            return Eu.create(this, t, this._def)
        }
        transform(t) {
            return new Dr({
                ...Je(this._def),
                schema: this,
                typeName: qe.ZodEffects,
                effect: {
                    type: "transform",
                    transform: t
                }
            })
        }
        default(t) {
            const n = typeof t == "function" ? t : () => t;
            return new Iu({
                ...Je(this._def),
                innerType: this,
                defaultValue: n,
                typeName: qe.ZodDefault
            })
        }
        brand() {
            return new _0({
                typeName: qe.ZodBranded,
                type: this,
                ...Je(this._def)
            })
        }
        catch(t) {
            const n = typeof t == "function" ? t : () => t;
            return new Nu({
                ...Je(this._def),
                innerType: this,
                catchValue: n,
                typeName: qe.ZodCatch
            })
        }
        describe(t) {
            const n = this.constructor;
            return new n({
                ...this._def,
                description: t
            })
        }
        pipe(t) {
            return Hu.create(this, t)
        }
        readonly() {
            return xu.create(this)
        }
        isOptional() {
            return this.safeParse(void 0).success
        }
        isNullable() {
            return this.safeParse(null).success
        }
    }
    const FF = /^c[^\s-]{8,}$/i
      , jF = /^[0-9a-z]+$/
      , qF = /^[0-9A-HJKMNP-TV-Z]{26}$/
      , HF = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , YF = /^[a-z0-9_-]{21}$/i
      , VF = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
      , WF = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , zF = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let xp;
    const GF = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
      , ZF = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
      , KF = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      , gE = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
      , JF = new RegExp(`^${gE}$`);
    function yE(e) {
        let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
        return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`),
        t
    }
    function XF(e) {
        return new RegExp(`^${yE(e)}$`)
    }
    function _E(e) {
        let t = `${gE}T${yE(e)}`;
        const n = [];
        return n.push(e.local ? "Z?" : "Z"),
        e.offset && n.push("([+-]\\d{2}:?\\d{2})"),
        t = `${t}(${n.join("|")})`,
        new RegExp(`^${t}$`)
    }
    function QF(e, t) {
        return !!((t === "v4" || !t) && GF.test(e) || (t === "v6" || !t) && ZF.test(e))
    }
    class Pr extends rt {
        _parse(t) {
            if (this._def.coerce && (t.data = String(t.data)),
            this._getType(t) !== Ae.string) {
                const o = this._getOrReturnCtx(t);
                return be(o, {
                    code: me.invalid_type,
                    expected: Ae.string,
                    received: o.parsedType
                }),
                He
            }
            const r = new gn;
            let s;
            for (const o of this._def.checks)
                if (o.kind === "min")
                    t.data.length < o.value && (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.too_small,
                        minimum: o.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "max")
                    t.data.length > o.value && (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.too_big,
                        maximum: o.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "length") {
                    const c = t.data.length > o.value
                      , l = t.data.length < o.value;
                    (c || l) && (s = this._getOrReturnCtx(t, s),
                    c ? be(s, {
                        code: me.too_big,
                        maximum: o.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: o.message
                    }) : l && be(s, {
                        code: me.too_small,
                        minimum: o.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: o.message
                    }),
                    r.dirty())
                } else if (o.kind === "email")
                    WF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "email",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "emoji")
                    xp || (xp = new RegExp(zF,"u")),
                    xp.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "emoji",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "uuid")
                    HF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "uuid",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "nanoid")
                    YF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "nanoid",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "cuid")
                    FF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "cuid",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "cuid2")
                    jF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "cuid2",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "ulid")
                    qF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "ulid",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty());
                else if (o.kind === "url")
                    try {
                        new URL(t.data)
                    } catch {
                        s = this._getOrReturnCtx(t, s),
                        be(s, {
                            validation: "url",
                            code: me.invalid_string,
                            message: o.message
                        }),
                        r.dirty()
                    }
                else
                    o.kind === "regex" ? (o.regex.lastIndex = 0,
                    o.regex.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "regex",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty())) : o.kind === "trim" ? t.data = t.data.trim() : o.kind === "includes" ? t.data.includes(o.value, o.position) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.invalid_string,
                        validation: {
                            includes: o.value,
                            position: o.position
                        },
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : o.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : o.kind === "startsWith" ? t.data.startsWith(o.value) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.invalid_string,
                        validation: {
                            startsWith: o.value
                        },
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "endsWith" ? t.data.endsWith(o.value) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.invalid_string,
                        validation: {
                            endsWith: o.value
                        },
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "datetime" ? _E(o).test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.invalid_string,
                        validation: "datetime",
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "date" ? JF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.invalid_string,
                        validation: "date",
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "time" ? XF(o).test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        code: me.invalid_string,
                        validation: "time",
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "duration" ? VF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "duration",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "ip" ? QF(t.data, o.version) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "ip",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty()) : o.kind === "base64" ? KF.test(t.data) || (s = this._getOrReturnCtx(t, s),
                    be(s, {
                        validation: "base64",
                        code: me.invalid_string,
                        message: o.message
                    }),
                    r.dirty()) : ht.assertNever(o);
            return {
                status: r.value,
                value: t.data
            }
        }
        _regex(t, n, r) {
            return this.refinement(s => t.test(s), {
                validation: n,
                code: me.invalid_string,
                ...Me.errToObj(r)
            })
        }
        _addCheck(t) {
            return new Pr({
                ...this._def,
                checks: [...this._def.checks, t]
            })
        }
        email(t) {
            return this._addCheck({
                kind: "email",
                ...Me.errToObj(t)
            })
        }
        url(t) {
            return this._addCheck({
                kind: "url",
                ...Me.errToObj(t)
            })
        }
        emoji(t) {
            return this._addCheck({
                kind: "emoji",
                ...Me.errToObj(t)
            })
        }
        uuid(t) {
            return this._addCheck({
                kind: "uuid",
                ...Me.errToObj(t)
            })
        }
        nanoid(t) {
            return this._addCheck({
                kind: "nanoid",
                ...Me.errToObj(t)
            })
        }
        cuid(t) {
            return this._addCheck({
                kind: "cuid",
                ...Me.errToObj(t)
            })
        }
        cuid2(t) {
            return this._addCheck({
                kind: "cuid2",
                ...Me.errToObj(t)
            })
        }
        ulid(t) {
            return this._addCheck({
                kind: "ulid",
                ...Me.errToObj(t)
            })
        }
        base64(t) {
            return this._addCheck({
                kind: "base64",
                ...Me.errToObj(t)
            })
        }
        ip(t) {
            return this._addCheck({
                kind: "ip",
                ...Me.errToObj(t)
            })
        }
        datetime(t) {
            var n, r;
            return typeof t == "string" ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                local: !1,
                message: t
            }) : this._addCheck({
                kind: "datetime",
                precision: typeof t?.precision > "u" ? null : t?.precision,
                offset: (n = t?.offset) !== null && n !== void 0 ? n : !1,
                local: (r = t?.local) !== null && r !== void 0 ? r : !1,
                ...Me.errToObj(t?.message)
            })
        }
        date(t) {
            return this._addCheck({
                kind: "date",
                message: t
            })
        }
        time(t) {
            return typeof t == "string" ? this._addCheck({
                kind: "time",
                precision: null,
                message: t
            }) : this._addCheck({
                kind: "time",
                precision: typeof t?.precision > "u" ? null : t?.precision,
                ...Me.errToObj(t?.message)
            })
        }
        duration(t) {
            return this._addCheck({
                kind: "duration",
                ...Me.errToObj(t)
            })
        }
        regex(t, n) {
            return this._addCheck({
                kind: "regex",
                regex: t,
                ...Me.errToObj(n)
            })
        }
        includes(t, n) {
            return this._addCheck({
                kind: "includes",
                value: t,
                position: n?.position,
                ...Me.errToObj(n?.message)
            })
        }
        startsWith(t, n) {
            return this._addCheck({
                kind: "startsWith",
                value: t,
                ...Me.errToObj(n)
            })
        }
        endsWith(t, n) {
            return this._addCheck({
                kind: "endsWith",
                value: t,
                ...Me.errToObj(n)
            })
        }
        min(t, n) {
            return this._addCheck({
                kind: "min",
                value: t,
                ...Me.errToObj(n)
            })
        }
        max(t, n) {
            return this._addCheck({
                kind: "max",
                value: t,
                ...Me.errToObj(n)
            })
        }
        length(t, n) {
            return this._addCheck({
                kind: "length",
                value: t,
                ...Me.errToObj(n)
            })
        }
        nonempty(t) {
            return this.min(1, Me.errToObj(t))
        }
        trim() {
            return new Pr({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "trim"
                }]
            })
        }
        toLowerCase() {
            return new Pr({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toLowerCase"
                }]
            })
        }
        toUpperCase() {
            return new Pr({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toUpperCase"
                }]
            })
        }
        get isDatetime() {
            return !!this._def.checks.find(t => t.kind === "datetime")
        }
        get isDate() {
            return !!this._def.checks.find(t => t.kind === "date")
        }
        get isTime() {
            return !!this._def.checks.find(t => t.kind === "time")
        }
        get isDuration() {
            return !!this._def.checks.find(t => t.kind === "duration")
        }
        get isEmail() {
            return !!this._def.checks.find(t => t.kind === "email")
        }
        get isURL() {
            return !!this._def.checks.find(t => t.kind === "url")
        }
        get isEmoji() {
            return !!this._def.checks.find(t => t.kind === "emoji")
        }
        get isUUID() {
            return !!this._def.checks.find(t => t.kind === "uuid")
        }
        get isNANOID() {
            return !!this._def.checks.find(t => t.kind === "nanoid")
        }
        get isCUID() {
            return !!this._def.checks.find(t => t.kind === "cuid")
        }
        get isCUID2() {
            return !!this._def.checks.find(t => t.kind === "cuid2")
        }
        get isULID() {
            return !!this._def.checks.find(t => t.kind === "ulid")
        }
        get isIP() {
            return !!this._def.checks.find(t => t.kind === "ip")
        }
        get isBase64() {
            return !!this._def.checks.find(t => t.kind === "base64")
        }
        get minLength() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "min" && (t === null || n.value > t) && (t = n.value);
            return t
        }
        get maxLength() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "max" && (t === null || n.value < t) && (t = n.value);
            return t
        }
    }
    Pr.create = e => {
        var t;
        return new Pr({
            checks: [],
            typeName: qe.ZodString,
            coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
            ...Je(e)
        })
    }
    ;
    function ej(e, t) {
        const n = (e.toString().split(".")[1] || "").length
          , r = (t.toString().split(".")[1] || "").length
          , s = n > r ? n : r
          , o = parseInt(e.toFixed(s).replace(".", ""))
          , c = parseInt(t.toFixed(s).replace(".", ""));
        return o % c / Math.pow(10, s)
    }
    class Ss extends rt {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
        }
        _parse(t) {
            if (this._def.coerce && (t.data = Number(t.data)),
            this._getType(t) !== Ae.number) {
                const o = this._getOrReturnCtx(t);
                return be(o, {
                    code: me.invalid_type,
                    expected: Ae.number,
                    received: o.parsedType
                }),
                He
            }
            let r;
            const s = new gn;
            for (const o of this._def.checks)
                o.kind === "int" ? ht.isInteger(t.data) || (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: o.message
                }),
                s.dirty()) : o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.too_small,
                    minimum: o.value,
                    type: "number",
                    inclusive: o.inclusive,
                    exact: !1,
                    message: o.message
                }),
                s.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.too_big,
                    maximum: o.value,
                    type: "number",
                    inclusive: o.inclusive,
                    exact: !1,
                    message: o.message
                }),
                s.dirty()) : o.kind === "multipleOf" ? ej(t.data, o.value) !== 0 && (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.not_multiple_of,
                    multipleOf: o.value,
                    message: o.message
                }),
                s.dirty()) : o.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.not_finite,
                    message: o.message
                }),
                s.dirty()) : ht.assertNever(o);
            return {
                status: s.value,
                value: t.data
            }
        }
        gte(t, n) {
            return this.setLimit("min", t, !0, Me.toString(n))
        }
        gt(t, n) {
            return this.setLimit("min", t, !1, Me.toString(n))
        }
        lte(t, n) {
            return this.setLimit("max", t, !0, Me.toString(n))
        }
        lt(t, n) {
            return this.setLimit("max", t, !1, Me.toString(n))
        }
        setLimit(t, n, r, s) {
            return new Ss({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: t,
                    value: n,
                    inclusive: r,
                    message: Me.toString(s)
                }]
            })
        }
        _addCheck(t) {
            return new Ss({
                ...this._def,
                checks: [...this._def.checks, t]
            })
        }
        int(t) {
            return this._addCheck({
                kind: "int",
                message: Me.toString(t)
            })
        }
        positive(t) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: Me.toString(t)
            })
        }
        negative(t) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: Me.toString(t)
            })
        }
        nonpositive(t) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: Me.toString(t)
            })
        }
        nonnegative(t) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: Me.toString(t)
            })
        }
        multipleOf(t, n) {
            return this._addCheck({
                kind: "multipleOf",
                value: t,
                message: Me.toString(n)
            })
        }
        finite(t) {
            return this._addCheck({
                kind: "finite",
                message: Me.toString(t)
            })
        }
        safe(t) {
            return this._addCheck({
                kind: "min",
                inclusive: !0,
                value: Number.MIN_SAFE_INTEGER,
                message: Me.toString(t)
            })._addCheck({
                kind: "max",
                inclusive: !0,
                value: Number.MAX_SAFE_INTEGER,
                message: Me.toString(t)
            })
        }
        get minValue() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "min" && (t === null || n.value > t) && (t = n.value);
            return t
        }
        get maxValue() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "max" && (t === null || n.value < t) && (t = n.value);
            return t
        }
        get isInt() {
            return !!this._def.checks.find(t => t.kind === "int" || t.kind === "multipleOf" && ht.isInteger(t.value))
        }
        get isFinite() {
            let t = null
              , n = null;
            for (const r of this._def.checks) {
                if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
                    return !0;
                r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value)
            }
            return Number.isFinite(n) && Number.isFinite(t)
        }
    }
    Ss.create = e => new Ss({
        checks: [],
        typeName: qe.ZodNumber,
        coerce: e?.coerce || !1,
        ...Je(e)
    });
    class Ts extends rt {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte
        }
        _parse(t) {
            if (this._def.coerce && (t.data = BigInt(t.data)),
            this._getType(t) !== Ae.bigint) {
                const o = this._getOrReturnCtx(t);
                return be(o, {
                    code: me.invalid_type,
                    expected: Ae.bigint,
                    received: o.parsedType
                }),
                He
            }
            let r;
            const s = new gn;
            for (const o of this._def.checks)
                o.kind === "min" ? (o.inclusive ? t.data < o.value : t.data <= o.value) && (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.too_small,
                    type: "bigint",
                    minimum: o.value,
                    inclusive: o.inclusive,
                    message: o.message
                }),
                s.dirty()) : o.kind === "max" ? (o.inclusive ? t.data > o.value : t.data >= o.value) && (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.too_big,
                    type: "bigint",
                    maximum: o.value,
                    inclusive: o.inclusive,
                    message: o.message
                }),
                s.dirty()) : o.kind === "multipleOf" ? t.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r),
                be(r, {
                    code: me.not_multiple_of,
                    multipleOf: o.value,
                    message: o.message
                }),
                s.dirty()) : ht.assertNever(o);
            return {
                status: s.value,
                value: t.data
            }
        }
        gte(t, n) {
            return this.setLimit("min", t, !0, Me.toString(n))
        }
        gt(t, n) {
            return this.setLimit("min", t, !1, Me.toString(n))
        }
        lte(t, n) {
            return this.setLimit("max", t, !0, Me.toString(n))
        }
        lt(t, n) {
            return this.setLimit("max", t, !1, Me.toString(n))
        }
        setLimit(t, n, r, s) {
            return new Ts({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: t,
                    value: n,
                    inclusive: r,
                    message: Me.toString(s)
                }]
            })
        }
        _addCheck(t) {
            return new Ts({
                ...this._def,
                checks: [...this._def.checks, t]
            })
        }
        positive(t) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !1,
                message: Me.toString(t)
            })
        }
        negative(t) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !1,
                message: Me.toString(t)
            })
        }
        nonpositive(t) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !0,
                message: Me.toString(t)
            })
        }
        nonnegative(t) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !0,
                message: Me.toString(t)
            })
        }
        multipleOf(t, n) {
            return this._addCheck({
                kind: "multipleOf",
                value: t,
                message: Me.toString(n)
            })
        }
        get minValue() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "min" && (t === null || n.value > t) && (t = n.value);
            return t
        }
        get maxValue() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "max" && (t === null || n.value < t) && (t = n.value);
            return t
        }
    }
    Ts.create = e => {
        var t;
        return new Ts({
            checks: [],
            typeName: qe.ZodBigInt,
            coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
            ...Je(e)
        })
    }
    ;
    class _u extends rt {
        _parse(t) {
            if (this._def.coerce && (t.data = !!t.data),
            this._getType(t) !== Ae.boolean) {
                const r = this._getOrReturnCtx(t);
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.boolean,
                    received: r.parsedType
                }),
                He
            }
            return Tn(t.data)
        }
    }
    _u.create = e => new _u({
        typeName: qe.ZodBoolean,
        coerce: e?.coerce || !1,
        ...Je(e)
    });
    class ca extends rt {
        _parse(t) {
            if (this._def.coerce && (t.data = new Date(t.data)),
            this._getType(t) !== Ae.date) {
                const o = this._getOrReturnCtx(t);
                return be(o, {
                    code: me.invalid_type,
                    expected: Ae.date,
                    received: o.parsedType
                }),
                He
            }
            if (isNaN(t.data.getTime())) {
                const o = this._getOrReturnCtx(t);
                return be(o, {
                    code: me.invalid_date
                }),
                He
            }
            const r = new gn;
            let s;
            for (const o of this._def.checks)
                o.kind === "min" ? t.data.getTime() < o.value && (s = this._getOrReturnCtx(t, s),
                be(s, {
                    code: me.too_small,
                    message: o.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: o.value,
                    type: "date"
                }),
                r.dirty()) : o.kind === "max" ? t.data.getTime() > o.value && (s = this._getOrReturnCtx(t, s),
                be(s, {
                    code: me.too_big,
                    message: o.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: o.value,
                    type: "date"
                }),
                r.dirty()) : ht.assertNever(o);
            return {
                status: r.value,
                value: new Date(t.data.getTime())
            }
        }
        _addCheck(t) {
            return new ca({
                ...this._def,
                checks: [...this._def.checks, t]
            })
        }
        min(t, n) {
            return this._addCheck({
                kind: "min",
                value: t.getTime(),
                message: Me.toString(n)
            })
        }
        max(t, n) {
            return this._addCheck({
                kind: "max",
                value: t.getTime(),
                message: Me.toString(n)
            })
        }
        get minDate() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "min" && (t === null || n.value > t) && (t = n.value);
            return t != null ? new Date(t) : null
        }
        get maxDate() {
            let t = null;
            for (const n of this._def.checks)
                n.kind === "max" && (t === null || n.value < t) && (t = n.value);
            return t != null ? new Date(t) : null
        }
    }
    ca.create = e => new ca({
        checks: [],
        coerce: e?.coerce || !1,
        typeName: qe.ZodDate,
        ...Je(e)
    });
    class Qf extends rt {
        _parse(t) {
            if (this._getType(t) !== Ae.symbol) {
                const r = this._getOrReturnCtx(t);
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.symbol,
                    received: r.parsedType
                }),
                He
            }
            return Tn(t.data)
        }
    }
    Qf.create = e => new Qf({
        typeName: qe.ZodSymbol,
        ...Je(e)
    });
    class vu extends rt {
        _parse(t) {
            if (this._getType(t) !== Ae.undefined) {
                const r = this._getOrReturnCtx(t);
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.undefined,
                    received: r.parsedType
                }),
                He
            }
            return Tn(t.data)
        }
    }
    vu.create = e => new vu({
        typeName: qe.ZodUndefined,
        ...Je(e)
    });
    class wu extends rt {
        _parse(t) {
            if (this._getType(t) !== Ae.null) {
                const r = this._getOrReturnCtx(t);
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.null,
                    received: r.parsedType
                }),
                He
            }
            return Tn(t.data)
        }
    }
    wu.create = e => new wu({
        typeName: qe.ZodNull,
        ...Je(e)
    });
    class Eo extends rt {
        constructor() {
            super(...arguments),
            this._any = !0
        }
        _parse(t) {
            return Tn(t.data)
        }
    }
    Eo.create = e => new Eo({
        typeName: qe.ZodAny,
        ...Je(e)
    });
    class ra extends rt {
        constructor() {
            super(...arguments),
            this._unknown = !0
        }
        _parse(t) {
            return Tn(t.data)
        }
    }
    ra.create = e => new ra({
        typeName: qe.ZodUnknown,
        ...Je(e)
    });
    class ji extends rt {
        _parse(t) {
            const n = this._getOrReturnCtx(t);
            return be(n, {
                code: me.invalid_type,
                expected: Ae.never,
                received: n.parsedType
            }),
            He
        }
    }
    ji.create = e => new ji({
        typeName: qe.ZodNever,
        ...Je(e)
    });
    class ed extends rt {
        _parse(t) {
            if (this._getType(t) !== Ae.undefined) {
                const r = this._getOrReturnCtx(t);
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.void,
                    received: r.parsedType
                }),
                He
            }
            return Tn(t.data)
        }
    }
    ed.create = e => new ed({
        typeName: qe.ZodVoid,
        ...Je(e)
    });
    class Cr extends rt {
        _parse(t) {
            const {ctx: n, status: r} = this._processInputParams(t)
              , s = this._def;
            if (n.parsedType !== Ae.array)
                return be(n, {
                    code: me.invalid_type,
                    expected: Ae.array,
                    received: n.parsedType
                }),
                He;
            if (s.exactLength !== null) {
                const c = n.data.length > s.exactLength.value
                  , l = n.data.length < s.exactLength.value;
                (c || l) && (be(n, {
                    code: c ? me.too_big : me.too_small,
                    minimum: l ? s.exactLength.value : void 0,
                    maximum: c ? s.exactLength.value : void 0,
                    type: "array",
                    inclusive: !0,
                    exact: !0,
                    message: s.exactLength.message
                }),
                r.dirty())
            }
            if (s.minLength !== null && n.data.length < s.minLength.value && (be(n, {
                code: me.too_small,
                minimum: s.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: s.minLength.message
            }),
            r.dirty()),
            s.maxLength !== null && n.data.length > s.maxLength.value && (be(n, {
                code: me.too_big,
                maximum: s.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: s.maxLength.message
            }),
            r.dirty()),
            n.common.async)
                return Promise.all([...n.data].map( (c, l) => s.type._parseAsync(new ri(n,c,n.path,l)))).then(c => gn.mergeArray(r, c));
            const o = [...n.data].map( (c, l) => s.type._parseSync(new ri(n,c,n.path,l)));
            return gn.mergeArray(r, o)
        }
        get element() {
            return this._def.type
        }
        min(t, n) {
            return new Cr({
                ...this._def,
                minLength: {
                    value: t,
                    message: Me.toString(n)
                }
            })
        }
        max(t, n) {
            return new Cr({
                ...this._def,
                maxLength: {
                    value: t,
                    message: Me.toString(n)
                }
            })
        }
        length(t, n) {
            return new Cr({
                ...this._def,
                exactLength: {
                    value: t,
                    message: Me.toString(n)
                }
            })
        }
        nonempty(t) {
            return this.min(1, t)
        }
    }
    Cr.create = (e, t) => new Cr({
        type: e,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: qe.ZodArray,
        ...Je(t)
    });
    function ro(e) {
        if (e instanceof Lt) {
            const t = {};
            for (const n in e.shape) {
                const r = e.shape[n];
                t[n] = ti.create(ro(r))
            }
            return new Lt({
                ...e._def,
                shape: () => t
            })
        } else
            return e instanceof Cr ? new Cr({
                ...e._def,
                type: ro(e.element)
            }) : e instanceof ti ? ti.create(ro(e.unwrap())) : e instanceof Os ? Os.create(ro(e.unwrap())) : e instanceof ii ? ii.create(e.items.map(t => ro(t))) : e
    }
    class Lt extends rt {
        constructor() {
            super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const t = this._def.shape()
              , n = ht.objectKeys(t);
            return this._cached = {
                shape: t,
                keys: n
            }
        }
        _parse(t) {
            if (this._getType(t) !== Ae.object) {
                const d = this._getOrReturnCtx(t);
                return be(d, {
                    code: me.invalid_type,
                    expected: Ae.object,
                    received: d.parsedType
                }),
                He
            }
            const {status: r, ctx: s} = this._processInputParams(t)
              , {shape: o, keys: c} = this._getCached()
              , l = [];
            if (!(this._def.catchall instanceof ji && this._def.unknownKeys === "strip"))
                for (const d in s.data)
                    c.includes(d) || l.push(d);
            const f = [];
            for (const d of c) {
                const h = o[d]
                  , y = s.data[d];
                f.push({
                    key: {
                        status: "valid",
                        value: d
                    },
                    value: h._parse(new ri(s,y,s.path,d)),
                    alwaysSet: d in s.data
                })
            }
            if (this._def.catchall instanceof ji) {
                const d = this._def.unknownKeys;
                if (d === "passthrough")
                    for (const h of l)
                        f.push({
                            key: {
                                status: "valid",
                                value: h
                            },
                            value: {
                                status: "valid",
                                value: s.data[h]
                            }
                        });
                else if (d === "strict")
                    l.length > 0 && (be(s, {
                        code: me.unrecognized_keys,
                        keys: l
                    }),
                    r.dirty());
                else if (d !== "strip")
                    throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                const d = this._def.catchall;
                for (const h of l) {
                    const y = s.data[h];
                    f.push({
                        key: {
                            status: "valid",
                            value: h
                        },
                        value: d._parse(new ri(s,y,s.path,h)),
                        alwaysSet: h in s.data
                    })
                }
            }
            return s.common.async ? Promise.resolve().then(async () => {
                const d = [];
                for (const h of f) {
                    const y = await h.key
                      , I = await h.value;
                    d.push({
                        key: y,
                        value: I,
                        alwaysSet: h.alwaysSet
                    })
                }
                return d
            }
            ).then(d => gn.mergeObjectSync(r, d)) : gn.mergeObjectSync(r, f)
        }
        get shape() {
            return this._def.shape()
        }
        strict(t) {
            return Me.errToObj,
            new Lt({
                ...this._def,
                unknownKeys: "strict",
                ...t !== void 0 ? {
                    errorMap: (n, r) => {
                        var s, o, c, l;
                        const f = (c = (o = (s = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(s, n, r).message) !== null && c !== void 0 ? c : r.defaultError;
                        return n.code === "unrecognized_keys" ? {
                            message: (l = Me.errToObj(t).message) !== null && l !== void 0 ? l : f
                        } : {
                            message: f
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new Lt({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new Lt({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        extend(t) {
            return new Lt({
                ...this._def,
                shape: () => ({
                    ...this._def.shape(),
                    ...t
                })
            })
        }
        merge(t) {
            return new Lt({
                unknownKeys: t._def.unknownKeys,
                catchall: t._def.catchall,
                shape: () => ({
                    ...this._def.shape(),
                    ...t._def.shape()
                }),
                typeName: qe.ZodObject
            })
        }
        setKey(t, n) {
            return this.augment({
                [t]: n
            })
        }
        catchall(t) {
            return new Lt({
                ...this._def,
                catchall: t
            })
        }
        pick(t) {
            const n = {};
            return ht.objectKeys(t).forEach(r => {
                t[r] && this.shape[r] && (n[r] = this.shape[r])
            }
            ),
            new Lt({
                ...this._def,
                shape: () => n
            })
        }
        omit(t) {
            const n = {};
            return ht.objectKeys(this.shape).forEach(r => {
                t[r] || (n[r] = this.shape[r])
            }
            ),
            new Lt({
                ...this._def,
                shape: () => n
            })
        }
        deepPartial() {
            return ro(this)
        }
        partial(t) {
            const n = {};
            return ht.objectKeys(this.shape).forEach(r => {
                const s = this.shape[r];
                t && !t[r] ? n[r] = s : n[r] = s.optional()
            }
            ),
            new Lt({
                ...this._def,
                shape: () => n
            })
        }
        required(t) {
            const n = {};
            return ht.objectKeys(this.shape).forEach(r => {
                if (t && !t[r])
                    n[r] = this.shape[r];
                else {
                    let o = this.shape[r];
                    for (; o instanceof ti; )
                        o = o._def.innerType;
                    n[r] = o
                }
            }
            ),
            new Lt({
                ...this._def,
                shape: () => n
            })
        }
        keyof() {
            return vE(ht.objectKeys(this.shape))
        }
    }
    Lt.create = (e, t) => new Lt({
        shape: () => e,
        unknownKeys: "strip",
        catchall: ji.create(),
        typeName: qe.ZodObject,
        ...Je(t)
    });
    Lt.strictCreate = (e, t) => new Lt({
        shape: () => e,
        unknownKeys: "strict",
        catchall: ji.create(),
        typeName: qe.ZodObject,
        ...Je(t)
    });
    Lt.lazycreate = (e, t) => new Lt({
        shape: e,
        unknownKeys: "strip",
        catchall: ji.create(),
        typeName: qe.ZodObject,
        ...Je(t)
    });
    class bu extends rt {
        _parse(t) {
            const {ctx: n} = this._processInputParams(t)
              , r = this._def.options;
            function s(o) {
                for (const l of o)
                    if (l.result.status === "valid")
                        return l.result;
                for (const l of o)
                    if (l.result.status === "dirty")
                        return n.common.issues.push(...l.ctx.common.issues),
                        l.result;
                const c = o.map(l => new Yn(l.ctx.common.issues));
                return be(n, {
                    code: me.invalid_union,
                    unionErrors: c
                }),
                He
            }
            if (n.common.async)
                return Promise.all(r.map(async o => {
                    const c = {
                        ...n,
                        common: {
                            ...n.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await o._parseAsync({
                            data: n.data,
                            path: n.path,
                            parent: c
                        }),
                        ctx: c
                    }
                }
                )).then(s);
            {
                let o;
                const c = [];
                for (const f of r) {
                    const d = {
                        ...n,
                        common: {
                            ...n.common,
                            issues: []
                        },
                        parent: null
                    }
                      , h = f._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: d
                    });
                    if (h.status === "valid")
                        return h;
                    h.status === "dirty" && !o && (o = {
                        result: h,
                        ctx: d
                    }),
                    d.common.issues.length && c.push(d.common.issues)
                }
                if (o)
                    return n.common.issues.push(...o.ctx.common.issues),
                    o.result;
                const l = c.map(f => new Yn(f));
                return be(n, {
                    code: me.invalid_union,
                    unionErrors: l
                }),
                He
            }
        }
        get options() {
            return this._def.options
        }
    }
    bu.create = (e, t) => new bu({
        options: e,
        typeName: qe.ZodUnion,
        ...Je(t)
    });
    const Ni = e => e instanceof Tu ? Ni(e.schema) : e instanceof Dr ? Ni(e.innerType()) : e instanceof Au ? [e.value] : e instanceof As ? e.options : e instanceof Ou ? ht.objectValues(e.enum) : e instanceof Iu ? Ni(e._def.innerType) : e instanceof vu ? [void 0] : e instanceof wu ? [null] : e instanceof ti ? [void 0, ...Ni(e.unwrap())] : e instanceof Os ? [null, ...Ni(e.unwrap())] : e instanceof _0 || e instanceof xu ? Ni(e.unwrap()) : e instanceof Nu ? Ni(e._def.innerType) : [];
    class Dd extends rt {
        _parse(t) {
            const {ctx: n} = this._processInputParams(t);
            if (n.parsedType !== Ae.object)
                return be(n, {
                    code: me.invalid_type,
                    expected: Ae.object,
                    received: n.parsedType
                }),
                He;
            const r = this.discriminator
              , s = n.data[r]
              , o = this.optionsMap.get(s);
            return o ? n.common.async ? o._parseAsync({
                data: n.data,
                path: n.path,
                parent: n
            }) : o._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            }) : (be(n, {
                code: me.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [r]
            }),
            He)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get options() {
            return this._def.options
        }
        get optionsMap() {
            return this._def.optionsMap
        }
        static create(t, n, r) {
            const s = new Map;
            for (const o of n) {
                const c = Ni(o.shape[t]);
                if (!c.length)
                    throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
                for (const l of c) {
                    if (s.has(l))
                        throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(l)}`);
                    s.set(l, o)
                }
            }
            return new Dd({
                typeName: qe.ZodDiscriminatedUnion,
                discriminator: t,
                options: n,
                optionsMap: s,
                ...Je(r)
            })
        }
    }
    function Tm(e, t) {
        const n = gs(e)
          , r = gs(t);
        if (e === t)
            return {
                valid: !0,
                data: e
            };
        if (n === Ae.object && r === Ae.object) {
            const s = ht.objectKeys(t)
              , o = ht.objectKeys(e).filter(l => s.indexOf(l) !== -1)
              , c = {
                ...e,
                ...t
            };
            for (const l of o) {
                const f = Tm(e[l], t[l]);
                if (!f.valid)
                    return {
                        valid: !1
                    };
                c[l] = f.data
            }
            return {
                valid: !0,
                data: c
            }
        } else if (n === Ae.array && r === Ae.array) {
            if (e.length !== t.length)
                return {
                    valid: !1
                };
            const s = [];
            for (let o = 0; o < e.length; o++) {
                const c = e[o]
                  , l = t[o]
                  , f = Tm(c, l);
                if (!f.valid)
                    return {
                        valid: !1
                    };
                s.push(f.data)
            }
            return {
                valid: !0,
                data: s
            }
        } else
            return n === Ae.date && r === Ae.date && +e == +t ? {
                valid: !0,
                data: e
            } : {
                valid: !1
            }
    }
    class Eu extends rt {
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t)
              , s = (o, c) => {
                if (Em(o) || Em(c))
                    return He;
                const l = Tm(o.value, c.value);
                return l.valid ? ((Sm(o) || Sm(c)) && n.dirty(),
                {
                    status: n.value,
                    value: l.data
                }) : (be(r, {
                    code: me.invalid_intersection_types
                }),
                He)
            }
            ;
            return r.common.async ? Promise.all([this._def.left._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }), this._def.right._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            })]).then( ([o,c]) => s(o, c)) : s(this._def.left._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            }), this._def.right._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            }))
        }
    }
    Eu.create = (e, t, n) => new Eu({
        left: e,
        right: t,
        typeName: qe.ZodIntersection,
        ...Je(n)
    });
    class ii extends rt {
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t);
            if (r.parsedType !== Ae.array)
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.array,
                    received: r.parsedType
                }),
                He;
            if (r.data.length < this._def.items.length)
                return be(r, {
                    code: me.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }),
                He;
            !this._def.rest && r.data.length > this._def.items.length && (be(r, {
                code: me.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            n.dirty());
            const o = [...r.data].map( (c, l) => {
                const f = this._def.items[l] || this._def.rest;
                return f ? f._parse(new ri(r,c,r.path,l)) : null
            }
            ).filter(c => !!c);
            return r.common.async ? Promise.all(o).then(c => gn.mergeArray(n, c)) : gn.mergeArray(n, o)
        }
        get items() {
            return this._def.items
        }
        rest(t) {
            return new ii({
                ...this._def,
                rest: t
            })
        }
    }
    ii.create = (e, t) => {
        if (!Array.isArray(e))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new ii({
            items: e,
            typeName: qe.ZodTuple,
            rest: null,
            ...Je(t)
        })
    }
    ;
    class Su extends rt {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t);
            if (r.parsedType !== Ae.object)
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.object,
                    received: r.parsedType
                }),
                He;
            const s = []
              , o = this._def.keyType
              , c = this._def.valueType;
            for (const l in r.data)
                s.push({
                    key: o._parse(new ri(r,l,r.path,l)),
                    value: c._parse(new ri(r,r.data[l],r.path,l)),
                    alwaysSet: l in r.data
                });
            return r.common.async ? gn.mergeObjectAsync(n, s) : gn.mergeObjectSync(n, s)
        }
        get element() {
            return this._def.valueType
        }
        static create(t, n, r) {
            return n instanceof rt ? new Su({
                keyType: t,
                valueType: n,
                typeName: qe.ZodRecord,
                ...Je(r)
            }) : new Su({
                keyType: Pr.create(),
                valueType: t,
                typeName: qe.ZodRecord,
                ...Je(n)
            })
        }
    }
    class td extends rt {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t);
            if (r.parsedType !== Ae.map)
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.map,
                    received: r.parsedType
                }),
                He;
            const s = this._def.keyType
              , o = this._def.valueType
              , c = [...r.data.entries()].map( ([l,f], d) => ({
                key: s._parse(new ri(r,l,r.path,[d, "key"])),
                value: o._parse(new ri(r,f,r.path,[d, "value"]))
            }));
            if (r.common.async) {
                const l = new Map;
                return Promise.resolve().then(async () => {
                    for (const f of c) {
                        const d = await f.key
                          , h = await f.value;
                        if (d.status === "aborted" || h.status === "aborted")
                            return He;
                        (d.status === "dirty" || h.status === "dirty") && n.dirty(),
                        l.set(d.value, h.value)
                    }
                    return {
                        status: n.value,
                        value: l
                    }
                }
                )
            } else {
                const l = new Map;
                for (const f of c) {
                    const d = f.key
                      , h = f.value;
                    if (d.status === "aborted" || h.status === "aborted")
                        return He;
                    (d.status === "dirty" || h.status === "dirty") && n.dirty(),
                    l.set(d.value, h.value)
                }
                return {
                    status: n.value,
                    value: l
                }
            }
        }
    }
    td.create = (e, t, n) => new td({
        valueType: t,
        keyType: e,
        typeName: qe.ZodMap,
        ...Je(n)
    });
    class ua extends rt {
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t);
            if (r.parsedType !== Ae.set)
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.set,
                    received: r.parsedType
                }),
                He;
            const s = this._def;
            s.minSize !== null && r.data.size < s.minSize.value && (be(r, {
                code: me.too_small,
                minimum: s.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: s.minSize.message
            }),
            n.dirty()),
            s.maxSize !== null && r.data.size > s.maxSize.value && (be(r, {
                code: me.too_big,
                maximum: s.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: s.maxSize.message
            }),
            n.dirty());
            const o = this._def.valueType;
            function c(f) {
                const d = new Set;
                for (const h of f) {
                    if (h.status === "aborted")
                        return He;
                    h.status === "dirty" && n.dirty(),
                    d.add(h.value)
                }
                return {
                    status: n.value,
                    value: d
                }
            }
            const l = [...r.data.values()].map( (f, d) => o._parse(new ri(r,f,r.path,d)));
            return r.common.async ? Promise.all(l).then(f => c(f)) : c(l)
        }
        min(t, n) {
            return new ua({
                ...this._def,
                minSize: {
                    value: t,
                    message: Me.toString(n)
                }
            })
        }
        max(t, n) {
            return new ua({
                ...this._def,
                maxSize: {
                    value: t,
                    message: Me.toString(n)
                }
            })
        }
        size(t, n) {
            return this.min(t, n).max(t, n)
        }
        nonempty(t) {
            return this.min(1, t)
        }
    }
    ua.create = (e, t) => new ua({
        valueType: e,
        minSize: null,
        maxSize: null,
        typeName: qe.ZodSet,
        ...Je(t)
    });
    class _o extends rt {
        constructor() {
            super(...arguments),
            this.validate = this.implement
        }
        _parse(t) {
            const {ctx: n} = this._processInputParams(t);
            if (n.parsedType !== Ae.function)
                return be(n, {
                    code: me.invalid_type,
                    expected: Ae.function,
                    received: n.parsedType
                }),
                He;
            function r(l, f) {
                return Jf({
                    data: l,
                    path: n.path,
                    errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Kf(), bo].filter(d => !!d),
                    issueData: {
                        code: me.invalid_arguments,
                        argumentsError: f
                    }
                })
            }
            function s(l, f) {
                return Jf({
                    data: l,
                    path: n.path,
                    errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Kf(), bo].filter(d => !!d),
                    issueData: {
                        code: me.invalid_return_type,
                        returnTypeError: f
                    }
                })
            }
            const o = {
                errorMap: n.common.contextualErrorMap
            }
              , c = n.data;
            if (this._def.returns instanceof So) {
                const l = this;
                return Tn(async function(...f) {
                    const d = new Yn([])
                      , h = await l._def.args.parseAsync(f, o).catch($ => {
                        throw d.addIssue(r(f, $)),
                        d
                    }
                    )
                      , y = await Reflect.apply(c, this, h);
                    return await l._def.returns._def.type.parseAsync(y, o).catch($ => {
                        throw d.addIssue(s(y, $)),
                        d
                    }
                    )
                })
            } else {
                const l = this;
                return Tn(function(...f) {
                    const d = l._def.args.safeParse(f, o);
                    if (!d.success)
                        throw new Yn([r(f, d.error)]);
                    const h = Reflect.apply(c, this, d.data)
                      , y = l._def.returns.safeParse(h, o);
                    if (!y.success)
                        throw new Yn([s(h, y.error)]);
                    return y.data
                })
            }
        }
        parameters() {
            return this._def.args
        }
        returnType() {
            return this._def.returns
        }
        args(...t) {
            return new _o({
                ...this._def,
                args: ii.create(t).rest(ra.create())
            })
        }
        returns(t) {
            return new _o({
                ...this._def,
                returns: t
            })
        }
        implement(t) {
            return this.parse(t)
        }
        strictImplement(t) {
            return this.parse(t)
        }
        static create(t, n, r) {
            return new _o({
                args: t || ii.create([]).rest(ra.create()),
                returns: n || ra.create(),
                typeName: qe.ZodFunction,
                ...Je(r)
            })
        }
    }
    class Tu extends rt {
        get schema() {
            return this._def.getter()
        }
        _parse(t) {
            const {ctx: n} = this._processInputParams(t);
            return this._def.getter()._parse({
                data: n.data,
                path: n.path,
                parent: n
            })
        }
    }
    Tu.create = (e, t) => new Tu({
        getter: e,
        typeName: qe.ZodLazy,
        ...Je(t)
    });
    class Au extends rt {
        _parse(t) {
            if (t.data !== this._def.value) {
                const n = this._getOrReturnCtx(t);
                return be(n, {
                    received: n.data,
                    code: me.invalid_literal,
                    expected: this._def.value
                }),
                He
            }
            return {
                status: "valid",
                value: t.data
            }
        }
        get value() {
            return this._def.value
        }
    }
    Au.create = (e, t) => new Au({
        value: e,
        typeName: qe.ZodLiteral,
        ...Je(t)
    });
    function vE(e, t) {
        return new As({
            values: e,
            typeName: qe.ZodEnum,
            ...Je(t)
        })
    }
    class As extends rt {
        constructor() {
            super(...arguments),
            zc.set(this, void 0)
        }
        _parse(t) {
            if (typeof t.data != "string") {
                const n = this._getOrReturnCtx(t)
                  , r = this._def.values;
                return be(n, {
                    expected: ht.joinValues(r),
                    received: n.parsedType,
                    code: me.invalid_type
                }),
                He
            }
            if (Xf(this, zc) || mE(this, zc, new Set(this._def.values)),
            !Xf(this, zc).has(t.data)) {
                const n = this._getOrReturnCtx(t)
                  , r = this._def.values;
                return be(n, {
                    received: n.data,
                    code: me.invalid_enum_value,
                    options: r
                }),
                He
            }
            return Tn(t.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            const t = {};
            for (const n of this._def.values)
                t[n] = n;
            return t
        }
        get Values() {
            const t = {};
            for (const n of this._def.values)
                t[n] = n;
            return t
        }
        get Enum() {
            const t = {};
            for (const n of this._def.values)
                t[n] = n;
            return t
        }
        extract(t, n=this._def) {
            return As.create(t, {
                ...this._def,
                ...n
            })
        }
        exclude(t, n=this._def) {
            return As.create(this.options.filter(r => !t.includes(r)), {
                ...this._def,
                ...n
            })
        }
    }
    zc = new WeakMap;
    As.create = vE;
    class Ou extends rt {
        constructor() {
            super(...arguments),
            Gc.set(this, void 0)
        }
        _parse(t) {
            const n = ht.getValidEnumValues(this._def.values)
              , r = this._getOrReturnCtx(t);
            if (r.parsedType !== Ae.string && r.parsedType !== Ae.number) {
                const s = ht.objectValues(n);
                return be(r, {
                    expected: ht.joinValues(s),
                    received: r.parsedType,
                    code: me.invalid_type
                }),
                He
            }
            if (Xf(this, Gc) || mE(this, Gc, new Set(ht.getValidEnumValues(this._def.values))),
            !Xf(this, Gc).has(t.data)) {
                const s = ht.objectValues(n);
                return be(r, {
                    received: r.data,
                    code: me.invalid_enum_value,
                    options: s
                }),
                He
            }
            return Tn(t.data)
        }
        get enum() {
            return this._def.values
        }
    }
    Gc = new WeakMap;
    Ou.create = (e, t) => new Ou({
        values: e,
        typeName: qe.ZodNativeEnum,
        ...Je(t)
    });
    class So extends rt {
        unwrap() {
            return this._def.type
        }
        _parse(t) {
            const {ctx: n} = this._processInputParams(t);
            if (n.parsedType !== Ae.promise && n.common.async === !1)
                return be(n, {
                    code: me.invalid_type,
                    expected: Ae.promise,
                    received: n.parsedType
                }),
                He;
            const r = n.parsedType === Ae.promise ? n.data : Promise.resolve(n.data);
            return Tn(r.then(s => this._def.type.parseAsync(s, {
                path: n.path,
                errorMap: n.common.contextualErrorMap
            })))
        }
    }
    So.create = (e, t) => new So({
        type: e,
        typeName: qe.ZodPromise,
        ...Je(t)
    });
    class Dr extends rt {
        innerType() {
            return this._def.schema
        }
        sourceType() {
            return this._def.schema._def.typeName === qe.ZodEffects ? this._def.schema.sourceType() : this._def.schema
        }
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t)
              , s = this._def.effect || null
              , o = {
                addIssue: c => {
                    be(r, c),
                    c.fatal ? n.abort() : n.dirty()
                }
                ,
                get path() {
                    return r.path
                }
            };
            if (o.addIssue = o.addIssue.bind(o),
            s.type === "preprocess") {
                const c = s.transform(r.data, o);
                if (r.common.async)
                    return Promise.resolve(c).then(async l => {
                        if (n.value === "aborted")
                            return He;
                        const f = await this._def.schema._parseAsync({
                            data: l,
                            path: r.path,
                            parent: r
                        });
                        return f.status === "aborted" ? He : f.status === "dirty" || n.value === "dirty" ? ao(f.value) : f
                    }
                    );
                {
                    if (n.value === "aborted")
                        return He;
                    const l = this._def.schema._parseSync({
                        data: c,
                        path: r.path,
                        parent: r
                    });
                    return l.status === "aborted" ? He : l.status === "dirty" || n.value === "dirty" ? ao(l.value) : l
                }
            }
            if (s.type === "refinement") {
                const c = l => {
                    const f = s.refinement(l, o);
                    if (r.common.async)
                        return Promise.resolve(f);
                    if (f instanceof Promise)
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return l
                }
                ;
                if (r.common.async === !1) {
                    const l = this._def.schema._parseSync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    });
                    return l.status === "aborted" ? He : (l.status === "dirty" && n.dirty(),
                    c(l.value),
                    {
                        status: n.value,
                        value: l.value
                    })
                } else
                    return this._def.schema._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    }).then(l => l.status === "aborted" ? He : (l.status === "dirty" && n.dirty(),
                    c(l.value).then( () => ({
                        status: n.value,
                        value: l.value
                    }))))
            }
            if (s.type === "transform")
                if (r.common.async === !1) {
                    const c = this._def.schema._parseSync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    });
                    if (!gu(c))
                        return c;
                    const l = s.transform(c.value, o);
                    if (l instanceof Promise)
                        throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: n.value,
                        value: l
                    }
                } else
                    return this._def.schema._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    }).then(c => gu(c) ? Promise.resolve(s.transform(c.value, o)).then(l => ({
                        status: n.value,
                        value: l
                    })) : c);
            ht.assertNever(s)
        }
    }
    Dr.create = (e, t, n) => new Dr({
        schema: e,
        typeName: qe.ZodEffects,
        effect: t,
        ...Je(n)
    });
    Dr.createWithPreprocess = (e, t, n) => new Dr({
        schema: t,
        effect: {
            type: "preprocess",
            transform: e
        },
        typeName: qe.ZodEffects,
        ...Je(n)
    });
    class ti extends rt {
        _parse(t) {
            return this._getType(t) === Ae.undefined ? Tn(void 0) : this._def.innerType._parse(t)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    ti.create = (e, t) => new ti({
        innerType: e,
        typeName: qe.ZodOptional,
        ...Je(t)
    });
    class Os extends rt {
        _parse(t) {
            return this._getType(t) === Ae.null ? Tn(null) : this._def.innerType._parse(t)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    Os.create = (e, t) => new Os({
        innerType: e,
        typeName: qe.ZodNullable,
        ...Je(t)
    });
    class Iu extends rt {
        _parse(t) {
            const {ctx: n} = this._processInputParams(t);
            let r = n.data;
            return n.parsedType === Ae.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({
                data: r,
                path: n.path,
                parent: n
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    }
    Iu.create = (e, t) => new Iu({
        innerType: e,
        typeName: qe.ZodDefault,
        defaultValue: typeof t.default == "function" ? t.default : () => t.default,
        ...Je(t)
    });
    class Nu extends rt {
        _parse(t) {
            const {ctx: n} = this._processInputParams(t)
              , r = {
                ...n,
                common: {
                    ...n.common,
                    issues: []
                }
            }
              , s = this._def.innerType._parse({
                data: r.data,
                path: r.path,
                parent: {
                    ...r
                }
            });
            return yu(s) ? s.then(o => ({
                status: "valid",
                value: o.status === "valid" ? o.value : this._def.catchValue({
                    get error() {
                        return new Yn(r.common.issues)
                    },
                    input: r.data
                })
            })) : {
                status: "valid",
                value: s.status === "valid" ? s.value : this._def.catchValue({
                    get error() {
                        return new Yn(r.common.issues)
                    },
                    input: r.data
                })
            }
        }
        removeCatch() {
            return this._def.innerType
        }
    }
    Nu.create = (e, t) => new Nu({
        innerType: e,
        typeName: qe.ZodCatch,
        catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
        ...Je(t)
    });
    class nd extends rt {
        _parse(t) {
            if (this._getType(t) !== Ae.nan) {
                const r = this._getOrReturnCtx(t);
                return be(r, {
                    code: me.invalid_type,
                    expected: Ae.nan,
                    received: r.parsedType
                }),
                He
            }
            return {
                status: "valid",
                value: t.data
            }
        }
    }
    nd.create = e => new nd({
        typeName: qe.ZodNaN,
        ...Je(e)
    });
    const tj = Symbol("zod_brand");
    class _0 extends rt {
        _parse(t) {
            const {ctx: n} = this._processInputParams(t)
              , r = n.data;
            return this._def.type._parse({
                data: r,
                path: n.path,
                parent: n
            })
        }
        unwrap() {
            return this._def.type
        }
    }
    class Hu extends rt {
        _parse(t) {
            const {status: n, ctx: r} = this._processInputParams(t);
            if (r.common.async)
                return (async () => {
                    const o = await this._def.in._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    });
                    return o.status === "aborted" ? He : o.status === "dirty" ? (n.dirty(),
                    ao(o.value)) : this._def.out._parseAsync({
                        data: o.value,
                        path: r.path,
                        parent: r
                    })
                }
                )();
            {
                const s = this._def.in._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return s.status === "aborted" ? He : s.status === "dirty" ? (n.dirty(),
                {
                    status: "dirty",
                    value: s.value
                }) : this._def.out._parseSync({
                    data: s.value,
                    path: r.path,
                    parent: r
                })
            }
        }
        static create(t, n) {
            return new Hu({
                in: t,
                out: n,
                typeName: qe.ZodPipeline
            })
        }
    }
    class xu extends rt {
        _parse(t) {
            const n = this._def.innerType._parse(t)
              , r = s => (gu(s) && (s.value = Object.freeze(s.value)),
            s);
            return yu(n) ? n.then(s => r(s)) : r(n)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    xu.create = (e, t) => new xu({
        innerType: e,
        typeName: qe.ZodReadonly,
        ...Je(t)
    });
    function wE(e, t={}, n) {
        return e ? Eo.create().superRefine( (r, s) => {
            var o, c;
            if (!e(r)) {
                const l = typeof t == "function" ? t(r) : typeof t == "string" ? {
                    message: t
                } : t
                  , f = (c = (o = l.fatal) !== null && o !== void 0 ? o : n) !== null && c !== void 0 ? c : !0
                  , d = typeof l == "string" ? {
                    message: l
                } : l;
                s.addIssue({
                    code: "custom",
                    ...d,
                    fatal: f
                })
            }
        }
        ) : Eo.create()
    }
    const nj = {
        object: Lt.lazycreate
    };
    var qe;
    (function(e) {
        e.ZodString = "ZodString",
        e.ZodNumber = "ZodNumber",
        e.ZodNaN = "ZodNaN",
        e.ZodBigInt = "ZodBigInt",
        e.ZodBoolean = "ZodBoolean",
        e.ZodDate = "ZodDate",
        e.ZodSymbol = "ZodSymbol",
        e.ZodUndefined = "ZodUndefined",
        e.ZodNull = "ZodNull",
        e.ZodAny = "ZodAny",
        e.ZodUnknown = "ZodUnknown",
        e.ZodNever = "ZodNever",
        e.ZodVoid = "ZodVoid",
        e.ZodArray = "ZodArray",
        e.ZodObject = "ZodObject",
        e.ZodUnion = "ZodUnion",
        e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        e.ZodIntersection = "ZodIntersection",
        e.ZodTuple = "ZodTuple",
        e.ZodRecord = "ZodRecord",
        e.ZodMap = "ZodMap",
        e.ZodSet = "ZodSet",
        e.ZodFunction = "ZodFunction",
        e.ZodLazy = "ZodLazy",
        e.ZodLiteral = "ZodLiteral",
        e.ZodEnum = "ZodEnum",
        e.ZodEffects = "ZodEffects",
        e.ZodNativeEnum = "ZodNativeEnum",
        e.ZodOptional = "ZodOptional",
        e.ZodNullable = "ZodNullable",
        e.ZodDefault = "ZodDefault",
        e.ZodCatch = "ZodCatch",
        e.ZodPromise = "ZodPromise",
        e.ZodBranded = "ZodBranded",
        e.ZodPipeline = "ZodPipeline",
        e.ZodReadonly = "ZodReadonly"
    }
    )(qe || (qe = {}));
    const rj = (e, t={
        message: `Input not instance of ${e.name}`
    }) => wE(n => n instanceof e, t)
      , bE = Pr.create
      , EE = Ss.create
      , ij = nd.create
      , sj = Ts.create
      , SE = _u.create
      , aj = ca.create
      , oj = Qf.create
      , cj = vu.create
      , uj = wu.create
      , lj = Eo.create
      , fj = ra.create
      , dj = ji.create
      , hj = ed.create
      , pj = Cr.create
      , mj = Lt.create
      , gj = Lt.strictCreate
      , yj = bu.create
      , _j = Dd.create
      , vj = Eu.create
      , wj = ii.create
      , bj = Su.create
      , Ej = td.create
      , Sj = ua.create
      , Tj = _o.create
      , Aj = Tu.create
      , Oj = Au.create
      , Ij = As.create
      , Nj = Ou.create
      , xj = So.create
      , Fv = Dr.create
      , $j = ti.create
      , Rj = Os.create
      , Pj = Dr.createWithPreprocess
      , kj = Hu.create
      , Cj = () => bE().optional()
      , Mj = () => EE().optional()
      , Lj = () => SE().optional()
      , Dj = {
        string: e => Pr.create({
            ...e,
            coerce: !0
        }),
        number: e => Ss.create({
            ...e,
            coerce: !0
        }),
        boolean: e => _u.create({
            ...e,
            coerce: !0
        }),
        bigint: e => Ts.create({
            ...e,
            coerce: !0
        }),
        date: e => ca.create({
            ...e,
            coerce: !0
        })
    }
      , Uj = He;
    var Gr = Object.freeze({
        __proto__: null,
        defaultErrorMap: bo,
        setErrorMap: UF,
        getErrorMap: Kf,
        makeIssue: Jf,
        EMPTY_PATH: BF,
        addIssueToContext: be,
        ParseStatus: gn,
        INVALID: He,
        DIRTY: ao,
        OK: Tn,
        isAborted: Em,
        isDirty: Sm,
        isValid: gu,
        isAsync: yu,
        get util() {
            return ht
        },
        get objectUtil() {
            return bm
        },
        ZodParsedType: Ae,
        getParsedType: gs,
        ZodType: rt,
        datetimeRegex: _E,
        ZodString: Pr,
        ZodNumber: Ss,
        ZodBigInt: Ts,
        ZodBoolean: _u,
        ZodDate: ca,
        ZodSymbol: Qf,
        ZodUndefined: vu,
        ZodNull: wu,
        ZodAny: Eo,
        ZodUnknown: ra,
        ZodNever: ji,
        ZodVoid: ed,
        ZodArray: Cr,
        ZodObject: Lt,
        ZodUnion: bu,
        ZodDiscriminatedUnion: Dd,
        ZodIntersection: Eu,
        ZodTuple: ii,
        ZodRecord: Su,
        ZodMap: td,
        ZodSet: ua,
        ZodFunction: _o,
        ZodLazy: Tu,
        ZodLiteral: Au,
        ZodEnum: As,
        ZodNativeEnum: Ou,
        ZodPromise: So,
        ZodEffects: Dr,
        ZodTransformer: Dr,
        ZodOptional: ti,
        ZodNullable: Os,
        ZodDefault: Iu,
        ZodCatch: Nu,
        ZodNaN: nd,
        BRAND: tj,
        ZodBranded: _0,
        ZodPipeline: Hu,
        ZodReadonly: xu,
        custom: wE,
        Schema: rt,
        ZodSchema: rt,
        late: nj,
        get ZodFirstPartyTypeKind() {
            return qe
        },
        coerce: Dj,
        any: lj,
        array: pj,
        bigint: sj,
        boolean: SE,
        date: aj,
        discriminatedUnion: _j,
        effect: Fv,
        enum: Ij,
        function: Tj,
        instanceof: rj,
        intersection: vj,
        lazy: Aj,
        literal: Oj,
        map: Ej,
        nan: ij,
        nativeEnum: Nj,
        never: dj,
        null: uj,
        nullable: Rj,
        number: EE,
        object: mj,
        oboolean: Lj,
        onumber: Mj,
        optional: $j,
        ostring: Cj,
        pipeline: kj,
        preprocess: Pj,
        promise: xj,
        record: bj,
        set: Sj,
        strictObject: gj,
        string: bE,
        symbol: oj,
        transformer: Fv,
        tuple: wj,
        undefined: cj,
        union: yj,
        unknown: fj,
        void: hj,
        NEVER: Uj,
        ZodIssueCode: me,
        quotelessJson: DF,
        ZodError: Yn
    });
    const Bj = e => e.message ? e.message : "unspecified error";
    class rd extends Sn {
        constructor(t) {
            super(),
            this.code = hF,
            this.errors = t,
            super.message = `Web3 validator found ${t.length} error[s]:
${this._compileErrors().join(`
`)}`
        }
        _compileErrors() {
            return this.errors.map(Bj)
        }
    }
    const Fj = ["bool", "int", "uint", "bytes", "string", "address", "tuple"]
      , TE = e => typeof e == "object" && "type"in e && "name"in e
      , jj = e => typeof e == "string"
      , Ln = e => typeof e == "string" && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e)
      , qj = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"]
      , ha = e => {
        let t = e.replace(/ /, ""), n, r = !1, s = [];
        if (e.includes("[") && (t = t.slice(0, t.indexOf("[")),
        s = [...e.matchAll(/(?:\[(\d*)\])/g)].map(o => parseInt(o[1], 10)).map(o => Number.isNaN(o) ? -1 : o),
        r = s.length > 0),
        Fj.includes(t))
            return {
                baseType: t,
                isArray: r,
                baseTypeSize: n,
                arraySizes: s
            };
        if (t.startsWith("int"))
            n = parseInt(t.substring(3), 10),
            t = "int";
        else if (t.startsWith("uint"))
            n = parseInt(e.substring(4), 10),
            t = "uint";
        else if (t.startsWith("bytes"))
            n = parseInt(t.substring(5), 10),
            t = "bytes";
        else
            return {
                baseType: void 0,
                isArray: !1,
                baseTypeSize: void 0,
                arraySizes: s
            };
        return {
            baseType: t,
            isArray: r,
            baseTypeSize: n,
            arraySizes: s
        }
    }
      , $p = (e, t={}) => {
        if (Object.keys(t).includes("type"))
            throw new rd([{
                keyword: "eth",
                message: 'Either "eth" or "type" can be presented in schema',
                params: {
                    eth: e
                },
                instancePath: "",
                schemaPath: ""
            }]);
        const {baseType: r, baseTypeSize: s} = ha(e);
        if (!r && !qj.includes(e))
            throw new rd([{
                keyword: "eth",
                message: `Eth data type "${e}" is not valid`,
                params: {
                    eth: e
                },
                instancePath: "",
                schemaPath: ""
            }]);
        if (r) {
            if (r === "tuple")
                throw new Error('"tuple" type is not implemented directly.');
            return {
                format: `${r}${s ?? ""}`,
                required: !0
            }
        }
        return e ? {
            format: e,
            required: !0
        } : {}
    }
      , id = (e, t="/0") => {
        const n = {
            type: "array",
            items: [],
            maxItems: e.length,
            minItems: e.length
        };
        for (const [r,s] of e.entries()) {
            let o, c, l = [];
            TE(s) ? (o = s.type,
            c = s.name || `${t}/${r}`,
            l = s.components) : typeof s == "string" ? (o = s,
            c = `${t}/${r}`) : Array.isArray(s) && (s[0] && typeof s[0] == "string" && s[0].startsWith("tuple") && !Array.isArray(s[0]) && s[1] && Array.isArray(s[1]) ? (o = s[0],
            c = `${t}/${r}`,
            l = s[1]) : (o = "tuple",
            c = `${t}/${r}`,
            l = s));
            const {baseType: f, isArray: d, arraySizes: h} = ha(o);
            let y, I = n;
            for (let $ = h.length - 1; $ > 0; $ -= 1)
                y = {
                    type: "array",
                    $id: c,
                    items: [],
                    maxItems: h[$],
                    minItems: h[$]
                },
                h[$] < 0 && (delete y.maxItems,
                delete y.minItems),
                Array.isArray(I.items) ? I.items.length === 0 ? I.items = [y] : I.items.push(y) : I.items = [I.items, y],
                I = y;
            if (f === "tuple" && !d) {
                const $ = id(l, c);
                $.$id = c,
                I.items.push($)
            } else if (f === "tuple" && d) {
                const $ = h[0]
                  , O = Object.assign({
                    type: "array",
                    $id: c,
                    items: id(l, c)
                }, $ >= 0 && {
                    minItems: $,
                    maxItems: $
                });
                I.items.push(O)
            } else if (d) {
                const $ = h[0]
                  , O = Object.assign({
                    type: "array",
                    $id: c,
                    items: $p(o)
                }, $ >= 0 && {
                    minItems: $,
                    maxItems: $
                });
                I.items.push(O)
            } else
                Array.isArray(I.items) ? I.items.push(Object.assign({
                    $id: c
                }, $p(o))) : I.items.push(Object.assign({
                    $id: c
                }, $p(o)));
            I = n
        }
        return n
    }
      , AE = e => id(e)
      , v0 = (e, t) => t === 1 ? e : v0(e[0], t - 1)
      , Tf = (e, t, n) => {
        const r = [];
        for (const [s,o] of e.entries()) {
            let c, l, f = [];
            TE(o) ? (c = o.type,
            l = o.name,
            f = o.components) : typeof o == "string" ? c = o : Array.isArray(o) && (o[1] && Array.isArray(o[1]) ? (c = o[0],
            f = o[1]) : (c = "tuple",
            f = o));
            const {baseType: d, isArray: h, arraySizes: y} = ha(c)
              , I = Array.isArray(t) ? t[s] : t[l];
            if (d === "tuple" && !h)
                r.push(Tf(f, I, n));
            else if (d === "tuple" && h) {
                const $ = [];
                for (const O of I)
                    if (y.length > 1) {
                        const A = v0(O, y.length - 1)
                          , N = [];
                        for (const m of A)
                            N.push(Tf(f, m, n));
                        $.push(N)
                    } else
                        $.push(Tf(f, O, n));
                r.push($)
            } else
                r.push(I)
        }
        return n = n ?? [],
        n.push(...r),
        n
    }
      , Hj = e => {
        if (e >= 48 && e <= 57)
            return e - 48;
        if (e >= 65 && e <= 70)
            return e - 55;
        if (e >= 97 && e <= 102)
            return e - 87;
        throw new Error(`Invalid code point: ${e}`)
    }
      , Ud = e => {
        if (!Ln(e))
            throw new Error("Invalid hex string");
        const [t,n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e]
          , r = BigInt(n);
        return r > Number.MAX_SAFE_INTEGER ? t ? -r : r : r < Number.MIN_SAFE_INTEGER ? r : t ? -1 * Number(r) : Number(r)
    }
      , w0 = e => {
        if ((typeof e == "number" || typeof e == "bigint") && e < 0)
            return `-0x${e.toString(16).slice(1)}`;
        if ((typeof e == "number" || typeof e == "bigint") && e >= 0)
            return `0x${e.toString(16)}`;
        if (typeof e == "string" && Ln(e)) {
            const [t,n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e]
              , r = n.split(/^(-)?0(x|X)/).slice(-1)[0];
            return `${t ? "-" : ""}0x${r.replace(/^0+/, "").toLowerCase()}`
        }
        if (typeof e == "string" && !Ln(e))
            return w0(BigInt(e));
        throw new wF(e)
    }
      , Am = (e, t, n="0") => {
        if (typeof e == "string" && !Ln(e))
            return e.padStart(t, n);
        const r = typeof e == "string" && Ln(e) ? e : w0(e)
          , [s,o] = r.startsWith("-") ? ["-0x", r.slice(3)] : ["0x", r.slice(2)];
        return `${s}${o.padStart(t, n)}`
    }
    ;
    function Bd(e) {
        let t = "0x";
        for (const n of e) {
            const r = n.toString(16);
            t += r.length === 1 ? `0${r}` : r
        }
        return t
    }
    const Oi = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102
    };
    function jv(e) {
        if (e >= Oi.zero && e <= Oi.nine)
            return e - Oi.zero;
        if (e >= Oi.A && e <= Oi.F)
            return e - (Oi.A - 10);
        if (e >= Oi.a && e <= Oi.f)
            return e - (Oi.a - 10)
    }
    function b0(e) {
        let t = 0;
        if (e.startsWith("0") && (e[1] === "x" || e[1] === "X") && (t = 2),
        e.length % 2 !== 0)
            throw new wm(`hex string has odd length: ${e}`);
        const n = (e.length - t) / 2
          , r = new Uint8Array(n);
        for (let s = 0, o = t; s < n; s += 1) {
            const c = jv(e.charCodeAt(o++))
              , l = jv(e.charCodeAt(o++));
            if (c === void 0 || l === void 0)
                throw new wm(`Invalid byte sequence ("${e[o - 2]}${e[o - 1]}" in "${e}").`);
            r[s] = c * 16 + l
        }
        return r
    }
    function E0(e) {
        var t;
        return !(e instanceof Uint8Array) && ((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" ? Uint8Array.from(e) : e
    }
    const Yj = Object.freeze(Object.defineProperty({
        __proto__: null,
        abiSchemaToJsonSchema: id,
        codePointToInt: Hj,
        ensureIfUint8Array: E0,
        ethAbiToJsonSchema: AE,
        fetchArrayElement: v0,
        hexToNumber: Ud,
        hexToUint8Array: b0,
        numberToHex: w0,
        padLeft: Am,
        parseBaseType: ha,
        transformJsonDataToAbiFormat: Tf,
        uint8ArrayToHexString: Bd
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Om = e => {
        var t, n;
        return e instanceof Uint8Array || ((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" || ((n = e?.constructor) === null || n === void 0 ? void 0 : n.name) === "Buffer"
    }
      , OE = (e, t={
        abiType: "bytes"
    }) => {
        if (typeof e != "string" && !Array.isArray(e) && !Om(e) || typeof e == "string" && Ln(e) && e.startsWith("-") || typeof e == "string" && !Ln(e))
            return !1;
        let n;
        if (typeof e == "string") {
            if (e.length % 2 !== 0)
                return !1;
            n = b0(e)
        } else if (Array.isArray(e)) {
            if (e.some(r => r < 0 || r > 255 || !Number.isInteger(r)))
                return !1;
            n = new Uint8Array(e)
        } else
            n = e;
        if (t?.abiType) {
            const {baseTypeSize: r} = ha(t.abiType);
            return r ? n.length === r : !0
        }
        return t?.size ? n.length === t?.size : !0
    }
      , Vj = e => {
        if (!/^(0x)?[0-9a-f]{40}$/i.test(e))
            return !1;
        const t = e.slice(2)
          , n = h0(t.toLowerCase())
          , r = Bd(fE(E0(n))).slice(2);
        for (let s = 0; s < 40; s += 1)
            if (parseInt(r[s], 16) > 7 && t[s].toUpperCase() !== t[s] || parseInt(r[s], 16) <= 7 && t[s].toLowerCase() !== t[s])
                return !1;
        return !0
    }
      , $u = (e, t=!0) => {
        if (typeof e != "string" && !Om(e))
            return !1;
        let n;
        return Om(e) ? n = Bd(e) : typeof e == "string" && !Ln(e) ? n = e.toLowerCase().startsWith("0x") ? e : `0x${e}` : n = e,
        /^(0x)?[0-9a-f]{40}$/i.test(n) ? /^(0x|0X)?[0-9a-f]{40}$/.test(n) || /^(0x|0X)?[0-9A-F]{40}$/.test(n) ? !0 : t ? Vj(n) : !0 : !1
    }
    ;
    var Ru;
    (function(e) {
        e.NUMBER = "NUMBER_NUMBER",
        e.HEX = "NUMBER_HEX",
        e.STR = "NUMBER_STR",
        e.BIGINT = "NUMBER_BIGINT"
    }
    )(Ru || (Ru = {}));
    var Pu;
    (function(e) {
        e.HEX = "BYTES_HEX",
        e.UINT8ARRAY = "BYTES_UINT8ARRAY"
    }
    )(Pu || (Pu = {}));
    Ru.BIGINT,
    Pu.HEX;
    Ru.HEX,
    Pu.HEX;
    var Im;
    (function(e) {
        e.EARLIEST = "earliest",
        e.LATEST = "latest",
        e.PENDING = "pending",
        e.SAFE = "safe",
        e.FINALIZED = "finalized",
        e.COMMITTED = "committed"
    }
    )(Im || (Im = {}));
    var qv;
    (function(e) {
        e.chainstart = "chainstart",
        e.frontier = "frontier",
        e.homestead = "homestead",
        e.dao = "dao",
        e.tangerineWhistle = "tangerineWhistle",
        e.spuriousDragon = "spuriousDragon",
        e.byzantium = "byzantium",
        e.constantinople = "constantinople",
        e.petersburg = "petersburg",
        e.istanbul = "istanbul",
        e.muirGlacier = "muirGlacier",
        e.berlin = "berlin",
        e.london = "london",
        e.altair = "altair",
        e.arrowGlacier = "arrowGlacier",
        e.grayGlacier = "grayGlacier",
        e.bellatrix = "bellatrix",
        e.merge = "merge",
        e.capella = "capella",
        e.shanghai = "shanghai"
    }
    )(qv || (qv = {}));
    var Hv = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    };
    const Yv = Symbol.for("web3/base-provider");
    class Fd {
        static isWeb3Provider(t) {
            return t instanceof Fd || !!(t && t[Yv])
        }
        get[Yv]() {
            return !0
        }
        send(t, n) {
            this.request(t).then(r => {
                n(null, r)
            }
            ).catch(r => {
                n(r)
            }
            )
        }
        sendAsync(t) {
            return Hv(this, void 0, void 0, function*() {
                return this.request(t)
            })
        }
        asEIP1193Provider() {
            const t = Object.create(this)
              , n = t.request;
            return t.request = function(s) {
                return Hv(this, void 0, void 0, function*() {
                    return (yield n(s)).result
                })
            }
            ,
            t.asEIP1193Provider = void 0,
            t
        }
    }
    const Nm = (e, t) => {
        if (t === BigInt(0))
            return BigInt(1);
        let n = e;
        for (let r = 1; r < t; r += 1)
            n *= e;
        return n
    }
      , S0 = (e, t={
        abiType: "uint"
    }) => {
        if (!["number", "string", "bigint"].includes(typeof e) || typeof e == "string" && e.length === 0)
            return !1;
        let n;
        if (t?.abiType) {
            const {baseTypeSize: s} = ha(t.abiType);
            s && (n = s)
        } else
            t.bitSize && (n = t.bitSize);
        const r = Nm(BigInt(2), BigInt(n ?? 256)) - BigInt(1);
        try {
            const s = typeof e == "string" && Ln(e) ? BigInt(Ud(e)) : BigInt(e);
            return s >= 0 && s <= r
        } catch {
            return !1
        }
    }
      , T0 = (e, t={
        abiType: "int"
    }) => {
        if (!["number", "string", "bigint"].includes(typeof e) || typeof e == "number" && e > Number.MAX_SAFE_INTEGER)
            return !1;
        let n;
        if (t?.abiType) {
            const {baseTypeSize: o, baseType: c} = ha(t.abiType);
            if (c !== "int")
                return !1;
            o && (n = o)
        } else
            t.bitSize && (n = t.bitSize);
        const r = Nm(BigInt(2), BigInt((n ?? 256) - 1))
          , s = BigInt(-1) * Nm(BigInt(2), BigInt((n ?? 256) - 1));
        try {
            const o = typeof e == "string" && Ln(e) ? BigInt(Ud(e)) : BigInt(e);
            return o >= s && o <= r
        } catch {
            return !1
        }
    }
      , Wj = e => !!(T0(e) || typeof e == "string" && /[0-9.]/.test(e) && e.indexOf(".") === e.lastIndexOf(".") || typeof e == "number")
      , IE = e => S0(e)
      , NE = e => Object.values(Im).includes(e)
      , xm = e => NE(e) || IE(e)
      , zj = e => typeof e != "string" || !/^(0x)?[0-9a-f]{512}$/i.test(e) ? !1 : !!(/^(0x)?[0-9a-f]{512}$/.test(e) || /^(0x)?[0-9A-F]{512}$/.test(e))
      , Gj = e => ["number", "string", "boolean"].includes(typeof e) ? typeof e == "boolean" ? !0 : typeof e == "string" && !Ln(e) ? e === "1" || e === "0" : typeof e == "string" && Ln(e) ? e === "0x1" || e === "0x0" : e === 1 || e === 0 : !1
      , dr = e => e == null
      , Vv = e => typeof e != "string" || !/^(0x)?[0-9a-f]{64}$/i.test(e) ? !1 : !!(/^(0x)?[0-9a-f]{64}$/.test(e) || /^(0x)?[0-9A-F]{64}$/.test(e))
      , Zj = e => {
        const t = ["fromBlock", "toBlock", "address", "topics", "blockHash"];
        if (dr(e) || typeof e != "object" || !Object.keys(e).every(n => t.includes(n)) || !dr(e.fromBlock) && !xm(e.fromBlock) || !dr(e.toBlock) && !xm(e.toBlock))
            return !1;
        if (!dr(e.address)) {
            if (Array.isArray(e.address)) {
                if (!e.address.every(n => $u(n)))
                    return !1
            } else if (!$u(e.address))
                return !1
        }
        return !(!dr(e.topics) && !e.topics.every(n => dr(n) ? !0 : Array.isArray(n) ? n.every(r => Vv(r)) : !!Vv(n)))
    }
      , la = {
        address: e => $u(e),
        bloom: e => zj(e),
        blockNumber: e => IE(e),
        blockTag: e => NE(e),
        blockNumberOrTag: e => xm(e),
        bool: e => Gj(e),
        bytes: e => OE(e),
        filter: e => Zj(e),
        hex: e => Ln(e),
        uint: e => S0(e),
        int: e => T0(e),
        number: e => Wj(e),
        string: e => jj(e)
    };
    for (let e = 8; e <= 256; e += 8)
        la[`int${e}`] = t => T0(t, {
            bitSize: e
        }),
        la[`uint${e}`] = t => S0(t, {
            bitSize: e
        });
    for (let e = 1; e <= 32; e += 1)
        la[`bytes${e}`] = t => OE(t, {
            size: e
        });
    la.bytes256 = la.bytes;
    const Zc = e => {
        if ((!e?.type || e?.type === "object") && e?.properties) {
            const t = {};
            for (const n of Object.keys(e.properties)) {
                const r = Zc(e.properties[n]);
                r && (t[n] = r)
            }
            return Array.isArray(e.required) ? Gr.object(t).partial().required(e.required.reduce( (n, r) => Object.assign(Object.assign({}, n), {
                [r]: !0
            }), {})) : Gr.object(t).partial()
        }
        if (e?.type === "array" && e?.items) {
            if (Array.isArray(e.items) && e.items.length > 1 && e.maxItems !== void 0 && new Set(e.items.map(r => r.$id)).size === e.items.length) {
                const r = [];
                for (const s of e.items) {
                    const o = Zc(s);
                    o && r.push(o)
                }
                return Gr.tuple(r)
            }
            const t = Array.isArray(e.items) ? e.items[0] : e.items;
            let n = Gr.array(Zc(t));
            return n = e.minItems !== void 0 ? n.min(e.minItems) : n,
            n = e.maxItems !== void 0 ? n.max(e.maxItems) : n,
            n
        }
        if (e.oneOf && Array.isArray(e.oneOf))
            return Gr.union(e.oneOf.map(t => Zc(t)));
        if (e?.format) {
            if (!la[e.format])
                throw new LF(e.format);
            return Gr.any().refine(la[e.format], t => ({
                params: {
                    value: t,
                    format: e.format
                }
            }))
        }
        return e?.type && e?.type !== "object" && typeof Gr[String(e.type)] == "function" ? Gr[String(e.type)]() : Gr.object({
            data: Gr.any()
        }).partial()
    }
    ;
    class oo {
        static factory() {
            return oo.validatorInstance || (oo.validatorInstance = new oo),
            oo.validatorInstance
        }
        validate(t, n, r) {
            var s, o;
            const l = Zc(t).safeParse(n);
            if (!l.success) {
                const f = this.convertErrors((o = (s = l.error) === null || s === void 0 ? void 0 : s.issues) !== null && o !== void 0 ? o : []);
                if (f) {
                    if (r?.silent)
                        return f;
                    throw new rd(f)
                }
            }
        }
        convertErrors(t) {
            if (t && Array.isArray(t) && t.length > 0)
                return t.map(n => {
                    var r;
                    let s, o, c, l;
                    l = n.path.join("/");
                    const f = String(n.path[n.path.length - 1])
                      , d = n.path.join("/");
                    if (n.code === me.too_big)
                        o = "maxItems",
                        l = `${d}/maxItems`,
                        c = {
                            limit: n.maximum
                        },
                        s = `must NOT have more than ${n.maximum} items`;
                    else if (n.code === me.too_small)
                        o = "minItems",
                        l = `${d}/minItems`,
                        c = {
                            limit: n.minimum
                        },
                        s = `must NOT have fewer than ${n.minimum} items`;
                    else if (n.code === me.custom) {
                        const {value: h, format: y} = (r = n.params) !== null && r !== void 0 ? r : {};
                        typeof h > "u" ? s = `value at "/${l}" is required` : s = `value "${typeof h == "object" ? JSON.stringify(h) : h}" at "/${l}" must pass "${y}" validation`,
                        c = {
                            value: h
                        }
                    }
                    return {
                        keyword: o ?? f,
                        instancePath: d ? `/${d}` : "",
                        schemaPath: l ? `#${l}` : "#",
                        params: c ?? {
                            value: n.message
                        },
                        message: s ?? n.message
                    }
                }
                )
        }
    }
    class Kj {
        constructor() {
            this._validator = oo.factory()
        }
        validateJSONSchema(t, n, r) {
            return this._validator.validate(t, n, r)
        }
        validate(t, n, r={
            silent: !1
        }) {
            var s, o;
            const c = AE(t);
            if (!(Array.isArray(c.items) && ((s = c.items) === null || s === void 0 ? void 0 : s.length) === 0 && n.length === 0)) {
                if (Array.isArray(c.items) && ((o = c.items) === null || o === void 0 ? void 0 : o.length) === 0 && n.length !== 0)
                    throw new rd([{
                        instancePath: "/0",
                        schemaPath: "/",
                        keyword: "required",
                        message: "empty schema against data can not be validated",
                        params: n
                    }]);
                return this._validator.validate(c, n, r)
            }
        }
    }
    const A0 = new Kj;
    function Jj(e) {
        var t, n;
        return e instanceof Uint8Array || ((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) === "Uint8Array" || ((n = e?.constructor) === null || n === void 0 ? void 0 : n.name) === "Buffer"
    }
    BigInt(0),
    BigInt(1),
    BigInt(1e3),
    BigInt(1e3),
    BigInt(1e3),
    BigInt(1e3),
    BigInt(1e6),
    BigInt(1e6),
    BigInt(1e6),
    BigInt(1e6),
    BigInt(1e9),
    BigInt(1e9),
    BigInt(1e9),
    BigInt(1e9),
    BigInt(1e9),
    BigInt(1e12),
    BigInt(1e12),
    BigInt(1e12),
    BigInt(1e15),
    BigInt(1e15),
    BigInt(1e15),
    BigInt("1000000000000000000"),
    BigInt("1000000000000000000000"),
    BigInt("1000000000000000000000"),
    BigInt("1000000000000000000000000"),
    BigInt("1000000000000000000000000000"),
    BigInt("1000000000000000000000000000000");
    const $m = e => {
        if (A0.validate(["bytes"], [e]),
        Jj(e))
            return e;
        if (Array.isArray(e))
            return new Uint8Array(e);
        if (typeof e == "string")
            return b0(e);
        throw new wm(e)
    }
      , {uint8ArrayToHexString: Xj} = Yj
      , Qj = e => Xj($m(e))
      , xE = e => typeof e == "string" && e.slice(0, 2).toLowerCase() !== "0x" ? $m(`0x${e}`) : $m(e)
      , e3 = e => (A0.validate(["hex"], [e]),
    Ud(e))
      , t3 = h0
      , n3 = e => {
        if (!$u(e, !1))
            throw new dE(e);
        const t = e.toLowerCase().replace(/^0x/i, "")
          , n = Bd(fE(E0(t3(t))));
        if (dr(n) || n === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
            return "";
        let r = "0x";
        const s = n.replace(/^0x/i, "");
        for (let o = 0; o < t.length; o += 1)
            parseInt(s[o], 16) > 7 ? r += t[o].toUpperCase() : r += t[o];
        return r
    }
    ;
    var $E = {
        exports: {}
    };
    (function(e) {
        var t = Object.prototype.hasOwnProperty
          , n = "~";
        function r() {}
        Object.create && (r.prototype = Object.create(null),
        new r().__proto__ || (n = !1));
        function s(f, d, h) {
            this.fn = f,
            this.context = d,
            this.once = h || !1
        }
        function o(f, d, h, y, I) {
            if (typeof h != "function")
                throw new TypeError("The listener must be a function");
            var $ = new s(h,y || f,I)
              , O = n ? n + d : d;
            return f._events[O] ? f._events[O].fn ? f._events[O] = [f._events[O], $] : f._events[O].push($) : (f._events[O] = $,
            f._eventsCount++),
            f
        }
        function c(f, d) {
            --f._eventsCount === 0 ? f._events = new r : delete f._events[d]
        }
        function l() {
            this._events = new r,
            this._eventsCount = 0
        }
        l.prototype.eventNames = function() {
            var d = [], h, y;
            if (this._eventsCount === 0)
                return d;
            for (y in h = this._events)
                t.call(h, y) && d.push(n ? y.slice(1) : y);
            return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(h)) : d
        }
        ,
        l.prototype.listeners = function(d) {
            var h = n ? n + d : d
              , y = this._events[h];
            if (!y)
                return [];
            if (y.fn)
                return [y.fn];
            for (var I = 0, $ = y.length, O = new Array($); I < $; I++)
                O[I] = y[I].fn;
            return O
        }
        ,
        l.prototype.listenerCount = function(d) {
            var h = n ? n + d : d
              , y = this._events[h];
            return y ? y.fn ? 1 : y.length : 0
        }
        ,
        l.prototype.emit = function(d, h, y, I, $, O) {
            var A = n ? n + d : d;
            if (!this._events[A])
                return !1;
            var N = this._events[A], m = arguments.length, g, M;
            if (N.fn) {
                switch (N.once && this.removeListener(d, N.fn, void 0, !0),
                m) {
                case 1:
                    return N.fn.call(N.context),
                    !0;
                case 2:
                    return N.fn.call(N.context, h),
                    !0;
                case 3:
                    return N.fn.call(N.context, h, y),
                    !0;
                case 4:
                    return N.fn.call(N.context, h, y, I),
                    !0;
                case 5:
                    return N.fn.call(N.context, h, y, I, $),
                    !0;
                case 6:
                    return N.fn.call(N.context, h, y, I, $, O),
                    !0
                }
                for (M = 1,
                g = new Array(m - 1); M < m; M++)
                    g[M - 1] = arguments[M];
                N.fn.apply(N.context, g)
            } else {
                var G = N.length, U;
                for (M = 0; M < G; M++)
                    switch (N[M].once && this.removeListener(d, N[M].fn, void 0, !0),
                    m) {
                    case 1:
                        N[M].fn.call(N[M].context);
                        break;
                    case 2:
                        N[M].fn.call(N[M].context, h);
                        break;
                    case 3:
                        N[M].fn.call(N[M].context, h, y);
                        break;
                    case 4:
                        N[M].fn.call(N[M].context, h, y, I);
                        break;
                    default:
                        if (!g)
                            for (U = 1,
                            g = new Array(m - 1); U < m; U++)
                                g[U - 1] = arguments[U];
                        N[M].fn.apply(N[M].context, g)
                    }
            }
            return !0
        }
        ,
        l.prototype.on = function(d, h, y) {
            return o(this, d, h, y, !1)
        }
        ,
        l.prototype.once = function(d, h, y) {
            return o(this, d, h, y, !0)
        }
        ,
        l.prototype.removeListener = function(d, h, y, I) {
            var $ = n ? n + d : d;
            if (!this._events[$])
                return this;
            if (!h)
                return c(this, $),
                this;
            var O = this._events[$];
            if (O.fn)
                O.fn === h && (!I || O.once) && (!y || O.context === y) && c(this, $);
            else {
                for (var A = 0, N = [], m = O.length; A < m; A++)
                    (O[A].fn !== h || I && !O[A].once || y && O[A].context !== y) && N.push(O[A]);
                N.length ? this._events[$] = N.length === 1 ? N[0] : N : c(this, $)
            }
            return this
        }
        ,
        l.prototype.removeAllListeners = function(d) {
            var h;
            return d ? (h = n ? n + d : d,
            this._events[h] && c(this, h)) : (this._events = new r,
            this._eventsCount = 0),
            this
        }
        ,
        l.prototype.off = l.prototype.removeListener,
        l.prototype.addListener = l.prototype.on,
        l.prefixed = n,
        l.EventEmitter = l,
        e.exports = l
    }
    )($E);
    var r3 = $E.exports;
    const i3 = jm(r3)
      , Rm = dr
      , s3 = (e, t, n="0") => typeof e == "string" ? Ln(e) ? Am(e, t, n) : e.padStart(t, n) : (A0.validate(["int"], [e]),
    Am(e, t, n))
      , Wv = s3;
    function a3(e) {
        return oE(e)
    }
    const o3 = e => a3(e)
      , c3 = () => {
        const e = o3(16);
        e[6] = e[6] & 15 | 64,
        e[8] = e[8] & 63 | 128;
        const t = Qj(e);
        return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join("-")
    }
      , RE = e => !Array.isArray(e) && !!e && e.jsonrpc === "2.0" && "result"in e && dr(e.error) && (typeof e.id == "number" || typeof e.id == "string")
      , PE = e => !Array.isArray(e) && e.jsonrpc === "2.0" && !!e && dr(e.result) && "error"in e && (typeof e.id == "number" || typeof e.id == "string")
      , u3 = e => !Array.isArray(e) && !!e && e.jsonrpc === "2.0" && !dr(e.params) && !dr(e.method)
      , zv = e => RE(e) || PE(e)
      , l3 = e => Array.isArray(e) ? e.every(zv) : zv(e)
      , Gv = e => Array.isArray(e) && e.length > 0 && l3(e);
    let f3;
    const Zv = e => {
        var t, n, r, s;
        return {
            jsonrpc: (t = e.jsonrpc) !== null && t !== void 0 ? t : "2.0",
            id: (r = (n = e.id) !== null && n !== void 0 ? n : f3) !== null && r !== void 0 ? r : c3(),
            method: e.method,
            params: (s = e.params) !== null && s !== void 0 ? s : void 0
        }
    }
      , d3 = e => Array.isArray(e) && e.length > 0;
    var Rp = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    }, kE;
    class h3 {
        constructor({timeout: t, eagerStart: n, timeoutMessage: r}={
            timeout: 0,
            eagerStart: !1,
            timeoutMessage: "DeferredPromise timed out"
        }) {
            this[kE] = "Promise",
            this._state = "pending",
            this._promise = new Promise( (s, o) => {
                this._resolve = s,
                this._reject = o
            }
            ),
            this._timeoutMessage = r,
            this._timeoutInterval = t,
            n && this.startTimer()
        }
        get state() {
            return this._state
        }
        then(t, n) {
            return Rp(this, void 0, void 0, function*() {
                return this._promise.then(t, n)
            })
        }
        catch(t) {
            return Rp(this, void 0, void 0, function*() {
                return this._promise.catch(t)
            })
        }
        finally(t) {
            return Rp(this, void 0, void 0, function*() {
                return this._promise.finally(t)
            })
        }
        resolve(t) {
            this._resolve(t),
            this._state = "fulfilled",
            this._clearTimeout()
        }
        reject(t) {
            this._reject(t),
            this._state = "rejected",
            this._clearTimeout()
        }
        startTimer() {
            this._timeoutInterval && this._timeoutInterval > 0 && (this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval))
        }
        _checkTimeout() {
            this._state === "pending" && this._timeoutId && this.reject(new _F(this._timeoutMessage))
        }
        _clearTimeout() {
            this._timeoutId && clearTimeout(this._timeoutId)
        }
    }
    kE = Symbol.toStringTag;
    class p3 {
        constructor(t, n) {
            this.eventEmitter = t,
            this.autoReconnect = n,
            this.chunkTimeout = 1e3 * 15
        }
        clearQueues() {
            typeof this._clearQueues == "function" && this._clearQueues()
        }
        onError(t) {
            this._clearQueues = t
        }
        parseResponse(t) {
            const n = [];
            return t.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach(s => {
                let o = s;
                this.lastChunk && (o = this.lastChunk + o);
                let c;
                try {
                    c = JSON.parse(o)
                } catch {
                    this.lastChunk = o,
                    this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout),
                    this.lastChunkTimeout = setTimeout( () => {
                        this.autoReconnect || (this.clearQueues(),
                        this.eventEmitter.emit("error", new EF({
                            id: 1,
                            jsonrpc: "2.0",
                            error: {
                                code: 2,
                                message: "Chunk timeout"
                            }
                        })))
                    }
                    , this.chunkTimeout);
                    return
                }
                clearTimeout(this.lastChunkTimeout),
                this.lastChunk = void 0,
                c && n.push(c)
            }
            ),
            n
        }
    }
    var Kv = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    };
    class CE extends Fd {
        constructor() {
            super(...arguments),
            this._eventEmitter = new i3,
            this._chainId = "",
            this._accounts = []
        }
        _getChainId() {
            return Kv(this, void 0, void 0, function*() {
                var t;
                const n = yield this.request(Zv({
                    method: "eth_chainId",
                    params: []
                }));
                return (t = n?.result) !== null && t !== void 0 ? t : ""
            })
        }
        _getAccounts() {
            return Kv(this, void 0, void 0, function*() {
                var t;
                const n = yield this.request(Zv({
                    method: "eth_accounts",
                    params: []
                }));
                return (t = n?.result) !== null && t !== void 0 ? t : []
            })
        }
        _onConnect() {
            Promise.all([this._getChainId().then(t => {
                t !== this._chainId && (this._chainId = t,
                this._eventEmitter.emit("chainChanged", this._chainId))
            }
            ).catch(t => {
                console.error(t)
            }
            ), this._getAccounts().then(t => {
                this._accounts.length === t.length && t.every(n => t.includes(n)) || (this._accounts = t,
                this._onAccountsChanged())
            }
            ).catch(t => {
                console.error(t)
            }
            )]).then( () => this._eventEmitter.emit("connect", {
                chainId: this._chainId
            })).catch(t => {
                console.error(t)
            }
            )
        }
        _onDisconnect(t, n) {
            this._eventEmitter.emit("disconnect", new SF(t,n))
        }
        _onAccountsChanged() {
            this._eventEmitter.emit("accountsChanged", this._accounts)
        }
    }
    var Pp = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    };
    const m3 = {
        autoReconnect: !0,
        delay: 5e3,
        maxAttempts: 5
    }
      , g3 = 1e3;
    class y3 extends CE {
        get SocketConnection() {
            return this._socketConnection
        }
        constructor(t, n, r) {
            if (super(),
            this._connectionStatus = "connecting",
            this._onMessageHandler = this._onMessage.bind(this),
            this._onOpenHandler = this._onConnect.bind(this),
            this._onCloseHandler = this._onCloseEvent.bind(this),
            this._onErrorHandler = this._onError.bind(this),
            !this._validateProviderPath(t))
                throw new vm(t);
            this._socketPath = t,
            this._socketOptions = n,
            this._reconnectOptions = Object.assign(Object.assign({}, m3), r ?? {}),
            this._pendingRequestsQueue = new Map,
            this._sentRequestsQueue = new Map,
            this._init(),
            this.connect(),
            this.chunkResponseParser = new p3(this._eventEmitter,this._reconnectOptions.autoReconnect),
            this.chunkResponseParser.onError( () => {
                this._clearQueues()
            }
            ),
            this.isReconnecting = !1
        }
        _init() {
            this._reconnectAttempts = 0
        }
        connect() {
            try {
                this._openSocketConnection(),
                this._connectionStatus = "connecting",
                this._addSocketListeners()
            } catch (t) {
                if (this.isReconnecting)
                    setImmediate( () => {
                        this._reconnect()
                    }
                    );
                else
                    throw this._connectionStatus = "disconnected",
                    t && t.message ? new qu(`Error while connecting to ${this._socketPath}. Reason: ${t.message}`) : new vm(this._socketPath)
            }
        }
        _validateProviderPath(t) {
            return !!t
        }
        getPendingRequestQueueSize() {
            return this._pendingRequestsQueue.size
        }
        getSentRequestsQueueSize() {
            return this._sentRequestsQueue.size
        }
        supportsSubscriptions() {
            return !0
        }
        on(t, n) {
            this._eventEmitter.on(t, n)
        }
        once(t, n) {
            this._eventEmitter.once(t, n)
        }
        removeListener(t, n) {
            this._eventEmitter.removeListener(t, n)
        }
        _onDisconnect(t, n) {
            this._connectionStatus = "disconnected",
            super._onDisconnect(t, n)
        }
        disconnect(t, n) {
            const r = t ?? g3;
            this._removeSocketListeners(),
            this.getStatus() !== "disconnected" && this._closeSocketConnection(r, n),
            this._onDisconnect(r, n)
        }
        safeDisconnect(t, n) {
            return Pp(this, arguments, void 0, function*(r, s, o=!1, c=1e3) {
                let l = 0;
                yield Pp(this, void 0, void 0, function*() {
                    return new Promise(d => {
                        const h = setInterval( () => {
                            o && l >= 5 && this.clearQueues(),
                            this.getPendingRequestQueueSize() === 0 && this.getSentRequestsQueueSize() === 0 && (clearInterval(h),
                            d(!0)),
                            l += 1
                        }
                        , c)
                    }
                    )
                }),
                this.disconnect(r, s)
            })
        }
        removeAllListeners(t) {
            this._eventEmitter.removeAllListeners(t)
        }
        _onError(t) {
            this.isReconnecting ? this._reconnect() : this._eventEmitter.emit("error", t)
        }
        reset() {
            this._sentRequestsQueue.clear(),
            this._pendingRequestsQueue.clear(),
            this._init(),
            this._removeSocketListeners(),
            this._addSocketListeners()
        }
        _reconnect() {
            this.isReconnecting || (this.isReconnecting = !0,
            this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach( (t, n) => {
                t.deferredPromise.reject(new gF),
                this._sentRequestsQueue.delete(n)
            }
            ),
            this._reconnectAttempts < this._reconnectOptions.maxAttempts ? (this._reconnectAttempts += 1,
            setTimeout( () => {
                this._removeSocketListeners(),
                this.connect(),
                this.isReconnecting = !1
            }
            , this._reconnectOptions.delay)) : (this.isReconnecting = !1,
            this._clearQueues(),
            this._removeSocketListeners(),
            this._eventEmitter.emit("error", new mF(this._reconnectOptions.maxAttempts))))
        }
        request(t) {
            return Pp(this, void 0, void 0, function*() {
                if (Rm(this._socketConnection))
                    throw new Error("Connection is undefined");
                this.getStatus() === "disconnected" && this.connect();
                const n = d3(t) ? t[0].id : t.id;
                if (!n)
                    throw new vF("Request Id not defined");
                if (this._sentRequestsQueue.has(n))
                    throw new yF(n);
                const r = new h3;
                r.catch(o => {
                    this._eventEmitter.emit("error", o)
                }
                );
                const s = {
                    payload: t,
                    deferredPromise: r
                };
                if (this.getStatus() === "connecting")
                    return this._pendingRequestsQueue.set(n, s),
                    s.deferredPromise;
                this._sentRequestsQueue.set(n, s);
                try {
                    this._sendToSocket(s.payload)
                } catch (o) {
                    this._sentRequestsQueue.delete(n),
                    this._eventEmitter.emit("error", o)
                }
                return r
            })
        }
        _onConnect() {
            this._connectionStatus = "connected",
            this._reconnectAttempts = 0,
            super._onConnect(),
            this._sendPendingRequests()
        }
        _sendPendingRequests() {
            for (const [t,n] of this._pendingRequestsQueue.entries())
                try {
                    this._sendToSocket(n.payload),
                    this._pendingRequestsQueue.delete(t),
                    this._sentRequestsQueue.set(t, n)
                } catch (r) {
                    this._pendingRequestsQueue.delete(t),
                    this._eventEmitter.emit("error", r)
                }
        }
        _onMessage(t) {
            const n = this._parseResponses(t);
            if (!(Rm(n) || n.length === 0))
                for (const r of n) {
                    if (u3(r) && r.method.endsWith("_subscription")) {
                        this._eventEmitter.emit("message", r);
                        return
                    }
                    const s = Gv(r) ? r[0].id : r.id
                      , o = this._sentRequestsQueue.get(s);
                    if (!o)
                        return;
                    (Gv(r) || RE(r) || PE(r)) && (this._eventEmitter.emit("message", r),
                    o.deferredPromise.resolve(r)),
                    this._sentRequestsQueue.delete(s)
                }
        }
        clearQueues(t) {
            this._clearQueues(t)
        }
        _clearQueues(t) {
            this._pendingRequestsQueue.size > 0 && this._pendingRequestsQueue.forEach( (n, r) => {
                n.deferredPromise.reject(new _m(t)),
                this._pendingRequestsQueue.delete(r)
            }
            ),
            this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach( (n, r) => {
                n.deferredPromise.reject(new _m(t)),
                this._sentRequestsQueue.delete(r)
            }
            ),
            this._removeSocketListeners()
        }
    }
    const To = new Map;
    let df = BigInt(256);
    for (let e = 8; e <= 256; e += 8)
        To.set(`uint${e}`, {
            min: BigInt(0),
            max: df - BigInt(1)
        }),
        To.set(`int${e}`, {
            min: -df / BigInt(2),
            max: df / BigInt(2) - BigInt(1)
        }),
        df *= BigInt(256);
    To.set("int", To.get("int256"));
    To.set("uint", To.get("uint256"));
    BigInt(1) << BigInt(256);
    var Jv;
    (function(e) {
        e.notFound = "WEB3_NOT_FOUND",
        e.blockNotFound = "BLOCK_NOT_FOUND"
    }
    )(Jv || (Jv = {}));
    const Xv = "access-tokens";
    var Qv;
    (function(e) {
        e[e.v1Create = `v1/${Xv}`] = "v1Create",
        e[e.v1Delete = `v1/${Xv}/:accessTokenId`] = "v1Delete"
    }
    )(Qv || (Qv = {}));
    /*! Axios v1.10.0 Copyright (c) 2025 Matt Zabriskie and contributors */
    var kp, ew;
    function ME() {
        if (ew)
            return kp;
        ew = 1;
        function e(w, E) {
            return function() {
                return w.apply(E, arguments)
            }
        }
        const {toString: t} = Object.prototype
          , {getPrototypeOf: n} = Object
          , {iterator: r, toStringTag: s} = Symbol
          , o = (w => E => {
            const L = t.call(E);
            return w[L] || (w[L] = L.slice(8, -1).toLowerCase())
        }
        )(Object.create(null))
          , c = w => (w = w.toLowerCase(),
        E => o(E) === w)
          , l = w => E => typeof E === w
          , {isArray: f} = Array
          , d = l("undefined");
        function h(w) {
            return w !== null && !d(w) && w.constructor !== null && !d(w.constructor) && O(w.constructor.isBuffer) && w.constructor.isBuffer(w)
        }
        const y = c("ArrayBuffer");
        function I(w) {
            let E;
            return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? E = ArrayBuffer.isView(w) : E = w && w.buffer && y(w.buffer),
            E
        }
        const $ = l("string")
          , O = l("function")
          , A = l("number")
          , N = w => w !== null && typeof w == "object"
          , m = w => w === !0 || w === !1
          , g = w => {
            if (o(w) !== "object")
                return !1;
            const E = n(w);
            return (E === null || E === Object.prototype || Object.getPrototypeOf(E) === null) && !(s in w) && !(r in w)
        }
          , M = c("Date")
          , G = c("File")
          , U = c("Blob")
          , D = c("FileList")
          , K = w => N(w) && O(w.pipe)
          , _ = w => {
            let E;
            return w && (typeof FormData == "function" && w instanceof FormData || O(w.append) && ((E = o(w)) === "formdata" || E === "object" && O(w.toString) && w.toString() === "[object FormData]"))
        }
          , T = c("URLSearchParams")
          , [S,q,C,F] = ["ReadableStream", "Request", "Response", "Headers"].map(c)
          , X = w => w.trim ? w.trim() : w.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        function v(w, E, {allOwnKeys: L=!1}={}) {
            if (w === null || typeof w > "u")
                return;
            let B, z;
            if (typeof w != "object" && (w = [w]),
            f(w))
                for (B = 0,
                z = w.length; B < z; B++)
                    E.call(null, w[B], B, w);
            else {
                const re = L ? Object.getOwnPropertyNames(w) : Object.keys(w)
                  , ie = re.length;
                let de;
                for (B = 0; B < ie; B++)
                    de = re[B],
                    E.call(null, w[de], de, w)
            }
        }
        function x(w, E) {
            E = E.toLowerCase();
            const L = Object.keys(w);
            let B = L.length, z;
            for (; B-- > 0; )
                if (z = L[B],
                E === z.toLowerCase())
                    return z;
            return null
        }
        const Y = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Hn
          , W = w => !d(w) && w !== Y;
        function te() {
            const {caseless: w} = W(this) && this || {}
              , E = {}
              , L = (B, z) => {
                const re = w && x(E, z) || z;
                g(E[re]) && g(B) ? E[re] = te(E[re], B) : g(B) ? E[re] = te({}, B) : f(B) ? E[re] = B.slice() : E[re] = B
            }
            ;
            for (let B = 0, z = arguments.length; B < z; B++)
                arguments[B] && v(arguments[B], L);
            return E
        }
        const J = (w, E, L, {allOwnKeys: B}={}) => (v(E, (z, re) => {
            L && O(z) ? w[re] = e(z, L) : w[re] = z
        }
        , {
            allOwnKeys: B
        }),
        w)
          , H = w => (w.charCodeAt(0) === 65279 && (w = w.slice(1)),
        w)
          , ae = (w, E, L, B) => {
            w.prototype = Object.create(E.prototype, B),
            w.prototype.constructor = w,
            Object.defineProperty(w, "super", {
                value: E.prototype
            }),
            L && Object.assign(w.prototype, L)
        }
          , Q = (w, E, L, B) => {
            let z, re, ie;
            const de = {};
            if (E = E || {},
            w == null)
                return E;
            do {
                for (z = Object.getOwnPropertyNames(w),
                re = z.length; re-- > 0; )
                    ie = z[re],
                    (!B || B(ie, w, E)) && !de[ie] && (E[ie] = w[ie],
                    de[ie] = !0);
                w = L !== !1 && n(w)
            } while (w && (!L || L(w, E)) && w !== Object.prototype);
            return E
        }
          , P = (w, E, L) => {
            w = String(w),
            (L === void 0 || L > w.length) && (L = w.length),
            L -= E.length;
            const B = w.indexOf(E, L);
            return B !== -1 && B === L
        }
          , j = w => {
            if (!w)
                return null;
            if (f(w))
                return w;
            let E = w.length;
            if (!A(E))
                return null;
            const L = new Array(E);
            for (; E-- > 0; )
                L[E] = w[E];
            return L
        }
          , se = (w => E => w && E instanceof w)(typeof Uint8Array < "u" && n(Uint8Array))
          , ye = (w, E) => {
            const B = (w && w[r]).call(w);
            let z;
            for (; (z = B.next()) && !z.done; ) {
                const re = z.value;
                E.call(w, re[0], re[1])
            }
        }
          , we = (w, E) => {
            let L;
            const B = [];
            for (; (L = w.exec(E)) !== null; )
                B.push(L);
            return B
        }
          , De = c("HTMLFormElement")
          , Re = w => w.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(L, B, z) {
            return B.toUpperCase() + z
        })
          , tt = ( ({hasOwnProperty: w}) => (E, L) => w.call(E, L))(Object.prototype)
          , vt = c("RegExp")
          , bt = (w, E) => {
            const L = Object.getOwnPropertyDescriptors(w)
              , B = {};
            v(L, (z, re) => {
                let ie;
                (ie = E(z, re, w)) !== !1 && (B[re] = ie || z)
            }
            ),
            Object.defineProperties(w, B)
        }
          , st = w => {
            bt(w, (E, L) => {
                if (O(w) && ["arguments", "caller", "callee"].indexOf(L) !== -1)
                    return !1;
                const B = w[L];
                if (O(B)) {
                    if (E.enumerable = !1,
                    "writable"in E) {
                        E.writable = !1;
                        return
                    }
                    E.set || (E.set = () => {
                        throw Error("Can not rewrite read-only method '" + L + "'")
                    }
                    )
                }
            }
            )
        }
          , ct = (w, E) => {
            const L = {}
              , B = z => {
                z.forEach(re => {
                    L[re] = !0
                }
                )
            }
            ;
            return f(w) ? B(w) : B(String(w).split(E)),
            L
        }
          , Br = () => {}
          , yn = (w, E) => w != null && Number.isFinite(w = +w) ? w : E;
        function Gi(w) {
            return !!(w && O(w.append) && w[s] === "FormData" && w[r])
        }
        const Ns = w => {
            const E = new Array(10)
              , L = (B, z) => {
                if (N(B)) {
                    if (E.indexOf(B) >= 0)
                        return;
                    if (!("toJSON"in B)) {
                        E[z] = B;
                        const re = f(B) ? [] : {};
                        return v(B, (ie, de) => {
                            const $e = L(ie, z + 1);
                            !d($e) && (re[de] = $e)
                        }
                        ),
                        E[z] = void 0,
                        re
                    }
                }
                return B
            }
            ;
            return L(w, 0)
        }
          , yr = c("AsyncFunction")
          , an = w => w && (N(w) || O(w)) && O(w.then) && O(w.catch)
          , Wn = ( (w, E) => w ? setImmediate : E ? ( (L, B) => (Y.addEventListener("message", ({source: z, data: re}) => {
            z === Y && re === L && B.length && B.shift()()
        }
        , !1),
        z => {
            B.push(z),
            Y.postMessage(L, "*")
        }
        ))(`axios@${Math.random()}`, []) : L => setTimeout(L))(typeof setImmediate == "function", O(Y.postMessage))
          , Fr = typeof queueMicrotask < "u" ? queueMicrotask.bind(Y) : typeof process < "u" && process.nextTick || Wn;
        var oe = {
            isArray: f,
            isArrayBuffer: y,
            isBuffer: h,
            isFormData: _,
            isArrayBufferView: I,
            isString: $,
            isNumber: A,
            isBoolean: m,
            isObject: N,
            isPlainObject: g,
            isReadableStream: S,
            isRequest: q,
            isResponse: C,
            isHeaders: F,
            isUndefined: d,
            isDate: M,
            isFile: G,
            isBlob: U,
            isRegExp: vt,
            isFunction: O,
            isStream: K,
            isURLSearchParams: T,
            isTypedArray: se,
            isFileList: D,
            forEach: v,
            merge: te,
            extend: J,
            trim: X,
            stripBOM: H,
            inherits: ae,
            toFlatObject: Q,
            kindOf: o,
            kindOfTest: c,
            endsWith: P,
            toArray: j,
            forEachEntry: ye,
            matchAll: we,
            isHTMLForm: De,
            hasOwnProperty: tt,
            hasOwnProp: tt,
            reduceDescriptors: bt,
            freezeMethods: st,
            toObjectSet: ct,
            toCamelCase: Re,
            noop: Br,
            toFiniteNumber: yn,
            findKey: x,
            global: Y,
            isContextDefined: W,
            isSpecCompliantForm: Gi,
            toJSONObject: Ns,
            isAsyncFn: yr,
            isThenable: an,
            setImmediate: Wn,
            asap: Fr,
            isIterable: w => w != null && O(w[r])
        };
        function Be(w, E, L, B, z) {
            Error.call(this),
            Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
            this.message = w,
            this.name = "AxiosError",
            E && (this.code = E),
            L && (this.config = L),
            B && (this.request = B),
            z && (this.response = z,
            this.status = z.status ? z.status : null)
        }
        oe.inherits(Be, Error, {
            toJSON: function() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: oe.toJSONObject(this.config),
                    code: this.code,
                    status: this.status
                }
            }
        });
        const zn = Be.prototype
          , Gn = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(w => {
            Gn[w] = {
                value: w
            }
        }
        ),
        Object.defineProperties(Be, Gn),
        Object.defineProperty(zn, "isAxiosError", {
            value: !0
        }),
        Be.from = (w, E, L, B, z, re) => {
            const ie = Object.create(zn);
            return oe.toFlatObject(w, ie, function($e) {
                return $e !== Error.prototype
            }, de => de !== "isAxiosError"),
            Be.call(ie, w.message, E, L, B, z),
            ie.cause = w,
            ie.name = w.name,
            re && Object.assign(ie, re),
            ie
        }
        ;
        var Zi = null;
        function ui(w) {
            return oe.isPlainObject(w) || oe.isArray(w)
        }
        function ma(w) {
            return oe.endsWith(w, "[]") ? w.slice(0, -2) : w
        }
        function ga(w, E, L) {
            return w ? w.concat(E).map(function(z, re) {
                return z = ma(z),
                !L && re ? "[" + z + "]" : z
            }).join(L ? "." : "") : E
        }
        function Mo(w) {
            return oe.isArray(w) && !w.some(ui)
        }
        const Lo = oe.toFlatObject(oe, {}, null, function(E) {
            return /^is[A-Z]/.test(E)
        });
        function Ki(w, E, L) {
            if (!oe.isObject(w))
                throw new TypeError("target must be an object");
            E = E || new FormData,
            L = oe.toFlatObject(L, {
                metaTokens: !0,
                dots: !1,
                indexes: !1
            }, !1, function(We, Ce) {
                return !oe.isUndefined(Ce[We])
            });
            const B = L.metaTokens
              , z = L.visitor || _e
              , re = L.dots
              , ie = L.indexes
              , $e = (L.Blob || typeof Blob < "u" && Blob) && oe.isSpecCompliantForm(E);
            if (!oe.isFunction(z))
                throw new TypeError("visitor must be a function");
            function pe(xe) {
                if (xe === null)
                    return "";
                if (oe.isDate(xe))
                    return xe.toISOString();
                if (oe.isBoolean(xe))
                    return xe.toString();
                if (!$e && oe.isBlob(xe))
                    throw new Be("Blob is not supported. Use a Buffer instead.");
                return oe.isArrayBuffer(xe) || oe.isTypedArray(xe) ? $e && typeof Blob == "function" ? new Blob([xe]) : Buffer.from(xe) : xe
            }
            function _e(xe, We, Ce) {
                let Ye = xe;
                if (xe && !Ce && typeof xe == "object") {
                    if (oe.endsWith(We, "{}"))
                        We = B ? We : We.slice(0, -2),
                        xe = JSON.stringify(xe);
                    else if (oe.isArray(xe) && Mo(xe) || (oe.isFileList(xe) || oe.endsWith(We, "[]")) && (Ye = oe.toArray(xe)))
                        return We = ma(We),
                        Ye.forEach(function(Ut, _r) {
                            !(oe.isUndefined(Ut) || Ut === null) && E.append(ie === !0 ? ga([We], _r, re) : ie === null ? We : We + "[]", pe(Ut))
                        }),
                        !1
                }
                return ui(xe) ? !0 : (E.append(ga(Ce, We, re), pe(xe)),
                !1)
            }
            const Oe = []
              , Et = Object.assign(Lo, {
                defaultVisitor: _e,
                convertValue: pe,
                isVisitable: ui
            });
            function Dt(xe, We) {
                if (!oe.isUndefined(xe)) {
                    if (Oe.indexOf(xe) !== -1)
                        throw Error("Circular reference detected in " + We.join("."));
                    Oe.push(xe),
                    oe.forEach(xe, function(Ye, At) {
                        (!(oe.isUndefined(Ye) || Ye === null) && z.call(E, Ye, oe.isString(At) ? At.trim() : At, We, Et)) === !0 && Dt(Ye, We ? We.concat(At) : [At])
                    }),
                    Oe.pop()
                }
            }
            if (!oe.isObject(w))
                throw new TypeError("data must be an object");
            return Dt(w),
            E
        }
        function ya(w) {
            const E = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+",
                "%00": "\0"
            };
            return encodeURIComponent(w).replace(/[!'()~]|%20|%00/g, function(B) {
                return E[B]
            })
        }
        function xs(w, E) {
            this._pairs = [],
            w && Ki(w, this, E)
        }
        const Wu = xs.prototype;
        Wu.append = function(E, L) {
            this._pairs.push([E, L])
        }
        ,
        Wu.toString = function(E) {
            const L = E ? function(B) {
                return E.call(this, B, ya)
            }
            : ya;
            return this._pairs.map(function(z) {
                return L(z[0]) + "=" + L(z[1])
            }, "").join("&")
        }
        ;
        function qd(w) {
            return encodeURIComponent(w).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }
        function zu(w, E, L) {
            if (!E)
                return w;
            const B = L && L.encode || qd;
            oe.isFunction(L) && (L = {
                serialize: L
            });
            const z = L && L.serialize;
            let re;
            if (z ? re = z(E, L) : re = oe.isURLSearchParams(E) ? E.toString() : new xs(E,L).toString(B),
            re) {
                const ie = w.indexOf("#");
                ie !== -1 && (w = w.slice(0, ie)),
                w += (w.indexOf("?") === -1 ? "?" : "&") + re
            }
            return w
        }
        class Gu {
            constructor() {
                this.handlers = []
            }
            use(E, L, B) {
                return this.handlers.push({
                    fulfilled: E,
                    rejected: L,
                    synchronous: B ? B.synchronous : !1,
                    runWhen: B ? B.runWhen : null
                }),
                this.handlers.length - 1
            }
            eject(E) {
                this.handlers[E] && (this.handlers[E] = null)
            }
            clear() {
                this.handlers && (this.handlers = [])
            }
            forEach(E) {
                oe.forEach(this.handlers, function(B) {
                    B !== null && E(B)
                })
            }
        }
        var Do = Gu
          , Zu = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        }
          , Hd = typeof URLSearchParams < "u" ? URLSearchParams : xs
          , Yd = typeof FormData < "u" ? FormData : null
          , Vd = typeof Blob < "u" ? Blob : null
          , Ku = {
            isBrowser: !0,
            classes: {
                URLSearchParams: Hd,
                FormData: Yd,
                Blob: Vd
            },
            protocols: ["http", "https", "file", "blob", "url", "data"]
        };
        const Uo = typeof window < "u" && typeof document < "u"
          , Bo = typeof navigator == "object" && navigator || void 0
          , Wd = Uo && (!Bo || ["ReactNative", "NativeScript", "NS"].indexOf(Bo.product) < 0)
          , Fo = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
          , zd = Uo && window.location.href || "http://localhost";
        var jo = Object.freeze({
            __proto__: null,
            hasBrowserEnv: Uo,
            hasStandardBrowserWebWorkerEnv: Fo,
            hasStandardBrowserEnv: Wd,
            navigator: Bo,
            origin: zd
        })
          , Xt = {
            ...jo,
            ...Ku
        };
        function Gd(w, E) {
            return Ki(w, new Xt.classes.URLSearchParams, Object.assign({
                visitor: function(L, B, z, re) {
                    return Xt.isNode && oe.isBuffer(L) ? (this.append(B, L.toString("base64")),
                    !1) : re.defaultVisitor.apply(this, arguments)
                }
            }, E))
        }
        function Zd(w) {
            return oe.matchAll(/\w+|\[(\w*)]/g, w).map(E => E[0] === "[]" ? "" : E[1] || E[0])
        }
        function Kd(w) {
            const E = {}
              , L = Object.keys(w);
            let B;
            const z = L.length;
            let re;
            for (B = 0; B < z; B++)
                re = L[B],
                E[re] = w[re];
            return E
        }
        function Ju(w) {
            function E(L, B, z, re) {
                let ie = L[re++];
                if (ie === "__proto__")
                    return !0;
                const de = Number.isFinite(+ie)
                  , $e = re >= L.length;
                return ie = !ie && oe.isArray(z) ? z.length : ie,
                $e ? (oe.hasOwnProp(z, ie) ? z[ie] = [z[ie], B] : z[ie] = B,
                !de) : ((!z[ie] || !oe.isObject(z[ie])) && (z[ie] = []),
                E(L, B, z[ie], re) && oe.isArray(z[ie]) && (z[ie] = Kd(z[ie])),
                !de)
            }
            if (oe.isFormData(w) && oe.isFunction(w.entries)) {
                const L = {};
                return oe.forEachEntry(w, (B, z) => {
                    E(Zd(B), z, L, 0)
                }
                ),
                L
            }
            return null
        }
        function Jd(w, E, L) {
            if (oe.isString(w))
                try {
                    return (E || JSON.parse)(w),
                    oe.trim(w)
                } catch (B) {
                    if (B.name !== "SyntaxError")
                        throw B
                }
            return (0,
            JSON.stringify)(w)
        }
        const qo = {
            transitional: Zu,
            adapter: ["xhr", "http", "fetch"],
            transformRequest: [function(E, L) {
                const B = L.getContentType() || ""
                  , z = B.indexOf("application/json") > -1
                  , re = oe.isObject(E);
                if (re && oe.isHTMLForm(E) && (E = new FormData(E)),
                oe.isFormData(E))
                    return z ? JSON.stringify(Ju(E)) : E;
                if (oe.isArrayBuffer(E) || oe.isBuffer(E) || oe.isStream(E) || oe.isFile(E) || oe.isBlob(E) || oe.isReadableStream(E))
                    return E;
                if (oe.isArrayBufferView(E))
                    return E.buffer;
                if (oe.isURLSearchParams(E))
                    return L.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                    E.toString();
                let de;
                if (re) {
                    if (B.indexOf("application/x-www-form-urlencoded") > -1)
                        return Gd(E, this.formSerializer).toString();
                    if ((de = oe.isFileList(E)) || B.indexOf("multipart/form-data") > -1) {
                        const $e = this.env && this.env.FormData;
                        return Ki(de ? {
                            "files[]": E
                        } : E, $e && new $e, this.formSerializer)
                    }
                }
                return re || z ? (L.setContentType("application/json", !1),
                Jd(E)) : E
            }
            ],
            transformResponse: [function(E) {
                const L = this.transitional || qo.transitional
                  , B = L && L.forcedJSONParsing
                  , z = this.responseType === "json";
                if (oe.isResponse(E) || oe.isReadableStream(E))
                    return E;
                if (E && oe.isString(E) && (B && !this.responseType || z)) {
                    const ie = !(L && L.silentJSONParsing) && z;
                    try {
                        return JSON.parse(E)
                    } catch (de) {
                        if (ie)
                            throw de.name === "SyntaxError" ? Be.from(de, Be.ERR_BAD_RESPONSE, this, null, this.response) : de
                    }
                }
                return E
            }
            ],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            maxBodyLength: -1,
            env: {
                FormData: Xt.classes.FormData,
                Blob: Xt.classes.Blob
            },
            validateStatus: function(E) {
                return E >= 200 && E < 300
            },
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*",
                    "Content-Type": void 0
                }
            }
        };
        oe.forEach(["delete", "get", "head", "post", "put", "patch"], w => {
            qo.headers[w] = {}
        }
        );
        var Ho = qo;
        const Xu = oe.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
        var Xd = w => {
            const E = {};
            let L, B, z;
            return w && w.split(`
`).forEach(function(ie) {
                z = ie.indexOf(":"),
                L = ie.substring(0, z).trim().toLowerCase(),
                B = ie.substring(z + 1).trim(),
                !(!L || E[L] && Xu[L]) && (L === "set-cookie" ? E[L] ? E[L].push(B) : E[L] = [B] : E[L] = E[L] ? E[L] + ", " + B : B)
            }),
            E
        }
        ;
        const Qu = Symbol("internals");
        function $s(w) {
            return w && String(w).trim().toLowerCase()
        }
        function _a(w) {
            return w === !1 || w == null ? w : oe.isArray(w) ? w.map(_a) : String(w)
        }
        function Qd(w) {
            const E = Object.create(null)
              , L = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
            let B;
            for (; B = L.exec(w); )
                E[B[1]] = B[2];
            return E
        }
        const eh = w => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(w.trim());
        function Ji(w, E, L, B, z) {
            if (oe.isFunction(B))
                return B.call(this, E, L);
            if (z && (E = L),
            !!oe.isString(E)) {
                if (oe.isString(B))
                    return E.indexOf(B) !== -1;
                if (oe.isRegExp(B))
                    return B.test(E)
            }
        }
        function th(w) {
            return w.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (E, L, B) => L.toUpperCase() + B)
        }
        function va(w, E) {
            const L = oe.toCamelCase(" " + E);
            ["get", "set", "has"].forEach(B => {
                Object.defineProperty(w, B + L, {
                    value: function(z, re, ie) {
                        return this[B].call(this, E, z, re, ie)
                    },
                    configurable: !0
                })
            }
            )
        }
        class wa {
            constructor(E) {
                E && this.set(E)
            }
            set(E, L, B) {
                const z = this;
                function re(de, $e, pe) {
                    const _e = $s($e);
                    if (!_e)
                        throw new Error("header name must be a non-empty string");
                    const Oe = oe.findKey(z, _e);
                    (!Oe || z[Oe] === void 0 || pe === !0 || pe === void 0 && z[Oe] !== !1) && (z[Oe || $e] = _a(de))
                }
                const ie = (de, $e) => oe.forEach(de, (pe, _e) => re(pe, _e, $e));
                if (oe.isPlainObject(E) || E instanceof this.constructor)
                    ie(E, L);
                else if (oe.isString(E) && (E = E.trim()) && !eh(E))
                    ie(Xd(E), L);
                else if (oe.isObject(E) && oe.isIterable(E)) {
                    let de = {}, $e, pe;
                    for (const _e of E) {
                        if (!oe.isArray(_e))
                            throw TypeError("Object iterator must return a key-value pair");
                        de[pe = _e[0]] = ($e = de[pe]) ? oe.isArray($e) ? [...$e, _e[1]] : [$e, _e[1]] : _e[1]
                    }
                    ie(de, L)
                } else
                    E != null && re(L, E, B);
                return this
            }
            get(E, L) {
                if (E = $s(E),
                E) {
                    const B = oe.findKey(this, E);
                    if (B) {
                        const z = this[B];
                        if (!L)
                            return z;
                        if (L === !0)
                            return Qd(z);
                        if (oe.isFunction(L))
                            return L.call(this, z, B);
                        if (oe.isRegExp(L))
                            return L.exec(z);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
            has(E, L) {
                if (E = $s(E),
                E) {
                    const B = oe.findKey(this, E);
                    return !!(B && this[B] !== void 0 && (!L || Ji(this, this[B], B, L)))
                }
                return !1
            }
            delete(E, L) {
                const B = this;
                let z = !1;
                function re(ie) {
                    if (ie = $s(ie),
                    ie) {
                        const de = oe.findKey(B, ie);
                        de && (!L || Ji(B, B[de], de, L)) && (delete B[de],
                        z = !0)
                    }
                }
                return oe.isArray(E) ? E.forEach(re) : re(E),
                z
            }
            clear(E) {
                const L = Object.keys(this);
                let B = L.length
                  , z = !1;
                for (; B--; ) {
                    const re = L[B];
                    (!E || Ji(this, this[re], re, E, !0)) && (delete this[re],
                    z = !0)
                }
                return z
            }
            normalize(E) {
                const L = this
                  , B = {};
                return oe.forEach(this, (z, re) => {
                    const ie = oe.findKey(B, re);
                    if (ie) {
                        L[ie] = _a(z),
                        delete L[re];
                        return
                    }
                    const de = E ? th(re) : String(re).trim();
                    de !== re && delete L[re],
                    L[de] = _a(z),
                    B[de] = !0
                }
                ),
                this
            }
            concat(...E) {
                return this.constructor.concat(this, ...E)
            }
            toJSON(E) {
                const L = Object.create(null);
                return oe.forEach(this, (B, z) => {
                    B != null && B !== !1 && (L[z] = E && oe.isArray(B) ? B.join(", ") : B)
                }
                ),
                L
            }
            [Symbol.iterator]() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
            toString() {
                return Object.entries(this.toJSON()).map( ([E,L]) => E + ": " + L).join(`
`)
            }
            getSetCookie() {
                return this.get("set-cookie") || []
            }
            get[Symbol.toStringTag]() {
                return "AxiosHeaders"
            }
            static from(E) {
                return E instanceof this ? E : new this(E)
            }
            static concat(E, ...L) {
                const B = new this(E);
                return L.forEach(z => B.set(z)),
                B
            }
            static accessor(E) {
                const B = (this[Qu] = this[Qu] = {
                    accessors: {}
                }).accessors
                  , z = this.prototype;
                function re(ie) {
                    const de = $s(ie);
                    B[de] || (va(z, ie),
                    B[de] = !0)
                }
                return oe.isArray(E) ? E.forEach(re) : re(E),
                this
            }
        }
        wa.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
        oe.reduceDescriptors(wa.prototype, ({value: w}, E) => {
            let L = E[0].toUpperCase() + E.slice(1);
            return {
                get: () => w,
                set(B) {
                    this[L] = B
                }
            }
        }
        ),
        oe.freezeMethods(wa);
        var Dn = wa;
        function Yo(w, E) {
            const L = this || Ho
              , B = E || L
              , z = Dn.from(B.headers);
            let re = B.data;
            return oe.forEach(w, function(de) {
                re = de.call(L, re, z.normalize(), E ? E.status : void 0)
            }),
            z.normalize(),
            re
        }
        function Vo(w) {
            return !!(w && w.__CANCEL__)
        }
        function li(w, E, L) {
            Be.call(this, w ?? "canceled", Be.ERR_CANCELED, E, L),
            this.name = "CanceledError"
        }
        oe.inherits(li, Be, {
            __CANCEL__: !0
        });
        function Wo(w, E, L) {
            const B = L.config.validateStatus;
            !L.status || !B || B(L.status) ? w(L) : E(new Be("Request failed with status code " + L.status,[Be.ERR_BAD_REQUEST, Be.ERR_BAD_RESPONSE][Math.floor(L.status / 100) - 4],L.config,L.request,L))
        }
        function nh(w) {
            const E = /^([-+\w]{1,25})(:?\/\/|:)/.exec(w);
            return E && E[1] || ""
        }
        function rh(w, E) {
            w = w || 10;
            const L = new Array(w)
              , B = new Array(w);
            let z = 0, re = 0, ie;
            return E = E !== void 0 ? E : 1e3,
            function($e) {
                const pe = Date.now()
                  , _e = B[re];
                ie || (ie = pe),
                L[z] = $e,
                B[z] = pe;
                let Oe = re
                  , Et = 0;
                for (; Oe !== z; )
                    Et += L[Oe++],
                    Oe = Oe % w;
                if (z = (z + 1) % w,
                z === re && (re = (re + 1) % w),
                pe - ie < E)
                    return;
                const Dt = _e && pe - _e;
                return Dt ? Math.round(Et * 1e3 / Dt) : void 0
            }
        }
        function ih(w, E) {
            let L = 0, B = 1e3 / E, z, re;
            const ie = (pe, _e=Date.now()) => {
                L = _e,
                z = null,
                re && (clearTimeout(re),
                re = null),
                w.apply(null, pe)
            }
            ;
            return [ (...pe) => {
                const _e = Date.now()
                  , Oe = _e - L;
                Oe >= B ? ie(pe, _e) : (z = pe,
                re || (re = setTimeout( () => {
                    re = null,
                    ie(z)
                }
                , B - Oe)))
            }
            , () => z && ie(z)]
        }
        const ba = (w, E, L=3) => {
            let B = 0;
            const z = rh(50, 250);
            return ih(re => {
                const ie = re.loaded
                  , de = re.lengthComputable ? re.total : void 0
                  , $e = ie - B
                  , pe = z($e)
                  , _e = ie <= de;
                B = ie;
                const Oe = {
                    loaded: ie,
                    total: de,
                    progress: de ? ie / de : void 0,
                    bytes: $e,
                    rate: pe || void 0,
                    estimated: pe && de && _e ? (de - ie) / pe : void 0,
                    event: re,
                    lengthComputable: de != null,
                    [E ? "download" : "upload"]: !0
                };
                w(Oe)
            }
            , L)
        }
          , zo = (w, E) => {
            const L = w != null;
            return [B => E[0]({
                lengthComputable: L,
                total: w,
                loaded: B
            }), E[1]]
        }
          , Go = w => (...E) => oe.asap( () => w(...E));
        var el = Xt.hasStandardBrowserEnv ? ( (w, E) => L => (L = new URL(L,Xt.origin),
        w.protocol === L.protocol && w.host === L.host && (E || w.port === L.port)))(new URL(Xt.origin), Xt.navigator && /(msie|trident)/i.test(Xt.navigator.userAgent)) : () => !0
          , Zo = Xt.hasStandardBrowserEnv ? {
            write(w, E, L, B, z, re) {
                const ie = [w + "=" + encodeURIComponent(E)];
                oe.isNumber(L) && ie.push("expires=" + new Date(L).toGMTString()),
                oe.isString(B) && ie.push("path=" + B),
                oe.isString(z) && ie.push("domain=" + z),
                re === !0 && ie.push("secure"),
                document.cookie = ie.join("; ")
            },
            read(w) {
                const E = document.cookie.match(new RegExp("(^|;\\s*)(" + w + ")=([^;]*)"));
                return E ? decodeURIComponent(E[3]) : null
            },
            remove(w) {
                this.write(w, "", Date.now() - 864e5)
            }
        } : {
            write() {},
            read() {
                return null
            },
            remove() {}
        };
        function sh(w) {
            return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(w)
        }
        function tl(w, E) {
            return E ? w.replace(/\/?\/$/, "") + "/" + E.replace(/^\/+/, "") : w
        }
        function Rs(w, E, L) {
            let B = !sh(E);
            return w && (B || L == !1) ? tl(w, E) : E
        }
        const Ko = w => w instanceof Dn ? {
            ...w
        } : w;
        function fi(w, E) {
            E = E || {};
            const L = {};
            function B(pe, _e, Oe, Et) {
                return oe.isPlainObject(pe) && oe.isPlainObject(_e) ? oe.merge.call({
                    caseless: Et
                }, pe, _e) : oe.isPlainObject(_e) ? oe.merge({}, _e) : oe.isArray(_e) ? _e.slice() : _e
            }
            function z(pe, _e, Oe, Et) {
                if (oe.isUndefined(_e)) {
                    if (!oe.isUndefined(pe))
                        return B(void 0, pe, Oe, Et)
                } else
                    return B(pe, _e, Oe, Et)
            }
            function re(pe, _e) {
                if (!oe.isUndefined(_e))
                    return B(void 0, _e)
            }
            function ie(pe, _e) {
                if (oe.isUndefined(_e)) {
                    if (!oe.isUndefined(pe))
                        return B(void 0, pe)
                } else
                    return B(void 0, _e)
            }
            function de(pe, _e, Oe) {
                if (Oe in E)
                    return B(pe, _e);
                if (Oe in w)
                    return B(void 0, pe)
            }
            const $e = {
                url: re,
                method: re,
                data: re,
                baseURL: ie,
                transformRequest: ie,
                transformResponse: ie,
                paramsSerializer: ie,
                timeout: ie,
                timeoutMessage: ie,
                withCredentials: ie,
                withXSRFToken: ie,
                adapter: ie,
                responseType: ie,
                xsrfCookieName: ie,
                xsrfHeaderName: ie,
                onUploadProgress: ie,
                onDownloadProgress: ie,
                decompress: ie,
                maxContentLength: ie,
                maxBodyLength: ie,
                beforeRedirect: ie,
                transport: ie,
                httpAgent: ie,
                httpsAgent: ie,
                cancelToken: ie,
                socketPath: ie,
                responseEncoding: ie,
                validateStatus: de,
                headers: (pe, _e, Oe) => z(Ko(pe), Ko(_e), Oe, !0)
            };
            return oe.forEach(Object.keys(Object.assign({}, w, E)), function(_e) {
                const Oe = $e[_e] || z
                  , Et = Oe(w[_e], E[_e], _e);
                oe.isUndefined(Et) && Oe !== de || (L[_e] = Et)
            }),
            L
        }
        var Jo = w => {
            const E = fi({}, w);
            let {data: L, withXSRFToken: B, xsrfHeaderName: z, xsrfCookieName: re, headers: ie, auth: de} = E;
            E.headers = ie = Dn.from(ie),
            E.url = zu(Rs(E.baseURL, E.url, E.allowAbsoluteUrls), w.params, w.paramsSerializer),
            de && ie.set("Authorization", "Basic " + btoa((de.username || "") + ":" + (de.password ? unescape(encodeURIComponent(de.password)) : "")));
            let $e;
            if (oe.isFormData(L)) {
                if (Xt.hasStandardBrowserEnv || Xt.hasStandardBrowserWebWorkerEnv)
                    ie.setContentType(void 0);
                else if (($e = ie.getContentType()) !== !1) {
                    const [pe,..._e] = $e ? $e.split(";").map(Oe => Oe.trim()).filter(Boolean) : [];
                    ie.setContentType([pe || "multipart/form-data", ..._e].join("; "))
                }
            }
            if (Xt.hasStandardBrowserEnv && (B && oe.isFunction(B) && (B = B(E)),
            B || B !== !1 && el(E.url))) {
                const pe = z && re && Zo.read(re);
                pe && ie.set(z, pe)
            }
            return E
        }
          , Xo = typeof XMLHttpRequest < "u" && function(w) {
            return new Promise(function(L, B) {
                const z = Jo(w);
                let re = z.data;
                const ie = Dn.from(z.headers).normalize();
                let {responseType: de, onUploadProgress: $e, onDownloadProgress: pe} = z, _e, Oe, Et, Dt, xe;
                function We() {
                    Dt && Dt(),
                    xe && xe(),
                    z.cancelToken && z.cancelToken.unsubscribe(_e),
                    z.signal && z.signal.removeEventListener("abort", _e)
                }
                let Ce = new XMLHttpRequest;
                Ce.open(z.method.toUpperCase(), z.url, !0),
                Ce.timeout = z.timeout;
                function Ye() {
                    if (!Ce)
                        return;
                    const Ut = Dn.from("getAllResponseHeaders"in Ce && Ce.getAllResponseHeaders())
                      , Qt = {
                        data: !de || de === "text" || de === "json" ? Ce.responseText : Ce.response,
                        status: Ce.status,
                        statusText: Ce.statusText,
                        headers: Ut,
                        config: w,
                        request: Ce
                    };
                    Wo(function(di) {
                        L(di),
                        We()
                    }, function(di) {
                        B(di),
                        We()
                    }, Qt),
                    Ce = null
                }
                "onloadend"in Ce ? Ce.onloadend = Ye : Ce.onreadystatechange = function() {
                    !Ce || Ce.readyState !== 4 || Ce.status === 0 && !(Ce.responseURL && Ce.responseURL.indexOf("file:") === 0) || setTimeout(Ye)
                }
                ,
                Ce.onabort = function() {
                    Ce && (B(new Be("Request aborted",Be.ECONNABORTED,w,Ce)),
                    Ce = null)
                }
                ,
                Ce.onerror = function() {
                    B(new Be("Network Error",Be.ERR_NETWORK,w,Ce)),
                    Ce = null
                }
                ,
                Ce.ontimeout = function() {
                    let _r = z.timeout ? "timeout of " + z.timeout + "ms exceeded" : "timeout exceeded";
                    const Qt = z.transitional || Zu;
                    z.timeoutErrorMessage && (_r = z.timeoutErrorMessage),
                    B(new Be(_r,Qt.clarifyTimeoutError ? Be.ETIMEDOUT : Be.ECONNABORTED,w,Ce)),
                    Ce = null
                }
                ,
                re === void 0 && ie.setContentType(null),
                "setRequestHeader"in Ce && oe.forEach(ie.toJSON(), function(_r, Qt) {
                    Ce.setRequestHeader(Qt, _r)
                }),
                oe.isUndefined(z.withCredentials) || (Ce.withCredentials = !!z.withCredentials),
                de && de !== "json" && (Ce.responseType = z.responseType),
                pe && ([Et,xe] = ba(pe, !0),
                Ce.addEventListener("progress", Et)),
                $e && Ce.upload && ([Oe,Dt] = ba($e),
                Ce.upload.addEventListener("progress", Oe),
                Ce.upload.addEventListener("loadend", Dt)),
                (z.cancelToken || z.signal) && (_e = Ut => {
                    Ce && (B(!Ut || Ut.type ? new li(null,w,Ce) : Ut),
                    Ce.abort(),
                    Ce = null)
                }
                ,
                z.cancelToken && z.cancelToken.subscribe(_e),
                z.signal && (z.signal.aborted ? _e() : z.signal.addEventListener("abort", _e)));
                const At = nh(z.url);
                if (At && Xt.protocols.indexOf(At) === -1) {
                    B(new Be("Unsupported protocol " + At + ":",Be.ERR_BAD_REQUEST,w));
                    return
                }
                Ce.send(re || null)
            }
            )
        }
          , nl = (w, E) => {
            const {length: L} = w = w ? w.filter(Boolean) : [];
            if (E || L) {
                let B = new AbortController, z;
                const re = function(pe) {
                    if (!z) {
                        z = !0,
                        de();
                        const _e = pe instanceof Error ? pe : this.reason;
                        B.abort(_e instanceof Be ? _e : new li(_e instanceof Error ? _e.message : _e))
                    }
                };
                let ie = E && setTimeout( () => {
                    ie = null,
                    re(new Be(`timeout ${E} of ms exceeded`,Be.ETIMEDOUT))
                }
                , E);
                const de = () => {
                    w && (ie && clearTimeout(ie),
                    ie = null,
                    w.forEach(pe => {
                        pe.unsubscribe ? pe.unsubscribe(re) : pe.removeEventListener("abort", re)
                    }
                    ),
                    w = null)
                }
                ;
                w.forEach(pe => pe.addEventListener("abort", re));
                const {signal: $e} = B;
                return $e.unsubscribe = () => oe.asap(de),
                $e
            }
        }
        ;
        const Qo = function*(w, E) {
            let L = w.byteLength;
            if (L < E) {
                yield w;
                return
            }
            let B = 0, z;
            for (; B < L; )
                z = B + E,
                yield w.slice(B, z),
                B = z
        }
          , ec = async function*(w, E) {
            for await(const L of Xi(w))
                yield*Qo(L, E)
        }
          , Xi = async function*(w) {
            if (w[Symbol.asyncIterator]) {
                yield*w;
                return
            }
            const E = w.getReader();
            try {
                for (; ; ) {
                    const {done: L, value: B} = await E.read();
                    if (L)
                        break;
                    yield B
                }
            } finally {
                await E.cancel()
            }
        }
          , tc = (w, E, L, B) => {
            const z = ec(w, E);
            let re = 0, ie, de = $e => {
                ie || (ie = !0,
                B && B($e))
            }
            ;
            return new ReadableStream({
                async pull($e) {
                    try {
                        const {done: pe, value: _e} = await z.next();
                        if (pe) {
                            de(),
                            $e.close();
                            return
                        }
                        let Oe = _e.byteLength;
                        if (L) {
                            let Et = re += Oe;
                            L(Et)
                        }
                        $e.enqueue(new Uint8Array(_e))
                    } catch (pe) {
                        throw de(pe),
                        pe
                    }
                },
                cancel($e) {
                    return de($e),
                    z.return()
                }
            },{
                highWaterMark: 2
            })
        }
          , Ps = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
          , rl = Ps && typeof ReadableStream == "function"
          , il = Ps && (typeof TextEncoder == "function" ? (w => E => w.encode(E))(new TextEncoder) : async w => new Uint8Array(await new Response(w).arrayBuffer()))
          , nc = (w, ...E) => {
            try {
                return !!w(...E)
            } catch {
                return !1
            }
        }
          , sl = rl && nc( () => {
            let w = !1;
            const E = new Request(Xt.origin,{
                body: new ReadableStream,
                method: "POST",
                get duplex() {
                    return w = !0,
                    "half"
                }
            }).headers.has("Content-Type");
            return w && !E
        }
        )
          , rc = 64 * 1024
          , ic = rl && nc( () => oe.isReadableStream(new Response("").body))
          , Ea = {
            stream: ic && (w => w.body)
        };
        Ps && (w => {
            ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(E => {
                !Ea[E] && (Ea[E] = oe.isFunction(w[E]) ? L => L[E]() : (L, B) => {
                    throw new Be(`Response type '${E}' is not supported`,Be.ERR_NOT_SUPPORT,B)
                }
                )
            }
            )
        }
        )(new Response);
        const oh = async w => {
            if (w == null)
                return 0;
            if (oe.isBlob(w))
                return w.size;
            if (oe.isSpecCompliantForm(w))
                return (await new Request(Xt.origin,{
                    method: "POST",
                    body: w
                }).arrayBuffer()).byteLength;
            if (oe.isArrayBufferView(w) || oe.isArrayBuffer(w))
                return w.byteLength;
            if (oe.isURLSearchParams(w) && (w = w + ""),
            oe.isString(w))
                return (await il(w)).byteLength
        }
          , al = async (w, E) => {
            const L = oe.toFiniteNumber(w.getContentLength());
            return L ?? oh(E)
        }
        ;
        var ch = Ps && (async w => {
            let {url: E, method: L, data: B, signal: z, cancelToken: re, timeout: ie, onDownloadProgress: de, onUploadProgress: $e, responseType: pe, headers: _e, withCredentials: Oe="same-origin", fetchOptions: Et} = Jo(w);
            pe = pe ? (pe + "").toLowerCase() : "text";
            let Dt = nl([z, re && re.toAbortSignal()], ie), xe;
            const We = Dt && Dt.unsubscribe && ( () => {
                Dt.unsubscribe()
            }
            );
            let Ce;
            try {
                if ($e && sl && L !== "get" && L !== "head" && (Ce = await al(_e, B)) !== 0) {
                    let Qt = new Request(E,{
                        method: "POST",
                        body: B,
                        duplex: "half"
                    }), jr;
                    if (oe.isFormData(B) && (jr = Qt.headers.get("content-type")) && _e.setContentType(jr),
                    Qt.body) {
                        const [di,Na] = zo(Ce, ba(Go($e)));
                        B = tc(Qt.body, rc, di, Na)
                    }
                }
                oe.isString(Oe) || (Oe = Oe ? "include" : "omit");
                const Ye = "credentials"in Request.prototype;
                xe = new Request(E,{
                    ...Et,
                    signal: Dt,
                    method: L.toUpperCase(),
                    headers: _e.normalize().toJSON(),
                    body: B,
                    duplex: "half",
                    credentials: Ye ? Oe : void 0
                });
                let At = await fetch(xe, Et);
                const Ut = ic && (pe === "stream" || pe === "response");
                if (ic && (de || Ut && We)) {
                    const Qt = {};
                    ["status", "statusText", "headers"].forEach(uc => {
                        Qt[uc] = At[uc]
                    }
                    );
                    const jr = oe.toFiniteNumber(At.headers.get("content-length"))
                      , [di,Na] = de && zo(jr, ba(Go(de), !0)) || [];
                    At = new Response(tc(At.body, rc, di, () => {
                        Na && Na(),
                        We && We()
                    }
                    ),Qt)
                }
                pe = pe || "text";
                let _r = await Ea[oe.findKey(Ea, pe) || "text"](At, w);
                return !Ut && We && We(),
                await new Promise( (Qt, jr) => {
                    Wo(Qt, jr, {
                        data: _r,
                        headers: Dn.from(At.headers),
                        status: At.status,
                        statusText: At.statusText,
                        config: w,
                        request: xe
                    })
                }
                )
            } catch (Ye) {
                throw We && We(),
                Ye && Ye.name === "TypeError" && /Load failed|fetch/i.test(Ye.message) ? Object.assign(new Be("Network Error",Be.ERR_NETWORK,w,xe), {
                    cause: Ye.cause || Ye
                }) : Be.from(Ye, Ye && Ye.code, w, xe)
            }
        }
        );
        const sc = {
            http: Zi,
            xhr: Xo,
            fetch: ch
        };
        oe.forEach(sc, (w, E) => {
            if (w) {
                try {
                    Object.defineProperty(w, "name", {
                        value: E
                    })
                } catch {}
                Object.defineProperty(w, "adapterName", {
                    value: E
                })
            }
        }
        );
        const ol = w => `- ${w}`
          , uh = w => oe.isFunction(w) || w === null || w === !1;
        var Sa = {
            getAdapter: w => {
                w = oe.isArray(w) ? w : [w];
                const {length: E} = w;
                let L, B;
                const z = {};
                for (let re = 0; re < E; re++) {
                    L = w[re];
                    let ie;
                    if (B = L,
                    !uh(L) && (B = sc[(ie = String(L)).toLowerCase()],
                    B === void 0))
                        throw new Be(`Unknown adapter '${ie}'`);
                    if (B)
                        break;
                    z[ie || "#" + re] = B
                }
                if (!B) {
                    const re = Object.entries(z).map( ([de,$e]) => `adapter ${de} ` + ($e === !1 ? "is not supported by the environment" : "is not available in the build"));
                    let ie = E ? re.length > 1 ? `since :
` + re.map(ol).join(`
`) : " " + ol(re[0]) : "as no adapter specified";
                    throw new Be("There is no suitable adapter to dispatch the request " + ie,"ERR_NOT_SUPPORT")
                }
                return B
            }
            ,
            adapters: sc
        };
        function ac(w) {
            if (w.cancelToken && w.cancelToken.throwIfRequested(),
            w.signal && w.signal.aborted)
                throw new li(null,w)
        }
        function cl(w) {
            return ac(w),
            w.headers = Dn.from(w.headers),
            w.data = Yo.call(w, w.transformRequest),
            ["post", "put", "patch"].indexOf(w.method) !== -1 && w.headers.setContentType("application/x-www-form-urlencoded", !1),
            Sa.getAdapter(w.adapter || Ho.adapter)(w).then(function(B) {
                return ac(w),
                B.data = Yo.call(w, w.transformResponse, B),
                B.headers = Dn.from(B.headers),
                B
            }, function(B) {
                return Vo(B) || (ac(w),
                B && B.response && (B.response.data = Yo.call(w, w.transformResponse, B.response),
                B.response.headers = Dn.from(B.response.headers))),
                Promise.reject(B)
            })
        }
        const ul = "1.10.0"
          , Ta = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach( (w, E) => {
            Ta[w] = function(B) {
                return typeof B === w || "a" + (E < 1 ? "n " : " ") + w
            }
        }
        );
        const ll = {};
        Ta.transitional = function(E, L, B) {
            function z(re, ie) {
                return "[Axios v" + ul + "] Transitional option '" + re + "'" + ie + (B ? ". " + B : "")
            }
            return (re, ie, de) => {
                if (E === !1)
                    throw new Be(z(ie, " has been removed" + (L ? " in " + L : "")),Be.ERR_DEPRECATED);
                return L && !ll[ie] && (ll[ie] = !0,
                console.warn(z(ie, " has been deprecated since v" + L + " and will be removed in the near future"))),
                E ? E(re, ie, de) : !0
            }
        }
        ,
        Ta.spelling = function(E) {
            return (L, B) => (console.warn(`${B} is likely a misspelling of ${E}`),
            !0)
        }
        ;
        function It(w, E, L) {
            if (typeof w != "object")
                throw new Be("options must be an object",Be.ERR_BAD_OPTION_VALUE);
            const B = Object.keys(w);
            let z = B.length;
            for (; z-- > 0; ) {
                const re = B[z]
                  , ie = E[re];
                if (ie) {
                    const de = w[re]
                      , $e = de === void 0 || ie(de, re, w);
                    if ($e !== !0)
                        throw new Be("option " + re + " must be " + $e,Be.ERR_BAD_OPTION_VALUE);
                    continue
                }
                if (L !== !0)
                    throw new Be("Unknown option " + re,Be.ERR_BAD_OPTION)
            }
        }
        var yt = {
            assertOptions: It,
            validators: Ta
        };
        const Zn = yt.validators;
        class Aa {
            constructor(E) {
                this.defaults = E || {},
                this.interceptors = {
                    request: new Do,
                    response: new Do
                }
            }
            async request(E, L) {
                try {
                    return await this._request(E, L)
                } catch (B) {
                    if (B instanceof Error) {
                        let z = {};
                        Error.captureStackTrace ? Error.captureStackTrace(z) : z = new Error;
                        const re = z.stack ? z.stack.replace(/^.+\n/, "") : "";
                        try {
                            B.stack ? re && !String(B.stack).endsWith(re.replace(/^.+\n.+\n/, "")) && (B.stack += `
` + re) : B.stack = re
                        } catch {}
                    }
                    throw B
                }
            }
            _request(E, L) {
                typeof E == "string" ? (L = L || {},
                L.url = E) : L = E || {},
                L = fi(this.defaults, L);
                const {transitional: B, paramsSerializer: z, headers: re} = L;
                B !== void 0 && yt.assertOptions(B, {
                    silentJSONParsing: Zn.transitional(Zn.boolean),
                    forcedJSONParsing: Zn.transitional(Zn.boolean),
                    clarifyTimeoutError: Zn.transitional(Zn.boolean)
                }, !1),
                z != null && (oe.isFunction(z) ? L.paramsSerializer = {
                    serialize: z
                } : yt.assertOptions(z, {
                    encode: Zn.function,
                    serialize: Zn.function
                }, !0)),
                L.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? L.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : L.allowAbsoluteUrls = !0),
                yt.assertOptions(L, {
                    baseUrl: Zn.spelling("baseURL"),
                    withXsrfToken: Zn.spelling("withXSRFToken")
                }, !0),
                L.method = (L.method || this.defaults.method || "get").toLowerCase();
                let ie = re && oe.merge(re.common, re[L.method]);
                re && oe.forEach(["delete", "get", "head", "post", "put", "patch", "common"], xe => {
                    delete re[xe]
                }
                ),
                L.headers = Dn.concat(ie, re);
                const de = [];
                let $e = !0;
                this.interceptors.request.forEach(function(We) {
                    typeof We.runWhen == "function" && We.runWhen(L) === !1 || ($e = $e && We.synchronous,
                    de.unshift(We.fulfilled, We.rejected))
                });
                const pe = [];
                this.interceptors.response.forEach(function(We) {
                    pe.push(We.fulfilled, We.rejected)
                });
                let _e, Oe = 0, Et;
                if (!$e) {
                    const xe = [cl.bind(this), void 0];
                    for (xe.unshift.apply(xe, de),
                    xe.push.apply(xe, pe),
                    Et = xe.length,
                    _e = Promise.resolve(L); Oe < Et; )
                        _e = _e.then(xe[Oe++], xe[Oe++]);
                    return _e
                }
                Et = de.length;
                let Dt = L;
                for (Oe = 0; Oe < Et; ) {
                    const xe = de[Oe++]
                      , We = de[Oe++];
                    try {
                        Dt = xe(Dt)
                    } catch (Ce) {
                        We.call(this, Ce);
                        break
                    }
                }
                try {
                    _e = cl.call(this, Dt)
                } catch (xe) {
                    return Promise.reject(xe)
                }
                for (Oe = 0,
                Et = pe.length; Oe < Et; )
                    _e = _e.then(pe[Oe++], pe[Oe++]);
                return _e
            }
            getUri(E) {
                E = fi(this.defaults, E);
                const L = Rs(E.baseURL, E.url, E.allowAbsoluteUrls);
                return zu(L, E.params, E.paramsSerializer)
            }
        }
        oe.forEach(["delete", "get", "head", "options"], function(E) {
            Aa.prototype[E] = function(L, B) {
                return this.request(fi(B || {}, {
                    method: E,
                    url: L,
                    data: (B || {}).data
                }))
            }
        }),
        oe.forEach(["post", "put", "patch"], function(E) {
            function L(B) {
                return function(re, ie, de) {
                    return this.request(fi(de || {}, {
                        method: E,
                        headers: B ? {
                            "Content-Type": "multipart/form-data"
                        } : {},
                        url: re,
                        data: ie
                    }))
                }
            }
            Aa.prototype[E] = L(),
            Aa.prototype[E + "Form"] = L(!0)
        });
        var Oa = Aa;
        class oc {
            constructor(E) {
                if (typeof E != "function")
                    throw new TypeError("executor must be a function.");
                let L;
                this.promise = new Promise(function(re) {
                    L = re
                }
                );
                const B = this;
                this.promise.then(z => {
                    if (!B._listeners)
                        return;
                    let re = B._listeners.length;
                    for (; re-- > 0; )
                        B._listeners[re](z);
                    B._listeners = null
                }
                ),
                this.promise.then = z => {
                    let re;
                    const ie = new Promise(de => {
                        B.subscribe(de),
                        re = de
                    }
                    ).then(z);
                    return ie.cancel = function() {
                        B.unsubscribe(re)
                    }
                    ,
                    ie
                }
                ,
                E(function(re, ie, de) {
                    B.reason || (B.reason = new li(re,ie,de),
                    L(B.reason))
                })
            }
            throwIfRequested() {
                if (this.reason)
                    throw this.reason
            }
            subscribe(E) {
                if (this.reason) {
                    E(this.reason);
                    return
                }
                this._listeners ? this._listeners.push(E) : this._listeners = [E]
            }
            unsubscribe(E) {
                if (!this._listeners)
                    return;
                const L = this._listeners.indexOf(E);
                L !== -1 && this._listeners.splice(L, 1)
            }
            toAbortSignal() {
                const E = new AbortController
                  , L = B => {
                    E.abort(B)
                }
                ;
                return this.subscribe(L),
                E.signal.unsubscribe = () => this.unsubscribe(L),
                E.signal
            }
            static source() {
                let E;
                return {
                    token: new oc(function(z) {
                        E = z
                    }
                    ),
                    cancel: E
                }
            }
        }
        var lh = oc;
        function fh(w) {
            return function(L) {
                return w.apply(null, L)
            }
        }
        function fl(w) {
            return oe.isObject(w) && w.isAxiosError === !0
        }
        const cc = {
            Continue: 100,
            SwitchingProtocols: 101,
            Processing: 102,
            EarlyHints: 103,
            Ok: 200,
            Created: 201,
            Accepted: 202,
            NonAuthoritativeInformation: 203,
            NoContent: 204,
            ResetContent: 205,
            PartialContent: 206,
            MultiStatus: 207,
            AlreadyReported: 208,
            ImUsed: 226,
            MultipleChoices: 300,
            MovedPermanently: 301,
            Found: 302,
            SeeOther: 303,
            NotModified: 304,
            UseProxy: 305,
            Unused: 306,
            TemporaryRedirect: 307,
            PermanentRedirect: 308,
            BadRequest: 400,
            Unauthorized: 401,
            PaymentRequired: 402,
            Forbidden: 403,
            NotFound: 404,
            MethodNotAllowed: 405,
            NotAcceptable: 406,
            ProxyAuthenticationRequired: 407,
            RequestTimeout: 408,
            Conflict: 409,
            Gone: 410,
            LengthRequired: 411,
            PreconditionFailed: 412,
            PayloadTooLarge: 413,
            UriTooLong: 414,
            UnsupportedMediaType: 415,
            RangeNotSatisfiable: 416,
            ExpectationFailed: 417,
            ImATeapot: 418,
            MisdirectedRequest: 421,
            UnprocessableEntity: 422,
            Locked: 423,
            FailedDependency: 424,
            TooEarly: 425,
            UpgradeRequired: 426,
            PreconditionRequired: 428,
            TooManyRequests: 429,
            RequestHeaderFieldsTooLarge: 431,
            UnavailableForLegalReasons: 451,
            InternalServerError: 500,
            NotImplemented: 501,
            BadGateway: 502,
            ServiceUnavailable: 503,
            GatewayTimeout: 504,
            HttpVersionNotSupported: 505,
            VariantAlsoNegotiates: 506,
            InsufficientStorage: 507,
            LoopDetected: 508,
            NotExtended: 510,
            NetworkAuthenticationRequired: 511
        };
        Object.entries(cc).forEach( ([w,E]) => {
            cc[E] = w
        }
        );
        var zt = cc;
        function Ia(w) {
            const E = new Oa(w)
              , L = e(Oa.prototype.request, E);
            return oe.extend(L, Oa.prototype, E, {
                allOwnKeys: !0
            }),
            oe.extend(L, E, null, {
                allOwnKeys: !0
            }),
            L.create = function(z) {
                return Ia(fi(w, z))
            }
            ,
            L
        }
        const Tt = Ia(Ho);
        return Tt.Axios = Oa,
        Tt.CanceledError = li,
        Tt.CancelToken = lh,
        Tt.isCancel = Vo,
        Tt.VERSION = ul,
        Tt.toFormData = Ki,
        Tt.AxiosError = Be,
        Tt.Cancel = Tt.CanceledError,
        Tt.all = function(E) {
            return Promise.all(E)
        }
        ,
        Tt.spread = fh,
        Tt.isAxiosError = fl,
        Tt.mergeConfig = fi,
        Tt.AxiosHeaders = Dn,
        Tt.formToJSON = w => Ju(oe.isHTMLForm(w) ? new FormData(w) : w),
        Tt.getAdapter = Sa.getAdapter,
        Tt.HttpStatusCode = zt,
        Tt.default = Tt,
        kp = Tt,
        kp
    }
    var _3 = ME();
    const v3 = jm(_3)
      , Xa = "campaigns";
    var $i;
    (function(e) {
        e[e.v1Create = `v1/${Xa}`] = "v1Create",
        e[e.v1Delete = `v1/${Xa}/:campaignId`] = "v1Delete",
        e[e.v1Read = `v1/${Xa}/:campaignId`] = "v1Read",
        e[e.v1Update = `v1/${Xa}/:campaignId`] = "v1Update",
        e[e.v1Search = `v1/${Xa}`] = "v1Search",
        e[e.v1Points = `v1/${Xa}/:campaignId/points`] = "v1Points"
    }
    )($i || ($i = {}));
    var tw;
    (function(e) {
        e.notFound = "CAMPAIGN_NOT_FOUND",
        e.notDeletable = "CAMPAIGN_NOT_DELETABLE",
        e.walletRequired = "WALLET_REQUIRED",
        e.referralNotValid = "REFERRAL_CODE_INVALID",
        e.referralCodeNotActive = "REFERRAL_CODE_NOT_ACTIVE"
    }
    )(tw || (tw = {}));
    class w3 extends Cu {
        create(t) {
            return this._create($i.v1Create, t)
        }
        search(t) {
            return this._search($i.v1Search, t)
        }
        searchAll(t) {
            return this._searchAll($i.v1Search, t)
        }
        list(t) {
            return this._list($i.v1Search, t)
        }
        listAll(t) {
            return this._listAll($i.v1Search, t)
        }
        findOne(t) {
            return this._findOne($i.v1Search, t)
        }
        points(t, n) {
            return this.axios.request({
                url: $i.v1Points.replace(":campaignId", t),
                method: "GET",
                params: new URLSearchParams(ze({
                    walletAddress: n
                }))
            }).then(r => r.data)
        }
        constructor(t) {
            super(t)
        }
    }
    const Pc = "transactions";
    var ps;
    (function(e) {
        e[e.v1Create = `v1/${Pc}`] = "v1Create",
        e[e.v1Delete = `v1/${Pc}/:tokenId`] = "v1Delete",
        e[e.v1Read = `v1/${Pc}/:tokenId`] = "v1Read",
        e[e.v1Update = `v1/${Pc}/:tokenId`] = "v1Update",
        e[e.v1Search = `v1/${Pc}`] = "v1Search"
    }
    )(ps || (ps = {}));
    class b3 extends Cu {
        create(t) {
            return this._create(ps.v1Create, t)
        }
        search(t) {
            return this._search(ps.v1Search, t)
        }
        searchAll(t) {
            return this._searchAll(ps.v1Search, t)
        }
        list(t) {
            return this._list(ps.v1Search, t)
        }
        listAll(t) {
            return this._listAll(ps.v1Search, t)
        }
        findOne(t) {
            return this._findOne(ps.v1Search, t)
        }
        constructor(t) {
            super(t)
        }
    }
    const kc = "wallet-blocks";
    var nw;
    (function(e) {
        e.CONFIG_CHANGE = "CONFIG_CHANGE"
    }
    )(nw || (nw = {}));
    var Pm = {
        exports: {}
    };
    (function(e, t) {
        var n = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof Hn < "u" && Hn
          , r = function() {
            function o() {
                this.fetch = !1,
                this.DOMException = n.DOMException
            }
            return o.prototype = n,
            new o
        }();
        (function(o) {
            (function(c) {
                var l = typeof o < "u" && o || typeof self < "u" && self || typeof Hn < "u" && Hn || {}
                  , f = {
                    searchParams: "URLSearchParams"in l,
                    iterable: "Symbol"in l && "iterator"in Symbol,
                    blob: "FileReader"in l && "Blob"in l && function() {
                        try {
                            return new Blob,
                            !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData"in l,
                    arrayBuffer: "ArrayBuffer"in l
                };
                function d(v) {
                    return v && DataView.prototype.isPrototypeOf(v)
                }
                if (f.arrayBuffer)
                    var h = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                      , y = ArrayBuffer.isView || function(v) {
                        return v && h.indexOf(Object.prototype.toString.call(v)) > -1
                    }
                    ;
                function I(v) {
                    if (typeof v != "string" && (v = String(v)),
                    /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(v) || v === "")
                        throw new TypeError('Invalid character in header field name: "' + v + '"');
                    return v.toLowerCase()
                }
                function $(v) {
                    return typeof v != "string" && (v = String(v)),
                    v
                }
                function O(v) {
                    var x = {
                        next: function() {
                            var Y = v.shift();
                            return {
                                done: Y === void 0,
                                value: Y
                            }
                        }
                    };
                    return f.iterable && (x[Symbol.iterator] = function() {
                        return x
                    }
                    ),
                    x
                }
                function A(v) {
                    this.map = {},
                    v instanceof A ? v.forEach(function(x, Y) {
                        this.append(Y, x)
                    }, this) : Array.isArray(v) ? v.forEach(function(x) {
                        if (x.length != 2)
                            throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + x.length);
                        this.append(x[0], x[1])
                    }, this) : v && Object.getOwnPropertyNames(v).forEach(function(x) {
                        this.append(x, v[x])
                    }, this)
                }
                A.prototype.append = function(v, x) {
                    v = I(v),
                    x = $(x);
                    var Y = this.map[v];
                    this.map[v] = Y ? Y + ", " + x : x
                }
                ,
                A.prototype.delete = function(v) {
                    delete this.map[I(v)]
                }
                ,
                A.prototype.get = function(v) {
                    return v = I(v),
                    this.has(v) ? this.map[v] : null
                }
                ,
                A.prototype.has = function(v) {
                    return this.map.hasOwnProperty(I(v))
                }
                ,
                A.prototype.set = function(v, x) {
                    this.map[I(v)] = $(x)
                }
                ,
                A.prototype.forEach = function(v, x) {
                    for (var Y in this.map)
                        this.map.hasOwnProperty(Y) && v.call(x, this.map[Y], Y, this)
                }
                ,
                A.prototype.keys = function() {
                    var v = [];
                    return this.forEach(function(x, Y) {
                        v.push(Y)
                    }),
                    O(v)
                }
                ,
                A.prototype.values = function() {
                    var v = [];
                    return this.forEach(function(x) {
                        v.push(x)
                    }),
                    O(v)
                }
                ,
                A.prototype.entries = function() {
                    var v = [];
                    return this.forEach(function(x, Y) {
                        v.push([Y, x])
                    }),
                    O(v)
                }
                ,
                f.iterable && (A.prototype[Symbol.iterator] = A.prototype.entries);
                function N(v) {
                    if (!v._noBody) {
                        if (v.bodyUsed)
                            return Promise.reject(new TypeError("Already read"));
                        v.bodyUsed = !0
                    }
                }
                function m(v) {
                    return new Promise(function(x, Y) {
                        v.onload = function() {
                            x(v.result)
                        }
                        ,
                        v.onerror = function() {
                            Y(v.error)
                        }
                    }
                    )
                }
                function g(v) {
                    var x = new FileReader
                      , Y = m(x);
                    return x.readAsArrayBuffer(v),
                    Y
                }
                function M(v) {
                    var x = new FileReader
                      , Y = m(x)
                      , W = /charset=([A-Za-z0-9_-]+)/.exec(v.type)
                      , te = W ? W[1] : "utf-8";
                    return x.readAsText(v, te),
                    Y
                }
                function G(v) {
                    for (var x = new Uint8Array(v), Y = new Array(x.length), W = 0; W < x.length; W++)
                        Y[W] = String.fromCharCode(x[W]);
                    return Y.join("")
                }
                function U(v) {
                    if (v.slice)
                        return v.slice(0);
                    var x = new Uint8Array(v.byteLength);
                    return x.set(new Uint8Array(v)),
                    x.buffer
                }
                function D() {
                    return this.bodyUsed = !1,
                    this._initBody = function(v) {
                        this.bodyUsed = this.bodyUsed,
                        this._bodyInit = v,
                        v ? typeof v == "string" ? this._bodyText = v : f.blob && Blob.prototype.isPrototypeOf(v) ? this._bodyBlob = v : f.formData && FormData.prototype.isPrototypeOf(v) ? this._bodyFormData = v : f.searchParams && URLSearchParams.prototype.isPrototypeOf(v) ? this._bodyText = v.toString() : f.arrayBuffer && f.blob && d(v) ? (this._bodyArrayBuffer = U(v.buffer),
                        this._bodyInit = new Blob([this._bodyArrayBuffer])) : f.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(v) || y(v)) ? this._bodyArrayBuffer = U(v) : this._bodyText = v = Object.prototype.toString.call(v) : (this._noBody = !0,
                        this._bodyText = ""),
                        this.headers.get("content-type") || (typeof v == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : f.searchParams && URLSearchParams.prototype.isPrototypeOf(v) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }
                    ,
                    f.blob && (this.blob = function() {
                        var v = N(this);
                        if (v)
                            return v;
                        if (this._bodyBlob)
                            return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer)
                            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData)
                            throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }
                    ),
                    this.arrayBuffer = function() {
                        if (this._bodyArrayBuffer) {
                            var v = N(this);
                            return v || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                        } else {
                            if (f.blob)
                                return this.blob().then(g);
                            throw new Error("could not read as ArrayBuffer")
                        }
                    }
                    ,
                    this.text = function() {
                        var v = N(this);
                        if (v)
                            return v;
                        if (this._bodyBlob)
                            return M(this._bodyBlob);
                        if (this._bodyArrayBuffer)
                            return Promise.resolve(G(this._bodyArrayBuffer));
                        if (this._bodyFormData)
                            throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }
                    ,
                    f.formData && (this.formData = function() {
                        return this.text().then(S)
                    }
                    ),
                    this.json = function() {
                        return this.text().then(JSON.parse)
                    }
                    ,
                    this
                }
                var K = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
                function _(v) {
                    var x = v.toUpperCase();
                    return K.indexOf(x) > -1 ? x : v
                }
                function T(v, x) {
                    if (!(this instanceof T))
                        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    x = x || {};
                    var Y = x.body;
                    if (v instanceof T) {
                        if (v.bodyUsed)
                            throw new TypeError("Already read");
                        this.url = v.url,
                        this.credentials = v.credentials,
                        x.headers || (this.headers = new A(v.headers)),
                        this.method = v.method,
                        this.mode = v.mode,
                        this.signal = v.signal,
                        !Y && v._bodyInit != null && (Y = v._bodyInit,
                        v.bodyUsed = !0)
                    } else
                        this.url = String(v);
                    if (this.credentials = x.credentials || this.credentials || "same-origin",
                    (x.headers || !this.headers) && (this.headers = new A(x.headers)),
                    this.method = _(x.method || this.method || "GET"),
                    this.mode = x.mode || this.mode || null,
                    this.signal = x.signal || this.signal || function() {
                        if ("AbortController"in l) {
                            var J = new AbortController;
                            return J.signal
                        }
                    }(),
                    this.referrer = null,
                    (this.method === "GET" || this.method === "HEAD") && Y)
                        throw new TypeError("Body not allowed for GET or HEAD requests");
                    if (this._initBody(Y),
                    (this.method === "GET" || this.method === "HEAD") && (x.cache === "no-store" || x.cache === "no-cache")) {
                        var W = /([?&])_=[^&]*/;
                        if (W.test(this.url))
                            this.url = this.url.replace(W, "$1_=" + new Date().getTime());
                        else {
                            var te = /\?/;
                            this.url += (te.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                        }
                    }
                }
                T.prototype.clone = function() {
                    return new T(this,{
                        body: this._bodyInit
                    })
                }
                ;
                function S(v) {
                    var x = new FormData;
                    return v.trim().split("&").forEach(function(Y) {
                        if (Y) {
                            var W = Y.split("=")
                              , te = W.shift().replace(/\+/g, " ")
                              , J = W.join("=").replace(/\+/g, " ");
                            x.append(decodeURIComponent(te), decodeURIComponent(J))
                        }
                    }),
                    x
                }
                function q(v) {
                    var x = new A
                      , Y = v.replace(/\r?\n[\t ]+/g, " ");
                    return Y.split("\r").map(function(W) {
                        return W.indexOf(`
`) === 0 ? W.substr(1, W.length) : W
                    }).forEach(function(W) {
                        var te = W.split(":")
                          , J = te.shift().trim();
                        if (J) {
                            var H = te.join(":").trim();
                            try {
                                x.append(J, H)
                            } catch (ae) {
                                console.warn("Response " + ae.message)
                            }
                        }
                    }),
                    x
                }
                D.call(T.prototype);
                function C(v, x) {
                    if (!(this instanceof C))
                        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    if (x || (x = {}),
                    this.type = "default",
                    this.status = x.status === void 0 ? 200 : x.status,
                    this.status < 200 || this.status > 599)
                        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                    this.ok = this.status >= 200 && this.status < 300,
                    this.statusText = x.statusText === void 0 ? "" : "" + x.statusText,
                    this.headers = new A(x.headers),
                    this.url = x.url || "",
                    this._initBody(v)
                }
                D.call(C.prototype),
                C.prototype.clone = function() {
                    return new C(this._bodyInit,{
                        status: this.status,
                        statusText: this.statusText,
                        headers: new A(this.headers),
                        url: this.url
                    })
                }
                ,
                C.error = function() {
                    var v = new C(null,{
                        status: 200,
                        statusText: ""
                    });
                    return v.ok = !1,
                    v.status = 0,
                    v.type = "error",
                    v
                }
                ;
                var F = [301, 302, 303, 307, 308];
                C.redirect = function(v, x) {
                    if (F.indexOf(x) === -1)
                        throw new RangeError("Invalid status code");
                    return new C(null,{
                        status: x,
                        headers: {
                            location: v
                        }
                    })
                }
                ,
                c.DOMException = l.DOMException;
                try {
                    new c.DOMException
                } catch {
                    c.DOMException = function(x, Y) {
                        this.message = x,
                        this.name = Y;
                        var W = Error(x);
                        this.stack = W.stack
                    }
                    ,
                    c.DOMException.prototype = Object.create(Error.prototype),
                    c.DOMException.prototype.constructor = c.DOMException
                }
                function X(v, x) {
                    return new Promise(function(Y, W) {
                        var te = new T(v,x);
                        if (te.signal && te.signal.aborted)
                            return W(new c.DOMException("Aborted","AbortError"));
                        var J = new XMLHttpRequest;
                        function H() {
                            J.abort()
                        }
                        J.onload = function() {
                            var P = {
                                statusText: J.statusText,
                                headers: q(J.getAllResponseHeaders() || "")
                            };
                            te.url.indexOf("file://") === 0 && (J.status < 200 || J.status > 599) ? P.status = 200 : P.status = J.status,
                            P.url = "responseURL"in J ? J.responseURL : P.headers.get("X-Request-URL");
                            var j = "response"in J ? J.response : J.responseText;
                            setTimeout(function() {
                                Y(new C(j,P))
                            }, 0)
                        }
                        ,
                        J.onerror = function() {
                            setTimeout(function() {
                                W(new TypeError("Network request failed"))
                            }, 0)
                        }
                        ,
                        J.ontimeout = function() {
                            setTimeout(function() {
                                W(new TypeError("Network request timed out"))
                            }, 0)
                        }
                        ,
                        J.onabort = function() {
                            setTimeout(function() {
                                W(new c.DOMException("Aborted","AbortError"))
                            }, 0)
                        }
                        ;
                        function ae(P) {
                            try {
                                return P === "" && l.location.href ? l.location.href : P
                            } catch {
                                return P
                            }
                        }
                        if (J.open(te.method, ae(te.url), !0),
                        te.credentials === "include" ? J.withCredentials = !0 : te.credentials === "omit" && (J.withCredentials = !1),
                        "responseType"in J && (f.blob ? J.responseType = "blob" : f.arrayBuffer && (J.responseType = "arraybuffer")),
                        x && typeof x.headers == "object" && !(x.headers instanceof A || l.Headers && x.headers instanceof l.Headers)) {
                            var Q = [];
                            Object.getOwnPropertyNames(x.headers).forEach(function(P) {
                                Q.push(I(P)),
                                J.setRequestHeader(P, $(x.headers[P]))
                            }),
                            te.headers.forEach(function(P, j) {
                                Q.indexOf(j) === -1 && J.setRequestHeader(j, P)
                            })
                        } else
                            te.headers.forEach(function(P, j) {
                                J.setRequestHeader(j, P)
                            });
                        te.signal && (te.signal.addEventListener("abort", H),
                        J.onreadystatechange = function() {
                            J.readyState === 4 && te.signal.removeEventListener("abort", H)
                        }
                        ),
                        J.send(typeof te._bodyInit > "u" ? null : te._bodyInit)
                    }
                    )
                }
                return X.polyfill = !0,
                l.fetch || (l.fetch = X,
                l.Headers = A,
                l.Request = T,
                l.Response = C),
                c.Headers = A,
                c.Request = T,
                c.Response = C,
                c.fetch = X,
                c
            }
            )({})
        }
        )(r),
        r.fetch.ponyfill = !0,
        delete r.fetch.polyfill;
        var s = n.fetch ? n : r;
        t = s.fetch,
        t.default = s.fetch,
        t.fetch = s.fetch,
        t.Headers = s.Headers,
        t.Request = s.Request,
        t.Response = s.Response,
        e.exports = t
    }
    )(Pm, Pm.exports);
    var E3 = Pm.exports;
    const S3 = jm(E3);
    var T3 = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    };
    class O0 extends Fd {
        constructor(t, n) {
            if (super(),
            !O0.validateClientUrl(t))
                throw new vm(t);
            this.clientUrl = t,
            this.httpProviderOptions = n
        }
        static validateClientUrl(t) {
            return typeof t == "string" ? /^http(s)?:\/\//i.test(t) : !1
        }
        getStatus() {
            throw new Ai
        }
        supportsSubscriptions() {
            return !1
        }
        request(t, n) {
            var r;
            return T3(this, void 0, void 0, function*() {
                const s = Object.assign(Object.assign({}, (r = this.httpProviderOptions) === null || r === void 0 ? void 0 : r.providerOptions), n)
                  , o = yield S3(this.clientUrl, Object.assign(Object.assign({}, s), {
                    method: "POST",
                    headers: Object.assign(Object.assign({}, s.headers), {
                        "Content-Type": "application/json"
                    }),
                    body: JSON.stringify(t)
                }));
                if (!o.ok)
                    throw new y0(yield o.json(),void 0,void 0,o.status);
                return yield o.json()
            })
        }
        on() {
            throw new Ai
        }
        removeListener() {
            throw new Ai
        }
        once() {
            throw new Ai
        }
        removeAllListeners() {
            throw new Ai
        }
        connect() {
            throw new Ai
        }
        disconnect() {
            throw new Ai
        }
        reset() {
            throw new Ai
        }
        reconnect() {
            throw new Ai
        }
    }
    var io = null;
    typeof WebSocket < "u" ? io = WebSocket : typeof MozWebSocket < "u" ? io = MozWebSocket : typeof global < "u" ? io = global.WebSocket || global.MozWebSocket : typeof window < "u" ? io = window.WebSocket || window.MozWebSocket : typeof self < "u" && (io = self.WebSocket || self.MozWebSocket);
    const A3 = io;
    class O3 extends y3 {
        constructor(t, n, r) {
            super(t, n, r)
        }
        _validateProviderPath(t) {
            return typeof t == "string" ? /^ws(s)?:\/\//i.test(t) : !1
        }
        getStatus() {
            if (this._socketConnection && !Rm(this._socketConnection))
                switch (this._socketConnection.readyState) {
                case this._socketConnection.CONNECTING:
                    return "connecting";
                case this._socketConnection.OPEN:
                    return "connected";
                default:
                    return "disconnected"
                }
            return "disconnected"
        }
        _openSocketConnection() {
            this._socketConnection = new A3(this._socketPath,void 0,this._socketOptions && Object.keys(this._socketOptions).length === 0 ? void 0 : this._socketOptions)
        }
        _closeSocketConnection(t, n) {
            var r;
            (r = this._socketConnection) === null || r === void 0 || r.close(t, n)
        }
        _sendToSocket(t) {
            var n;
            if (this.getStatus() === "disconnected")
                throw new _m;
            (n = this._socketConnection) === null || n === void 0 || n.send(JSON.stringify(t))
        }
        _parseResponses(t) {
            return this.chunkResponseParser.parseResponse(t.data)
        }
        _addSocketListeners() {
            var t, n, r, s;
            (t = this._socketConnection) === null || t === void 0 || t.addEventListener("open", this._onOpenHandler),
            (n = this._socketConnection) === null || n === void 0 || n.addEventListener("message", this._onMessageHandler),
            (r = this._socketConnection) === null || r === void 0 || r.addEventListener("close", o => this._onCloseHandler(o)),
            (s = this._socketConnection) === null || s === void 0 || s.addEventListener("error", this._onErrorHandler)
        }
        _removeSocketListeners() {
            var t, n, r;
            (t = this._socketConnection) === null || t === void 0 || t.removeEventListener("message", this._onMessageHandler),
            (n = this._socketConnection) === null || n === void 0 || n.removeEventListener("open", this._onOpenHandler),
            (r = this._socketConnection) === null || r === void 0 || r.removeEventListener("close", this._onCloseHandler)
        }
        _onCloseEvent(t) {
            var n;
            if (this._reconnectOptions.autoReconnect && (![1e3, 1001].includes(t.code) || !t.wasClean)) {
                this._reconnect();
                return
            }
            this._clearQueues(t),
            this._removeSocketListeners(),
            this._onDisconnect(t.code, t.reason),
            (n = this._socketConnection) === null || n === void 0 || n.removeEventListener("error", this._onErrorHandler)
        }
    }
    var rw;
    (function(e) {
        e.PROVIDER_CHANGED = "PROVIDER_CHANGED",
        e.BEFORE_PROVIDER_CHANGE = "BEFORE_PROVIDER_CHANGE"
    }
    )(rw || (rw = {}));
    class LE extends p0 {
        constructor(t, n) {
            super(),
            this.finished = !1,
            this.destroyed = !1,
            sE(t);
            const r = Ld(n);
            if (this.iHash = t.create(),
            typeof this.iHash.update != "function")
                throw new Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen,
            this.outputLen = this.iHash.outputLen;
            const s = this.blockLen
              , o = new Uint8Array(s);
            o.set(r.length > s ? t.create().update(r).digest() : r);
            for (let c = 0; c < o.length; c++)
                o[c] ^= 54;
            this.iHash.update(o),
            this.oHash = t.create();
            for (let c = 0; c < o.length; c++)
                o[c] ^= 106;
            this.oHash.update(o),
            o.fill(0)
        }
        update(t) {
            return oa(this),
            this.iHash.update(t),
            this
        }
        digestInto(t) {
            oa(this),
            Co(t, this.outputLen),
            this.finished = !0,
            this.iHash.digestInto(t),
            this.oHash.update(t),
            this.oHash.digestInto(t),
            this.destroy()
        }
        digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t),
            t
        }
        _cloneInto(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {oHash: n, iHash: r, finished: s, destroyed: o, blockLen: c, outputLen: l} = this;
            return t = t,
            t.finished = s,
            t.destroyed = o,
            t.blockLen = c,
            t.outputLen = l,
            t.oHash = n._cloneInto(t.oHash),
            t.iHash = r._cloneInto(t.iHash),
            t
        }
        destroy() {
            this.destroyed = !0,
            this.oHash.destroy(),
            this.iHash.destroy()
        }
    }
    const DE = (e, t, n) => new LE(e,t).update(n).digest();
    DE.create = (e, t) => new LE(e,t);
    function I3(e, t, n, r) {
        if (typeof e.setBigUint64 == "function")
            return e.setBigUint64(t, n, r);
        const s = BigInt(32)
          , o = BigInt(4294967295)
          , c = Number(n >> s & o)
          , l = Number(n & o)
          , f = r ? 4 : 0
          , d = r ? 0 : 4;
        e.setUint32(t + f, c, r),
        e.setUint32(t + d, l, r)
    }
    const N3 = (e, t, n) => e & t ^ ~e & n
      , x3 = (e, t, n) => e & t ^ e & n ^ t & n;
    class $3 extends p0 {
        constructor(t, n, r, s) {
            super(),
            this.blockLen = t,
            this.outputLen = n,
            this.padOffset = r,
            this.isLE = s,
            this.finished = !1,
            this.length = 0,
            this.pos = 0,
            this.destroyed = !1,
            this.buffer = new Uint8Array(t),
            this.view = Np(this.buffer)
        }
        update(t) {
            oa(this);
            const {view: n, buffer: r, blockLen: s} = this;
            t = Ld(t);
            const o = t.length;
            for (let c = 0; c < o; ) {
                const l = Math.min(s - this.pos, o - c);
                if (l === s) {
                    const f = Np(t);
                    for (; s <= o - c; c += s)
                        this.process(f, c);
                    continue
                }
                r.set(t.subarray(c, c + l), this.pos),
                this.pos += l,
                c += l,
                this.pos === s && (this.process(n, 0),
                this.pos = 0)
            }
            return this.length += t.length,
            this.roundClean(),
            this
        }
        digestInto(t) {
            oa(this),
            f0(t, this),
            this.finished = !0;
            const {buffer: n, view: r, blockLen: s, isLE: o} = this;
            let {pos: c} = this;
            n[c++] = 128,
            this.buffer.subarray(c).fill(0),
            this.padOffset > s - c && (this.process(r, 0),
            c = 0);
            for (let y = c; y < s; y++)
                n[y] = 0;
            I3(r, s - 8, BigInt(this.length * 8), o),
            this.process(r, 0);
            const l = Np(t)
              , f = this.outputLen;
            if (f % 4)
                throw new Error("_sha2: outputLen should be aligned to 32bit");
            const d = f / 4
              , h = this.get();
            if (d > h.length)
                throw new Error("_sha2: outputLen bigger than state");
            for (let y = 0; y < d; y++)
                l.setUint32(4 * y, h[y], o)
        }
        digest() {
            const {buffer: t, outputLen: n} = this;
            this.digestInto(t);
            const r = t.slice(0, n);
            return this.destroy(),
            r
        }
        _cloneInto(t) {
            t || (t = new this.constructor),
            t.set(...this.get());
            const {blockLen: n, buffer: r, length: s, finished: o, destroyed: c, pos: l} = this;
            return t.length = s,
            t.pos = l,
            t.finished = o,
            t.destroyed = c,
            s % n && t.buffer.set(r),
            t
        }
    }
    const R3 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
      , fs = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
      , ds = new Uint32Array(64);
    class P3 extends $3 {
        constructor() {
            super(64, 32, 8, !1),
            this.A = fs[0] | 0,
            this.B = fs[1] | 0,
            this.C = fs[2] | 0,
            this.D = fs[3] | 0,
            this.E = fs[4] | 0,
            this.F = fs[5] | 0,
            this.G = fs[6] | 0,
            this.H = fs[7] | 0
        }
        get() {
            const {A: t, B: n, C: r, D: s, E: o, F: c, G: l, H: f} = this;
            return [t, n, r, s, o, c, l, f]
        }
        set(t, n, r, s, o, c, l, f) {
            this.A = t | 0,
            this.B = n | 0,
            this.C = r | 0,
            this.D = s | 0,
            this.E = o | 0,
            this.F = c | 0,
            this.G = l | 0,
            this.H = f | 0
        }
        process(t, n) {
            for (let y = 0; y < 16; y++,
            n += 4)
                ds[y] = t.getUint32(n, !1);
            for (let y = 16; y < 64; y++) {
                const I = ds[y - 15]
                  , $ = ds[y - 2]
                  , O = zr(I, 7) ^ zr(I, 18) ^ I >>> 3
                  , A = zr($, 17) ^ zr($, 19) ^ $ >>> 10;
                ds[y] = A + ds[y - 7] + O + ds[y - 16] | 0
            }
            let {A: r, B: s, C: o, D: c, E: l, F: f, G: d, H: h} = this;
            for (let y = 0; y < 64; y++) {
                const I = zr(l, 6) ^ zr(l, 11) ^ zr(l, 25)
                  , $ = h + I + N3(l, f, d) + R3[y] + ds[y] | 0
                  , A = (zr(r, 2) ^ zr(r, 13) ^ zr(r, 22)) + x3(r, s, o) | 0;
                h = d,
                d = f,
                f = l,
                l = c + $ | 0,
                c = o,
                o = s,
                s = r,
                r = $ + A | 0
            }
            r = r + this.A | 0,
            s = s + this.B | 0,
            o = o + this.C | 0,
            c = c + this.D | 0,
            l = l + this.E | 0,
            f = f + this.F | 0,
            d = d + this.G | 0,
            h = h + this.H | 0,
            this.set(r, s, o, c, l, f, d, h)
        }
        roundClean() {
            ds.fill(0)
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0),
            this.buffer.fill(0)
        }
    }
    const k3 = aE( () => new P3);
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const UE = BigInt(0)
      , jd = BigInt(1)
      , C3 = BigInt(2);
    function fa(e) {
        return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array"
    }
    function Yu(e) {
        if (!fa(e))
            throw new Error("Uint8Array expected")
    }
    const M3 = Array.from({
        length: 256
    }, (e, t) => t.toString(16).padStart(2, "0"));
    function Ao(e) {
        Yu(e);
        let t = "";
        for (let n = 0; n < e.length; n++)
            t += M3[e[n]];
        return t
    }
    function BE(e) {
        const t = e.toString(16);
        return t.length & 1 ? `0${t}` : t
    }
    function I0(e) {
        if (typeof e != "string")
            throw new Error("hex string expected, got " + typeof e);
        return BigInt(e === "" ? "0" : `0x${e}`)
    }
    const Ii = {
        _0: 48,
        _9: 57,
        _A: 65,
        _F: 70,
        _a: 97,
        _f: 102
    };
    function iw(e) {
        if (e >= Ii._0 && e <= Ii._9)
            return e - Ii._0;
        if (e >= Ii._A && e <= Ii._F)
            return e - (Ii._A - 10);
        if (e >= Ii._a && e <= Ii._f)
            return e - (Ii._a - 10)
    }
    function Oo(e) {
        if (typeof e != "string")
            throw new Error("hex string expected, got " + typeof e);
        const t = e.length
          , n = t / 2;
        if (t % 2)
            throw new Error("padded hex string expected, got unpadded hex of length " + t);
        const r = new Uint8Array(n);
        for (let s = 0, o = 0; s < n; s++,
        o += 2) {
            const c = iw(e.charCodeAt(o))
              , l = iw(e.charCodeAt(o + 1));
            if (c === void 0 || l === void 0) {
                const f = e[o] + e[o + 1];
                throw new Error('hex string expected, got non-hex character "' + f + '" at index ' + o)
            }
            r[s] = c * 16 + l
        }
        return r
    }
    function ia(e) {
        return I0(Ao(e))
    }
    function N0(e) {
        return Yu(e),
        I0(Ao(Uint8Array.from(e).reverse()))
    }
    function Io(e, t) {
        return Oo(e.toString(16).padStart(t * 2, "0"))
    }
    function x0(e, t) {
        return Io(e, t).reverse()
    }
    function L3(e) {
        return Oo(BE(e))
    }
    function xr(e, t, n) {
        let r;
        if (typeof t == "string")
            try {
                r = Oo(t)
            } catch (o) {
                throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${o}`)
            }
        else if (fa(t))
            r = Uint8Array.from(t);
        else
            throw new Error(`${e} must be hex string or Uint8Array`);
        const s = r.length;
        if (typeof n == "number" && s !== n)
            throw new Error(`${e} expected ${n} bytes, got ${s}`);
        return r
    }
    function ku(...e) {
        let t = 0;
        for (let r = 0; r < e.length; r++) {
            const s = e[r];
            Yu(s),
            t += s.length
        }
        const n = new Uint8Array(t);
        for (let r = 0, s = 0; r < e.length; r++) {
            const o = e[r];
            n.set(o, s),
            s += o.length
        }
        return n
    }
    function D3(e, t) {
        if (e.length !== t.length)
            return !1;
        let n = 0;
        for (let r = 0; r < e.length; r++)
            n |= e[r] ^ t[r];
        return n === 0
    }
    function U3(e) {
        if (typeof e != "string")
            throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
        return new Uint8Array(new TextEncoder().encode(e))
    }
    function B3(e) {
        let t;
        for (t = 0; e > UE; e >>= jd,
        t += 1)
            ;
        return t
    }
    function F3(e, t) {
        return e >> BigInt(t) & jd
    }
    function j3(e, t, n) {
        return e | (n ? jd : UE) << BigInt(t)
    }
    const $0 = e => (C3 << BigInt(e - 1)) - jd
      , Cp = e => new Uint8Array(e)
      , sw = e => Uint8Array.from(e);
    function FE(e, t, n) {
        if (typeof e != "number" || e < 2)
            throw new Error("hashLen must be a number");
        if (typeof t != "number" || t < 2)
            throw new Error("qByteLen must be a number");
        if (typeof n != "function")
            throw new Error("hmacFn must be a function");
        let r = Cp(e)
          , s = Cp(e)
          , o = 0;
        const c = () => {
            r.fill(1),
            s.fill(0),
            o = 0
        }
          , l = (...y) => n(s, r, ...y)
          , f = (y=Cp()) => {
            s = l(sw([0]), y),
            r = l(),
            y.length !== 0 && (s = l(sw([1]), y),
            r = l())
        }
          , d = () => {
            if (o++ >= 1e3)
                throw new Error("drbg: tried 1000 values");
            let y = 0;
            const I = [];
            for (; y < t; ) {
                r = l();
                const $ = r.slice();
                I.push($),
                y += r.length
            }
            return ku(...I)
        }
        ;
        return (y, I) => {
            c(),
            f(y);
            let $;
            for (; !($ = I(d())); )
                f();
            return c(),
            $
        }
    }
    const q3 = {
        bigint: e => typeof e == "bigint",
        function: e => typeof e == "function",
        boolean: e => typeof e == "boolean",
        string: e => typeof e == "string",
        stringOrUint8Array: e => typeof e == "string" || fa(e),
        isSafeInteger: e => Number.isSafeInteger(e),
        array: e => Array.isArray(e),
        field: (e, t) => t.Fp.isValid(e),
        hash: e => typeof e == "function" && Number.isSafeInteger(e.outputLen)
    };
    function Vu(e, t, n={}) {
        const r = (s, o, c) => {
            const l = q3[o];
            if (typeof l != "function")
                throw new Error(`Invalid validator "${o}", expected function`);
            const f = e[s];
            if (!(c && f === void 0) && !l(f, e))
                throw new Error(`Invalid param ${String(s)}=${f} (${typeof f}), expected ${o}`)
        }
        ;
        for (const [s,o] of Object.entries(t))
            r(s, o, !1);
        for (const [s,o] of Object.entries(n))
            r(s, o, !0);
        return e
    }
    const H3 = Object.freeze(Object.defineProperty({
        __proto__: null,
        abytes: Yu,
        bitGet: F3,
        bitLen: B3,
        bitMask: $0,
        bitSet: j3,
        bytesToHex: Ao,
        bytesToNumberBE: ia,
        bytesToNumberLE: N0,
        concatBytes: ku,
        createHmacDrbg: FE,
        ensureBytes: xr,
        equalBytes: D3,
        hexToBytes: Oo,
        hexToNumber: I0,
        isBytes: fa,
        numberToBytesBE: Io,
        numberToBytesLE: x0,
        numberToHexUnpadded: BE,
        numberToVarBytesBE: L3,
        utf8ToBytes: U3,
        validateObject: Vu
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const sn = BigInt(0)
      , Wt = BigInt(1)
      , Ks = BigInt(2)
      , Y3 = BigInt(3)
      , km = BigInt(4)
      , aw = BigInt(5)
      , ow = BigInt(8);
    BigInt(9);
    BigInt(16);
    function Pn(e, t) {
        const n = e % t;
        return n >= sn ? n : t + n
    }
    function V3(e, t, n) {
        if (n <= sn || t < sn)
            throw new Error("Expected power/modulo > 0");
        if (n === Wt)
            return sn;
        let r = Wt;
        for (; t > sn; )
            t & Wt && (r = r * e % n),
            e = e * e % n,
            t >>= Wt;
        return r
    }
    function ar(e, t, n) {
        let r = e;
        for (; t-- > sn; )
            r *= r,
            r %= n;
        return r
    }
    function Cm(e, t) {
        if (e === sn || t <= sn)
            throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
        let n = Pn(e, t)
          , r = t
          , s = sn
          , o = Wt;
        for (; n !== sn; ) {
            const l = r / n
              , f = r % n
              , d = s - o * l;
            r = n,
            n = f,
            s = o,
            o = d
        }
        if (r !== Wt)
            throw new Error("invert: does not exist");
        return Pn(s, t)
    }
    function W3(e) {
        const t = (e - Wt) / Ks;
        let n, r, s;
        for (n = e - Wt,
        r = 0; n % Ks === sn; n /= Ks,
        r++)
            ;
        for (s = Ks; s < e && V3(s, t, e) !== e - Wt; s++)
            ;
        if (r === 1) {
            const c = (e + Wt) / km;
            return function(f, d) {
                const h = f.pow(d, c);
                if (!f.eql(f.sqr(h), d))
                    throw new Error("Cannot find square root");
                return h
            }
        }
        const o = (n + Wt) / Ks;
        return function(l, f) {
            if (l.pow(f, t) === l.neg(l.ONE))
                throw new Error("Cannot find square root");
            let d = r
              , h = l.pow(l.mul(l.ONE, s), n)
              , y = l.pow(f, o)
              , I = l.pow(f, n);
            for (; !l.eql(I, l.ONE); ) {
                if (l.eql(I, l.ZERO))
                    return l.ZERO;
                let $ = 1;
                for (let A = l.sqr(I); $ < d && !l.eql(A, l.ONE); $++)
                    A = l.sqr(A);
                const O = l.pow(h, Wt << BigInt(d - $ - 1));
                h = l.sqr(O),
                y = l.mul(y, O),
                I = l.mul(I, h),
                d = $
            }
            return y
        }
    }
    function z3(e) {
        if (e % km === Y3) {
            const t = (e + Wt) / km;
            return function(r, s) {
                const o = r.pow(s, t);
                if (!r.eql(r.sqr(o), s))
                    throw new Error("Cannot find square root");
                return o
            }
        }
        if (e % ow === aw) {
            const t = (e - aw) / ow;
            return function(r, s) {
                const o = r.mul(s, Ks)
                  , c = r.pow(o, t)
                  , l = r.mul(s, c)
                  , f = r.mul(r.mul(l, Ks), c)
                  , d = r.mul(l, r.sub(f, r.ONE));
                if (!r.eql(r.sqr(d), s))
                    throw new Error("Cannot find square root");
                return d
            }
        }
        return W3(e)
    }
    const G3 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
    function Z3(e) {
        const t = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        }
          , n = G3.reduce( (r, s) => (r[s] = "function",
        r), t);
        return Vu(e, n)
    }
    function K3(e, t, n) {
        if (n < sn)
            throw new Error("Expected power > 0");
        if (n === sn)
            return e.ONE;
        if (n === Wt)
            return t;
        let r = e.ONE
          , s = t;
        for (; n > sn; )
            n & Wt && (r = e.mul(r, s)),
            s = e.sqr(s),
            n >>= Wt;
        return r
    }
    function J3(e, t) {
        const n = new Array(t.length)
          , r = t.reduce( (o, c, l) => e.is0(c) ? o : (n[l] = o,
        e.mul(o, c)), e.ONE)
          , s = e.inv(r);
        return t.reduceRight( (o, c, l) => e.is0(c) ? o : (n[l] = e.mul(o, n[l]),
        e.mul(o, c)), s),
        n
    }
    function jE(e, t) {
        const n = t !== void 0 ? t : e.toString(2).length
          , r = Math.ceil(n / 8);
        return {
            nBitLength: n,
            nByteLength: r
        }
    }
    function X3(e, t, n=!1, r={}) {
        if (e <= sn)
            throw new Error(`Expected Field ORDER > 0, got ${e}`);
        const {nBitLength: s, nByteLength: o} = jE(e, t);
        if (o > 2048)
            throw new Error("Field lengths over 2048 bytes are not supported");
        const c = z3(e)
          , l = Object.freeze({
            ORDER: e,
            BITS: s,
            BYTES: o,
            MASK: $0(s),
            ZERO: sn,
            ONE: Wt,
            create: f => Pn(f, e),
            isValid: f => {
                if (typeof f != "bigint")
                    throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);
                return sn <= f && f < e
            }
            ,
            is0: f => f === sn,
            isOdd: f => (f & Wt) === Wt,
            neg: f => Pn(-f, e),
            eql: (f, d) => f === d,
            sqr: f => Pn(f * f, e),
            add: (f, d) => Pn(f + d, e),
            sub: (f, d) => Pn(f - d, e),
            mul: (f, d) => Pn(f * d, e),
            pow: (f, d) => K3(l, f, d),
            div: (f, d) => Pn(f * Cm(d, e), e),
            sqrN: f => f * f,
            addN: (f, d) => f + d,
            subN: (f, d) => f - d,
            mulN: (f, d) => f * d,
            inv: f => Cm(f, e),
            sqrt: r.sqrt || (f => c(l, f)),
            invertBatch: f => J3(l, f),
            cmov: (f, d, h) => h ? d : f,
            toBytes: f => n ? x0(f, o) : Io(f, o),
            fromBytes: f => {
                if (f.length !== o)
                    throw new Error(`Fp.fromBytes: expected ${o}, got ${f.length}`);
                return n ? N0(f) : ia(f)
            }
        });
        return Object.freeze(l)
    }
    function qE(e) {
        if (typeof e != "bigint")
            throw new Error("field order must be bigint");
        const t = e.toString(2).length;
        return Math.ceil(t / 8)
    }
    function HE(e) {
        const t = qE(e);
        return t + Math.ceil(t / 2)
    }
    function Q3(e, t, n=!1) {
        const r = e.length
          , s = qE(t)
          , o = HE(t);
        if (r < 16 || r < o || r > 1024)
            throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
        const c = n ? ia(e) : N0(e)
          , l = Pn(c, t - Wt) + Wt;
        return n ? x0(l, s) : Io(l, s)
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const eq = BigInt(0)
      , Mp = BigInt(1);
    function tq(e, t) {
        const n = (s, o) => {
            const c = o.negate();
            return s ? c : o
        }
          , r = s => {
            const o = Math.ceil(t / s) + 1
              , c = 2 ** (s - 1);
            return {
                windows: o,
                windowSize: c
            }
        }
        ;
        return {
            constTimeNegate: n,
            unsafeLadder(s, o) {
                let c = e.ZERO
                  , l = s;
                for (; o > eq; )
                    o & Mp && (c = c.add(l)),
                    l = l.double(),
                    o >>= Mp;
                return c
            },
            precomputeWindow(s, o) {
                const {windows: c, windowSize: l} = r(o)
                  , f = [];
                let d = s
                  , h = d;
                for (let y = 0; y < c; y++) {
                    h = d,
                    f.push(h);
                    for (let I = 1; I < l; I++)
                        h = h.add(d),
                        f.push(h);
                    d = h.double()
                }
                return f
            },
            wNAF(s, o, c) {
                const {windows: l, windowSize: f} = r(s);
                let d = e.ZERO
                  , h = e.BASE;
                const y = BigInt(2 ** s - 1)
                  , I = 2 ** s
                  , $ = BigInt(s);
                for (let O = 0; O < l; O++) {
                    const A = O * f;
                    let N = Number(c & y);
                    c >>= $,
                    N > f && (N -= I,
                    c += Mp);
                    const m = A
                      , g = A + Math.abs(N) - 1
                      , M = O % 2 !== 0
                      , G = N < 0;
                    N === 0 ? h = h.add(n(M, o[m])) : d = d.add(n(G, o[g]))
                }
                return {
                    p: d,
                    f: h
                }
            },
            wNAFCached(s, o, c, l) {
                const f = s._WINDOW_SIZE || 1;
                let d = o.get(s);
                return d || (d = this.precomputeWindow(s, f),
                f !== 1 && o.set(s, l(d))),
                this.wNAF(f, d, c)
            }
        }
    }
    function YE(e) {
        return Z3(e.Fp),
        Vu(e, {
            n: "bigint",
            h: "bigint",
            Gx: "field",
            Gy: "field"
        }, {
            nBitLength: "isSafeInteger",
            nByteLength: "isSafeInteger"
        }),
        Object.freeze({
            ...jE(e.n, e.nBitLength),
            ...e,
            p: e.Fp.ORDER
        })
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    function nq(e) {
        const t = YE(e);
        Vu(t, {
            a: "field",
            b: "field"
        }, {
            allowedPrivateKeyLengths: "array",
            wrapPrivateKey: "boolean",
            isTorsionFree: "function",
            clearCofactor: "function",
            allowInfinityPoint: "boolean",
            fromBytes: "function",
            toBytes: "function"
        });
        const {endo: n, Fp: r, a: s} = t;
        if (n) {
            if (!r.eql(s, r.ZERO))
                throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
            if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
                throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
        }
        return Object.freeze({
            ...t
        })
    }
    const {bytesToNumberBE: rq, hexToBytes: iq} = H3
      , ea = {
        Err: class extends Error {
            constructor(t="") {
                super(t)
            }
        }
        ,
        _parseInt(e) {
            const {Err: t} = ea;
            if (e.length < 2 || e[0] !== 2)
                throw new t("Invalid signature integer tag");
            const n = e[1]
              , r = e.subarray(2, n + 2);
            if (!n || r.length !== n)
                throw new t("Invalid signature integer: wrong length");
            if (r[0] & 128)
                throw new t("Invalid signature integer: negative");
            if (r[0] === 0 && !(r[1] & 128))
                throw new t("Invalid signature integer: unnecessary leading zero");
            return {
                d: rq(r),
                l: e.subarray(n + 2)
            }
        },
        toSig(e) {
            const {Err: t} = ea
              , n = typeof e == "string" ? iq(e) : e;
            Yu(n);
            let r = n.length;
            if (r < 2 || n[0] != 48)
                throw new t("Invalid signature tag");
            if (n[1] !== r - 2)
                throw new t("Invalid signature: incorrect length");
            const {d: s, l: o} = ea._parseInt(n.subarray(2))
              , {d: c, l} = ea._parseInt(o);
            if (l.length)
                throw new t("Invalid signature: left bytes after parsing");
            return {
                r: s,
                s: c
            }
        },
        hexFromSig(e) {
            const t = d => Number.parseInt(d[0], 16) & 8 ? "00" + d : d
              , n = d => {
                const h = d.toString(16);
                return h.length & 1 ? `0${h}` : h
            }
              , r = t(n(e.s))
              , s = t(n(e.r))
              , o = r.length / 2
              , c = s.length / 2
              , l = n(o)
              , f = n(c);
            return `30${n(c + o + 4)}02${f}${s}02${l}${r}`
        }
    }
      , Ri = BigInt(0)
      , lr = BigInt(1);
    BigInt(2);
    const cw = BigInt(3);
    BigInt(4);
    function sq(e) {
        const t = nq(e)
          , {Fp: n} = t
          , r = t.toBytes || ( (O, A, N) => {
            const m = A.toAffine();
            return ku(Uint8Array.from([4]), n.toBytes(m.x), n.toBytes(m.y))
        }
        )
          , s = t.fromBytes || (O => {
            const A = O.subarray(1)
              , N = n.fromBytes(A.subarray(0, n.BYTES))
              , m = n.fromBytes(A.subarray(n.BYTES, 2 * n.BYTES));
            return {
                x: N,
                y: m
            }
        }
        );
        function o(O) {
            const {a: A, b: N} = t
              , m = n.sqr(O)
              , g = n.mul(m, O);
            return n.add(n.add(g, n.mul(O, A)), N)
        }
        if (!n.eql(n.sqr(t.Gy), o(t.Gx)))
            throw new Error("bad generator point: equation left != right");
        function c(O) {
            return typeof O == "bigint" && Ri < O && O < t.n
        }
        function l(O) {
            if (!c(O))
                throw new Error("Expected valid bigint: 0 < bigint < curve.n")
        }
        function f(O) {
            const {allowedPrivateKeyLengths: A, nByteLength: N, wrapPrivateKey: m, n: g} = t;
            if (A && typeof O != "bigint") {
                if (fa(O) && (O = Ao(O)),
                typeof O != "string" || !A.includes(O.length))
                    throw new Error("Invalid key");
                O = O.padStart(N * 2, "0")
            }
            let M;
            try {
                M = typeof O == "bigint" ? O : ia(xr("private key", O, N))
            } catch {
                throw new Error(`private key must be ${N} bytes, hex or bigint, not ${typeof O}`)
            }
            return m && (M = Pn(M, g)),
            l(M),
            M
        }
        const d = new Map;
        function h(O) {
            if (!(O instanceof y))
                throw new Error("ProjectivePoint expected")
        }
        class y {
            constructor(A, N, m) {
                if (this.px = A,
                this.py = N,
                this.pz = m,
                A == null || !n.isValid(A))
                    throw new Error("x required");
                if (N == null || !n.isValid(N))
                    throw new Error("y required");
                if (m == null || !n.isValid(m))
                    throw new Error("z required")
            }
            static fromAffine(A) {
                const {x: N, y: m} = A || {};
                if (!A || !n.isValid(N) || !n.isValid(m))
                    throw new Error("invalid affine point");
                if (A instanceof y)
                    throw new Error("projective point not allowed");
                const g = M => n.eql(M, n.ZERO);
                return g(N) && g(m) ? y.ZERO : new y(N,m,n.ONE)
            }
            get x() {
                return this.toAffine().x
            }
            get y() {
                return this.toAffine().y
            }
            static normalizeZ(A) {
                const N = n.invertBatch(A.map(m => m.pz));
                return A.map( (m, g) => m.toAffine(N[g])).map(y.fromAffine)
            }
            static fromHex(A) {
                const N = y.fromAffine(s(xr("pointHex", A)));
                return N.assertValidity(),
                N
            }
            static fromPrivateKey(A) {
                return y.BASE.multiply(f(A))
            }
            _setWindowSize(A) {
                this._WINDOW_SIZE = A,
                d.delete(this)
            }
            assertValidity() {
                if (this.is0()) {
                    if (t.allowInfinityPoint && !n.is0(this.py))
                        return;
                    throw new Error("bad point: ZERO")
                }
                const {x: A, y: N} = this.toAffine();
                if (!n.isValid(A) || !n.isValid(N))
                    throw new Error("bad point: x or y not FE");
                const m = n.sqr(N)
                  , g = o(A);
                if (!n.eql(m, g))
                    throw new Error("bad point: equation left != right");
                if (!this.isTorsionFree())
                    throw new Error("bad point: not in prime-order subgroup")
            }
            hasEvenY() {
                const {y: A} = this.toAffine();
                if (n.isOdd)
                    return !n.isOdd(A);
                throw new Error("Field doesn't support isOdd")
            }
            equals(A) {
                h(A);
                const {px: N, py: m, pz: g} = this
                  , {px: M, py: G, pz: U} = A
                  , D = n.eql(n.mul(N, U), n.mul(M, g))
                  , K = n.eql(n.mul(m, U), n.mul(G, g));
                return D && K
            }
            negate() {
                return new y(this.px,n.neg(this.py),this.pz)
            }
            double() {
                const {a: A, b: N} = t
                  , m = n.mul(N, cw)
                  , {px: g, py: M, pz: G} = this;
                let U = n.ZERO
                  , D = n.ZERO
                  , K = n.ZERO
                  , _ = n.mul(g, g)
                  , T = n.mul(M, M)
                  , S = n.mul(G, G)
                  , q = n.mul(g, M);
                return q = n.add(q, q),
                K = n.mul(g, G),
                K = n.add(K, K),
                U = n.mul(A, K),
                D = n.mul(m, S),
                D = n.add(U, D),
                U = n.sub(T, D),
                D = n.add(T, D),
                D = n.mul(U, D),
                U = n.mul(q, U),
                K = n.mul(m, K),
                S = n.mul(A, S),
                q = n.sub(_, S),
                q = n.mul(A, q),
                q = n.add(q, K),
                K = n.add(_, _),
                _ = n.add(K, _),
                _ = n.add(_, S),
                _ = n.mul(_, q),
                D = n.add(D, _),
                S = n.mul(M, G),
                S = n.add(S, S),
                _ = n.mul(S, q),
                U = n.sub(U, _),
                K = n.mul(S, T),
                K = n.add(K, K),
                K = n.add(K, K),
                new y(U,D,K)
            }
            add(A) {
                h(A);
                const {px: N, py: m, pz: g} = this
                  , {px: M, py: G, pz: U} = A;
                let D = n.ZERO
                  , K = n.ZERO
                  , _ = n.ZERO;
                const T = t.a
                  , S = n.mul(t.b, cw);
                let q = n.mul(N, M)
                  , C = n.mul(m, G)
                  , F = n.mul(g, U)
                  , X = n.add(N, m)
                  , v = n.add(M, G);
                X = n.mul(X, v),
                v = n.add(q, C),
                X = n.sub(X, v),
                v = n.add(N, g);
                let x = n.add(M, U);
                return v = n.mul(v, x),
                x = n.add(q, F),
                v = n.sub(v, x),
                x = n.add(m, g),
                D = n.add(G, U),
                x = n.mul(x, D),
                D = n.add(C, F),
                x = n.sub(x, D),
                _ = n.mul(T, v),
                D = n.mul(S, F),
                _ = n.add(D, _),
                D = n.sub(C, _),
                _ = n.add(C, _),
                K = n.mul(D, _),
                C = n.add(q, q),
                C = n.add(C, q),
                F = n.mul(T, F),
                v = n.mul(S, v),
                C = n.add(C, F),
                F = n.sub(q, F),
                F = n.mul(T, F),
                v = n.add(v, F),
                q = n.mul(C, v),
                K = n.add(K, q),
                q = n.mul(x, v),
                D = n.mul(X, D),
                D = n.sub(D, q),
                q = n.mul(X, C),
                _ = n.mul(x, _),
                _ = n.add(_, q),
                new y(D,K,_)
            }
            subtract(A) {
                return this.add(A.negate())
            }
            is0() {
                return this.equals(y.ZERO)
            }
            wNAF(A) {
                return $.wNAFCached(this, d, A, N => {
                    const m = n.invertBatch(N.map(g => g.pz));
                    return N.map( (g, M) => g.toAffine(m[M])).map(y.fromAffine)
                }
                )
            }
            multiplyUnsafe(A) {
                const N = y.ZERO;
                if (A === Ri)
                    return N;
                if (l(A),
                A === lr)
                    return this;
                const {endo: m} = t;
                if (!m)
                    return $.unsafeLadder(this, A);
                let {k1neg: g, k1: M, k2neg: G, k2: U} = m.splitScalar(A)
                  , D = N
                  , K = N
                  , _ = this;
                for (; M > Ri || U > Ri; )
                    M & lr && (D = D.add(_)),
                    U & lr && (K = K.add(_)),
                    _ = _.double(),
                    M >>= lr,
                    U >>= lr;
                return g && (D = D.negate()),
                G && (K = K.negate()),
                K = new y(n.mul(K.px, m.beta),K.py,K.pz),
                D.add(K)
            }
            multiply(A) {
                l(A);
                let N = A, m, g;
                const {endo: M} = t;
                if (M) {
                    const {k1neg: G, k1: U, k2neg: D, k2: K} = M.splitScalar(N);
                    let {p: _, f: T} = this.wNAF(U)
                      , {p: S, f: q} = this.wNAF(K);
                    _ = $.constTimeNegate(G, _),
                    S = $.constTimeNegate(D, S),
                    S = new y(n.mul(S.px, M.beta),S.py,S.pz),
                    m = _.add(S),
                    g = T.add(q)
                } else {
                    const {p: G, f: U} = this.wNAF(N);
                    m = G,
                    g = U
                }
                return y.normalizeZ([m, g])[0]
            }
            multiplyAndAddUnsafe(A, N, m) {
                const g = y.BASE
                  , M = (U, D) => D === Ri || D === lr || !U.equals(g) ? U.multiplyUnsafe(D) : U.multiply(D)
                  , G = M(this, N).add(M(A, m));
                return G.is0() ? void 0 : G
            }
            toAffine(A) {
                const {px: N, py: m, pz: g} = this
                  , M = this.is0();
                A == null && (A = M ? n.ONE : n.inv(g));
                const G = n.mul(N, A)
                  , U = n.mul(m, A)
                  , D = n.mul(g, A);
                if (M)
                    return {
                        x: n.ZERO,
                        y: n.ZERO
                    };
                if (!n.eql(D, n.ONE))
                    throw new Error("invZ was invalid");
                return {
                    x: G,
                    y: U
                }
            }
            isTorsionFree() {
                const {h: A, isTorsionFree: N} = t;
                if (A === lr)
                    return !0;
                if (N)
                    return N(y, this);
                throw new Error("isTorsionFree() has not been declared for the elliptic curve")
            }
            clearCofactor() {
                const {h: A, clearCofactor: N} = t;
                return A === lr ? this : N ? N(y, this) : this.multiplyUnsafe(t.h)
            }
            toRawBytes(A=!0) {
                return this.assertValidity(),
                r(y, this, A)
            }
            toHex(A=!0) {
                return Ao(this.toRawBytes(A))
            }
        }
        y.BASE = new y(t.Gx,t.Gy,n.ONE),
        y.ZERO = new y(n.ZERO,n.ONE,n.ZERO);
        const I = t.nBitLength
          , $ = tq(y, t.endo ? Math.ceil(I / 2) : I);
        return {
            CURVE: t,
            ProjectivePoint: y,
            normPrivateKeyToScalar: f,
            weierstrassEquation: o,
            isWithinCurveOrder: c
        }
    }
    function aq(e) {
        const t = YE(e);
        return Vu(t, {
            hash: "hash",
            hmac: "function",
            randomBytes: "function"
        }, {
            bits2int: "function",
            bits2int_modN: "function",
            lowS: "boolean"
        }),
        Object.freeze({
            lowS: !0,
            ...t
        })
    }
    function oq(e) {
        const t = aq(e)
          , {Fp: n, n: r} = t
          , s = n.BYTES + 1
          , o = 2 * n.BYTES + 1;
        function c(v) {
            return Ri < v && v < n.ORDER
        }
        function l(v) {
            return Pn(v, r)
        }
        function f(v) {
            return Cm(v, r)
        }
        const {ProjectivePoint: d, normPrivateKeyToScalar: h, weierstrassEquation: y, isWithinCurveOrder: I} = sq({
            ...t,
            toBytes(v, x, Y) {
                const W = x.toAffine()
                  , te = n.toBytes(W.x)
                  , J = ku;
                return Y ? J(Uint8Array.from([x.hasEvenY() ? 2 : 3]), te) : J(Uint8Array.from([4]), te, n.toBytes(W.y))
            },
            fromBytes(v) {
                const x = v.length
                  , Y = v[0]
                  , W = v.subarray(1);
                if (x === s && (Y === 2 || Y === 3)) {
                    const te = ia(W);
                    if (!c(te))
                        throw new Error("Point is not on curve");
                    const J = y(te);
                    let H;
                    try {
                        H = n.sqrt(J)
                    } catch (P) {
                        const j = P instanceof Error ? ": " + P.message : "";
                        throw new Error("Point is not on curve" + j)
                    }
                    const ae = (H & lr) === lr;
                    return (Y & 1) === 1 !== ae && (H = n.neg(H)),
                    {
                        x: te,
                        y: H
                    }
                } else if (x === o && Y === 4) {
                    const te = n.fromBytes(W.subarray(0, n.BYTES))
                      , J = n.fromBytes(W.subarray(n.BYTES, 2 * n.BYTES));
                    return {
                        x: te,
                        y: J
                    }
                } else
                    throw new Error(`Point of length ${x} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)
            }
        })
          , $ = v => Ao(Io(v, t.nByteLength));
        function O(v) {
            const x = r >> lr;
            return v > x
        }
        function A(v) {
            return O(v) ? l(-v) : v
        }
        const N = (v, x, Y) => ia(v.slice(x, Y));
        class m {
            constructor(x, Y, W) {
                this.r = x,
                this.s = Y,
                this.recovery = W,
                this.assertValidity()
            }
            static fromCompact(x) {
                const Y = t.nByteLength;
                return x = xr("compactSignature", x, Y * 2),
                new m(N(x, 0, Y),N(x, Y, 2 * Y))
            }
            static fromDER(x) {
                const {r: Y, s: W} = ea.toSig(xr("DER", x));
                return new m(Y,W)
            }
            assertValidity() {
                if (!I(this.r))
                    throw new Error("r must be 0 < r < CURVE.n");
                if (!I(this.s))
                    throw new Error("s must be 0 < s < CURVE.n")
            }
            addRecoveryBit(x) {
                return new m(this.r,this.s,x)
            }
            recoverPublicKey(x) {
                const {r: Y, s: W, recovery: te} = this
                  , J = K(xr("msgHash", x));
                if (te == null || ![0, 1, 2, 3].includes(te))
                    throw new Error("recovery id invalid");
                const H = te === 2 || te === 3 ? Y + t.n : Y;
                if (H >= n.ORDER)
                    throw new Error("recovery id 2 or 3 invalid");
                const ae = te & 1 ? "03" : "02"
                  , Q = d.fromHex(ae + $(H))
                  , P = f(H)
                  , j = l(-J * P)
                  , se = l(W * P)
                  , ye = d.BASE.multiplyAndAddUnsafe(Q, j, se);
                if (!ye)
                    throw new Error("point at infinify");
                return ye.assertValidity(),
                ye
            }
            hasHighS() {
                return O(this.s)
            }
            normalizeS() {
                return this.hasHighS() ? new m(this.r,l(-this.s),this.recovery) : this
            }
            toDERRawBytes() {
                return Oo(this.toDERHex())
            }
            toDERHex() {
                return ea.hexFromSig({
                    r: this.r,
                    s: this.s
                })
            }
            toCompactRawBytes() {
                return Oo(this.toCompactHex())
            }
            toCompactHex() {
                return $(this.r) + $(this.s)
            }
        }
        const g = {
            isValidPrivateKey(v) {
                try {
                    return h(v),
                    !0
                } catch {
                    return !1
                }
            },
            normPrivateKeyToScalar: h,
            randomPrivateKey: () => {
                const v = HE(t.n);
                return Q3(t.randomBytes(v), t.n)
            }
            ,
            precompute(v=8, x=d.BASE) {
                return x._setWindowSize(v),
                x.multiply(BigInt(3)),
                x
            }
        };
        function M(v, x=!0) {
            return d.fromPrivateKey(v).toRawBytes(x)
        }
        function G(v) {
            const x = fa(v)
              , Y = typeof v == "string"
              , W = (x || Y) && v.length;
            return x ? W === s || W === o : Y ? W === 2 * s || W === 2 * o : v instanceof d
        }
        function U(v, x, Y=!0) {
            if (G(v))
                throw new Error("first arg must be private key");
            if (!G(x))
                throw new Error("second arg must be public key");
            return d.fromHex(x).multiply(h(v)).toRawBytes(Y)
        }
        const D = t.bits2int || function(v) {
            const x = ia(v)
              , Y = v.length * 8 - t.nBitLength;
            return Y > 0 ? x >> BigInt(Y) : x
        }
          , K = t.bits2int_modN || function(v) {
            return l(D(v))
        }
          , _ = $0(t.nBitLength);
        function T(v) {
            if (typeof v != "bigint")
                throw new Error("bigint expected");
            if (!(Ri <= v && v < _))
                throw new Error(`bigint expected < 2^${t.nBitLength}`);
            return Io(v, t.nByteLength)
        }
        function S(v, x, Y=q) {
            if (["recovered", "canonical"].some(De => De in Y))
                throw new Error("sign() legacy options not supported");
            const {hash: W, randomBytes: te} = t;
            let {lowS: J, prehash: H, extraEntropy: ae} = Y;
            J == null && (J = !0),
            v = xr("msgHash", v),
            H && (v = xr("prehashed msgHash", W(v)));
            const Q = K(v)
              , P = h(x)
              , j = [T(P), T(Q)];
            if (ae != null && ae !== !1) {
                const De = ae === !0 ? te(n.BYTES) : ae;
                j.push(xr("extraEntropy", De))
            }
            const se = ku(...j)
              , ye = Q;
            function we(De) {
                const Re = D(De);
                if (!I(Re))
                    return;
                const tt = f(Re)
                  , vt = d.BASE.multiply(Re).toAffine()
                  , bt = l(vt.x);
                if (bt === Ri)
                    return;
                const st = l(tt * l(ye + bt * P));
                if (st === Ri)
                    return;
                let ct = (vt.x === bt ? 0 : 2) | Number(vt.y & lr)
                  , Br = st;
                return J && O(st) && (Br = A(st),
                ct ^= 1),
                new m(bt,Br,ct)
            }
            return {
                seed: se,
                k2sig: we
            }
        }
        const q = {
            lowS: t.lowS,
            prehash: !1
        }
          , C = {
            lowS: t.lowS,
            prehash: !1
        };
        function F(v, x, Y=q) {
            const {seed: W, k2sig: te} = S(v, x, Y)
              , J = t;
            return FE(J.hash.outputLen, J.nByteLength, J.hmac)(W, te)
        }
        d.BASE._setWindowSize(8);
        function X(v, x, Y, W=C) {
            const te = v;
            if (x = xr("msgHash", x),
            Y = xr("publicKey", Y),
            "strict"in W)
                throw new Error("options.strict was renamed to lowS");
            const {lowS: J, prehash: H} = W;
            let ae, Q;
            try {
                if (typeof te == "string" || fa(te))
                    try {
                        ae = m.fromDER(te)
                    } catch (vt) {
                        if (!(vt instanceof ea.Err))
                            throw vt;
                        ae = m.fromCompact(te)
                    }
                else if (typeof te == "object" && typeof te.r == "bigint" && typeof te.s == "bigint") {
                    const {r: vt, s: bt} = te;
                    ae = new m(vt,bt)
                } else
                    throw new Error("PARSE");
                Q = d.fromHex(Y)
            } catch (vt) {
                if (vt.message === "PARSE")
                    throw new Error("signature must be Signature instance, Uint8Array or hex string");
                return !1
            }
            if (J && ae.hasHighS())
                return !1;
            H && (x = t.hash(x));
            const {r: P, s: j} = ae
              , se = K(x)
              , ye = f(j)
              , we = l(se * ye)
              , De = l(P * ye)
              , Re = d.BASE.multiplyAndAddUnsafe(Q, we, De)?.toAffine();
            return Re ? l(Re.x) === P : !1
        }
        return {
            CURVE: t,
            getPublicKey: M,
            getSharedSecret: U,
            sign: F,
            verify: X,
            ProjectivePoint: d,
            Signature: m,
            utils: g
        }
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    function cq(e) {
        return {
            hash: e,
            hmac: (t, ...n) => DE(e, t, LB(...n)),
            randomBytes: oE
        }
    }
    function uq(e, t) {
        const n = r => oq({
            ...e,
            ...cq(r)
        });
        return Object.freeze({
            ...n(t),
            create: n
        })
    }
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const VE = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
      , uw = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
      , lq = BigInt(1)
      , Mm = BigInt(2)
      , lw = (e, t) => (e + t / Mm) / t;
    function fq(e) {
        const t = VE
          , n = BigInt(3)
          , r = BigInt(6)
          , s = BigInt(11)
          , o = BigInt(22)
          , c = BigInt(23)
          , l = BigInt(44)
          , f = BigInt(88)
          , d = e * e * e % t
          , h = d * d * e % t
          , y = ar(h, n, t) * h % t
          , I = ar(y, n, t) * h % t
          , $ = ar(I, Mm, t) * d % t
          , O = ar($, s, t) * $ % t
          , A = ar(O, o, t) * O % t
          , N = ar(A, l, t) * A % t
          , m = ar(N, f, t) * N % t
          , g = ar(m, l, t) * A % t
          , M = ar(g, n, t) * h % t
          , G = ar(M, c, t) * O % t
          , U = ar(G, r, t) * d % t
          , D = ar(U, Mm, t);
        if (!Lm.eql(Lm.sqr(D), e))
            throw new Error("Cannot find square root");
        return D
    }
    const Lm = X3(VE, void 0, void 0, {
        sqrt: fq
    })
      , R0 = uq({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Lm,
        n: uw,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: e => {
                const t = uw
                  , n = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
                  , r = -lq * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
                  , s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
                  , o = n
                  , c = BigInt("0x100000000000000000000000000000000")
                  , l = lw(o * e, t)
                  , f = lw(-r * e, t);
                let d = Pn(e - l * n - f * s, t)
                  , h = Pn(-l * r - f * o, t);
                const y = d > c
                  , I = h > c;
                if (y && (d = t - d),
                I && (h = t - h),
                d > c || h > c)
                    throw new Error("splitScalar: Endomorphism failed, k=" + e);
                return {
                    k1neg: y,
                    k1: d,
                    k2neg: I,
                    k2: h
                }
            }
        }
    }, k3);
    BigInt(0);
    R0.ProjectivePoint;
    const dq = Object.freeze(Object.defineProperty({
        __proto__: null,
        secp256k1: R0
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var Lp;
    const hq = (Lp = R0) !== null && Lp !== void 0 ? Lp : dq;
    BigInt("0xffffffffffffffff");
    BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    const pq = hq.CURVE.n;
    pq / BigInt(2);
    var fw;
    (function(e) {
        e[e.Mainnet = 1] = "Mainnet",
        e[e.Goerli = 5] = "Goerli",
        e[e.Sepolia = 11155111] = "Sepolia"
    }
    )(fw || (fw = {}));
    var dw;
    (function(e) {
        e.Chainstart = "chainstart",
        e.Homestead = "homestead",
        e.Dao = "dao",
        e.TangerineWhistle = "tangerineWhistle",
        e.SpuriousDragon = "spuriousDragon",
        e.Byzantium = "byzantium",
        e.Constantinople = "constantinople",
        e.Petersburg = "petersburg",
        e.Istanbul = "istanbul",
        e.MuirGlacier = "muirGlacier",
        e.Berlin = "berlin",
        e.London = "london",
        e.ArrowGlacier = "arrowGlacier",
        e.GrayGlacier = "grayGlacier",
        e.MergeForkIdTransition = "mergeForkIdTransition",
        e.Merge = "merge",
        e.Shanghai = "shanghai",
        e.ShardingForkDev = "shardingFork"
    }
    )(dw || (dw = {}));
    var hw;
    (function(e) {
        e.ProofOfStake = "pos",
        e.ProofOfWork = "pow",
        e.ProofOfAuthority = "poa"
    }
    )(hw || (hw = {}));
    var pw;
    (function(e) {
        e.Ethash = "ethash",
        e.Clique = "clique",
        e.Casper = "casper"
    }
    )(pw || (pw = {}));
    var mw;
    (function(e) {
        e.PolygonMainnet = "polygon-mainnet",
        e.PolygonMumbai = "polygon-mumbai",
        e.ArbitrumRinkebyTestnet = "arbitrum-rinkeby-testnet",
        e.ArbitrumOne = "arbitrum-one",
        e.xDaiChain = "x-dai-chain",
        e.OptimisticKovan = "optimistic-kovan",
        e.OptimisticEthereum = "optimistic-ethereum"
    }
    )(mw || (mw = {}));
    var gw;
    (function(e) {
        e[e.Number = 0] = "Number",
        e[e.BigInt = 1] = "BigInt",
        e[e.Uint8Array = 2] = "Uint8Array",
        e[e.PrefixedHexString = 3] = "PrefixedHexString"
    }
    )(gw || (gw = {}));
    var Ci = {};
    Object.defineProperty(Ci, "__esModule", {
        value: !0
    });
    Ci.RLP = Ci.utils = Ci.decode = Ci.encode = void 0;
    function P0(e) {
        if (Array.isArray(e)) {
            const n = [];
            let r = 0;
            for (let s = 0; s < e.length; s++) {
                const o = P0(e[s]);
                n.push(o),
                r += o.length
            }
            return Um(_w(r, 192), ...n)
        }
        const t = JE(e);
        return t.length === 1 && t[0] < 128 ? t : Um(_w(t.length, 128), t)
    }
    Ci.encode = P0;
    function Qa(e, t, n) {
        if (n > e.length)
            throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
        return e.slice(t, n)
    }
    function yw(e) {
        if (e[0] === 0)
            throw new Error("invalid RLP: extra zeros");
        return GE(zE(e))
    }
    function _w(e, t) {
        if (e < 56)
            return Uint8Array.from([e + t]);
        const n = Bm(e)
          , r = n.length / 2
          , s = Bm(t + 55 + r);
        return Uint8Array.from(sd(s + n))
    }
    function WE(e, t=!1) {
        if (typeof e > "u" || e === null || e.length === 0)
            return Uint8Array.from([]);
        const n = JE(e)
          , r = Dm(n);
        if (t)
            return r;
        if (r.remainder.length !== 0)
            throw new Error("invalid RLP: remainder must be zero");
        return r.data
    }
    Ci.decode = WE;
    function Dm(e) {
        let t, n, r, s, o;
        const c = []
          , l = e[0];
        if (l <= 127)
            return {
                data: e.slice(0, 1),
                remainder: e.slice(1)
            };
        if (l <= 183) {
            if (t = l - 127,
            l === 128 ? r = Uint8Array.from([]) : r = Qa(e, 1, t),
            t === 2 && r[0] < 128)
                throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
            return {
                data: r,
                remainder: e.slice(t)
            }
        } else if (l <= 191) {
            if (n = l - 182,
            e.length - 1 < n)
                throw new Error("invalid RLP: not enough bytes for string length");
            if (t = yw(Qa(e, 1, n)),
            t <= 55)
                throw new Error("invalid RLP: expected string length to be greater than 55");
            return r = Qa(e, n, t + n),
            {
                data: r,
                remainder: e.slice(t + n)
            }
        } else if (l <= 247) {
            for (t = l - 191,
            s = Qa(e, 1, t); s.length; )
                o = Dm(s),
                c.push(o.data),
                s = o.remainder;
            return {
                data: c,
                remainder: e.slice(t)
            }
        } else {
            if (n = l - 246,
            t = yw(Qa(e, 1, n)),
            t < 56)
                throw new Error("invalid RLP: encoded list too short");
            const f = n + t;
            if (f > e.length)
                throw new Error("invalid RLP: total length is larger than the data");
            for (s = Qa(e, n, f); s.length; )
                o = Dm(s),
                c.push(o.data),
                s = o.remainder;
            return {
                data: c,
                remainder: e.slice(f)
            }
        }
    }
    const mq = Array.from({
        length: 256
    }, (e, t) => t.toString(16).padStart(2, "0"));
    function zE(e) {
        let t = "";
        for (let n = 0; n < e.length; n++)
            t += mq[e[n]];
        return t
    }
    function GE(e) {
        const t = Number.parseInt(e, 16);
        if (Number.isNaN(t))
            throw new Error("Invalid byte sequence");
        return t
    }
    function sd(e) {
        if (typeof e != "string")
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
        if (e.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex");
        const t = new Uint8Array(e.length / 2);
        for (let n = 0; n < t.length; n++) {
            const r = n * 2;
            t[n] = GE(e.slice(r, r + 2))
        }
        return t
    }
    function Um(...e) {
        if (e.length === 1)
            return e[0];
        const t = e.reduce( (r, s) => r + s.length, 0)
          , n = new Uint8Array(t);
        for (let r = 0, s = 0; r < e.length; r++) {
            const o = e[r];
            n.set(o, s),
            s += o.length
        }
        return n
    }
    function ZE(e) {
        return new TextEncoder().encode(e)
    }
    function Bm(e) {
        if (e < 0)
            throw new Error("Invalid integer as argument, must be unsigned!");
        const t = e.toString(16);
        return t.length % 2 ? `0${t}` : t
    }
    function gq(e) {
        return e.length % 2 ? `0${e}` : e
    }
    function KE(e) {
        return e.length >= 2 && e[0] === "0" && e[1] === "x"
    }
    function yq(e) {
        return typeof e != "string" ? e : KE(e) ? e.slice(2) : e
    }
    function JE(e) {
        if (e instanceof Uint8Array)
            return e;
        if (typeof e == "string")
            return KE(e) ? sd(gq(yq(e))) : ZE(e);
        if (typeof e == "number" || typeof e == "bigint")
            return e ? sd(Bm(e)) : Uint8Array.from([]);
        if (e == null)
            return Uint8Array.from([]);
        throw new Error("toBytes: received unsupported type " + typeof e)
    }
    Ci.utils = {
        bytesToHex: zE,
        concatBytes: Um,
        hexToBytes: sd,
        utf8ToBytes: ZE
    };
    Ci.RLP = {
        encode: P0,
        decode: WE
    };
    var _q = {};
    /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
    (function(e) {
        (function(t) {
            t(typeof DO_NOT_EXPORT_CRC > "u" ? e : {})
        }
        )(function(t) {
            t.version = "1.2.2";
            function n() {
                for (var _ = 0, T = new Array(256), S = 0; S != 256; ++S)
                    _ = S,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    _ = _ & 1 ? -306674912 ^ _ >>> 1 : _ >>> 1,
                    T[S] = _;
                return typeof Int32Array < "u" ? new Int32Array(T) : T
            }
            var r = n();
            function s(_) {
                var T = 0
                  , S = 0
                  , q = 0
                  , C = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
                for (q = 0; q != 256; ++q)
                    C[q] = _[q];
                for (q = 0; q != 256; ++q)
                    for (S = _[q],
                    T = 256 + q; T < 4096; T += 256)
                        S = C[T] = S >>> 8 ^ _[S & 255];
                var F = [];
                for (q = 1; q != 16; ++q)
                    F[q - 1] = typeof Int32Array < "u" ? C.subarray(q * 256, q * 256 + 256) : C.slice(q * 256, q * 256 + 256);
                return F
            }
            var o = s(r)
              , c = o[0]
              , l = o[1]
              , f = o[2]
              , d = o[3]
              , h = o[4]
              , y = o[5]
              , I = o[6]
              , $ = o[7]
              , O = o[8]
              , A = o[9]
              , N = o[10]
              , m = o[11]
              , g = o[12]
              , M = o[13]
              , G = o[14];
            function U(_, T) {
                for (var S = T ^ -1, q = 0, C = _.length; q < C; )
                    S = S >>> 8 ^ r[(S ^ _.charCodeAt(q++)) & 255];
                return ~S
            }
            function D(_, T) {
                for (var S = T ^ -1, q = _.length - 15, C = 0; C < q; )
                    S = G[_[C++] ^ S & 255] ^ M[_[C++] ^ S >> 8 & 255] ^ g[_[C++] ^ S >> 16 & 255] ^ m[_[C++] ^ S >>> 24] ^ N[_[C++]] ^ A[_[C++]] ^ O[_[C++]] ^ $[_[C++]] ^ I[_[C++]] ^ y[_[C++]] ^ h[_[C++]] ^ d[_[C++]] ^ f[_[C++]] ^ l[_[C++]] ^ c[_[C++]] ^ r[_[C++]];
                for (q += 15; C < q; )
                    S = S >>> 8 ^ r[(S ^ _[C++]) & 255];
                return ~S
            }
            function K(_, T) {
                for (var S = T ^ -1, q = 0, C = _.length, F = 0, X = 0; q < C; )
                    F = _.charCodeAt(q++),
                    F < 128 ? S = S >>> 8 ^ r[(S ^ F) & 255] : F < 2048 ? (S = S >>> 8 ^ r[(S ^ (192 | F >> 6 & 31)) & 255],
                    S = S >>> 8 ^ r[(S ^ (128 | F & 63)) & 255]) : F >= 55296 && F < 57344 ? (F = (F & 1023) + 64,
                    X = _.charCodeAt(q++) & 1023,
                    S = S >>> 8 ^ r[(S ^ (240 | F >> 8 & 7)) & 255],
                    S = S >>> 8 ^ r[(S ^ (128 | F >> 2 & 63)) & 255],
                    S = S >>> 8 ^ r[(S ^ (128 | X >> 6 & 15 | (F & 3) << 4)) & 255],
                    S = S >>> 8 ^ r[(S ^ (128 | X & 63)) & 255]) : (S = S >>> 8 ^ r[(S ^ (224 | F >> 12 & 15)) & 255],
                    S = S >>> 8 ^ r[(S ^ (128 | F >> 6 & 63)) & 255],
                    S = S >>> 8 ^ r[(S ^ (128 | F & 63)) & 255]);
                return ~S
            }
            t.table = r,
            t.bstr = U,
            t.buf = D,
            t.str = K
        })
    }
    )(_q);
    var vw;
    (function(e) {
        e[e.EIP155ReplayProtection = 155] = "EIP155ReplayProtection",
        e[e.EIP1559FeeMarket = 1559] = "EIP1559FeeMarket",
        e[e.EIP2718TypedTransaction = 2718] = "EIP2718TypedTransaction",
        e[e.EIP2930AccessLists = 2930] = "EIP2930AccessLists"
    }
    )(vw || (vw = {}));
    const vq = 2;
    xE(vq.toString(16).padStart(2, "0"));
    const wq = 1;
    xE(wq.toString(16).padStart(2, "0"));
    class rn {
        constructor(t) {
            if (this.toAddress = () => {
                if (this.isDirect()) {
                    const n = this._iban.slice(4)
                      , r = rn._parseInt(n, 36)
                      , s = Wv(r, 40);
                    return n3(s)
                }
                throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35")
            }
            ,
            rn.isIndirect(t) || rn.isDirect(t))
                this._iban = t;
            else
                throw new Error("Invalid IBAN was provided")
        }
        static isDirect(t) {
            return t.length === 34 || t.length === 35
        }
        isDirect() {
            return rn.isDirect(this._iban)
        }
        static isIndirect(t) {
            return t.length === 20
        }
        isIndirect() {
            return rn.isIndirect(this._iban)
        }
        static isValid(t) {
            return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(t) && rn._mod9710(rn._iso13616Prepare(t)) === 1
        }
        isValid() {
            return rn.isValid(this._iban)
        }
        static fromBban(t) {
            const n = "XE"
              , s = `0${(98 - this._mod9710(this._iso13616Prepare(`${n}00${t}`))).toString()}`.slice(-2);
            return new rn(`${n}${s}${t}`)
        }
        static createIndirect(t) {
            return rn.fromBban(`ETH${t.institution}${t.identifier}`)
        }
        static fromAddress(t) {
            if (!$u(t))
                throw new dE(t);
            const r = BigInt(e3(t)).toString(36)
              , s = Wv(r, 15);
            return rn.fromBban(s.toUpperCase())
        }
        static toIban(t) {
            return rn.fromAddress(t).toString()
        }
        client() {
            return this.isIndirect() ? this._iban.slice(11) : ""
        }
        checksum() {
            return this._iban.slice(2, 4)
        }
        institution() {
            return this.isIndirect() ? this._iban.slice(7, 11) : ""
        }
        toString() {
            return this._iban
        }
    }
    rn._iso13616Prepare = e => {
        const r = e.toUpperCase();
        return `${r.slice(4)}${r.slice(0, 4)}`.split("").map(o => {
            const c = o.charCodeAt(0);
            return c >= 65 && c <= 90 ? c - 65 + 10 : o
        }
        ).join("")
    }
    ;
    rn._parseInt = (e, t) => [...e].reduce( (n, r) => BigInt(parseInt(r, t)) + BigInt(t) * n, BigInt(0));
    rn._mod9710 = e => {
        let t = e, n;
        for (; t.length > 2; )
            n = t.slice(0, 9),
            t = `${(parseInt(n, 10) % 97).toString()}${t.slice(n.length)}`;
        return parseInt(t, 10) % 97
    }
    ;
    rn.toAddress = e => new rn(e).toAddress();
    (function(e, t) {
        if (e.setImmediate)
            return;
        var n = 1, r = {}, s = !1, o = e.document, c;
        function l(g) {
            typeof g != "function" && (g = new Function("" + g));
            for (var M = new Array(arguments.length - 1), G = 0; G < M.length; G++)
                M[G] = arguments[G + 1];
            var U = {
                callback: g,
                args: M
            };
            return r[n] = U,
            c(n),
            n++
        }
        function f(g) {
            delete r[g]
        }
        function d(g) {
            var M = g.callback
              , G = g.args;
            switch (G.length) {
            case 0:
                M();
                break;
            case 1:
                M(G[0]);
                break;
            case 2:
                M(G[0], G[1]);
                break;
            case 3:
                M(G[0], G[1], G[2]);
                break;
            default:
                M.apply(t, G);
                break
            }
        }
        function h(g) {
            if (s)
                setTimeout(h, 0, g);
            else {
                var M = r[g];
                if (M) {
                    s = !0;
                    try {
                        d(M)
                    } finally {
                        f(g),
                        s = !1
                    }
                }
            }
        }
        function y() {
            c = function(g) {
                process.nextTick(function() {
                    h(g)
                })
            }
        }
        function I() {
            if (e.postMessage && !e.importScripts) {
                var g = !0
                  , M = e.onmessage;
                return e.onmessage = function() {
                    g = !1
                }
                ,
                e.postMessage("", "*"),
                e.onmessage = M,
                g
            }
        }
        function $() {
            var g = "setImmediate$" + Math.random() + "$"
              , M = function(G) {
                G.source === e && typeof G.data == "string" && G.data.indexOf(g) === 0 && h(+G.data.slice(g.length))
            };
            e.addEventListener ? e.addEventListener("message", M, !1) : e.attachEvent("onmessage", M),
            c = function(G) {
                e.postMessage(g + G, "*")
            }
        }
        function O() {
            var g = new MessageChannel;
            g.port1.onmessage = function(M) {
                var G = M.data;
                h(G)
            }
            ,
            c = function(M) {
                g.port2.postMessage(M)
            }
        }
        function A() {
            var g = o.documentElement;
            c = function(M) {
                var G = o.createElement("script");
                G.onreadystatechange = function() {
                    h(M),
                    G.onreadystatechange = null,
                    g.removeChild(G),
                    G = null
                }
                ,
                g.appendChild(G)
            }
        }
        function N() {
            c = function(g) {
                setTimeout(h, 0, g)
            }
        }
        var m = Object.getPrototypeOf && Object.getPrototypeOf(e);
        m = m && m.setTimeout ? m : e,
        {}.toString.call(e.process) === "[object process]" ? y() : I() ? $() : e.MessageChannel ? O() : o && "onreadystatechange"in o.createElement("script") ? A() : N(),
        m.setImmediate = l,
        m.clearImmediate = f
    }
    )(typeof self > "u" ? typeof Hn > "u" ? Hn : Hn : self);
    const bq = {
        type: "object",
        properties: {
            address: {
                format: "address"
            },
            storageKeys: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            }
        }
    }
      , k0 = {
        type: "array",
        items: Object.assign({}, bq)
    };
    Object.assign({}, k0);
    const ww = {
        type: "string",
        enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
    }
      , bw = {
        type: "string",
        enum: ["arrowGlacier", "berlin", "byzantium", "chainstart", "constantinople", "dao", "homestead", "istanbul", "london", "merge", "muirGlacier", "petersburg", "shanghai", "spuriousDragon", "tangerineWhistle"]
    }
      , Eq = {
        type: "object",
        properties: {
            name: {
                format: "string"
            },
            networkId: {
                format: "uint"
            },
            chainId: {
                format: "uint"
            }
        }
    }
      , Sq = {
        type: "object",
        properties: {
            from: {
                format: "address"
            },
            to: {
                oneOf: [{
                    format: "address"
                }, {
                    type: "null"
                }]
            },
            value: {
                format: "uint"
            },
            gas: {
                format: "uint"
            },
            gasPrice: {
                format: "uint"
            },
            effectiveGasPrice: {
                format: "uint"
            },
            type: {
                format: "uint"
            },
            maxFeePerGas: {
                format: "uint"
            },
            maxPriorityFeePerGas: {
                format: "uint"
            },
            accessList: Object.assign({}, k0),
            data: {
                format: "bytes"
            },
            input: {
                format: "bytes"
            },
            nonce: {
                format: "uint"
            },
            chain: Object.assign({}, ww),
            hardfork: Object.assign({}, bw),
            chainId: {
                format: "uint"
            },
            networkId: {
                format: "uint"
            },
            common: {
                type: "object",
                properties: {
                    customChain: Object.assign({}, Eq),
                    baseChain: Object.assign({}, ww),
                    hardfork: Object.assign({}, bw)
                }
            },
            gasLimit: {
                format: "uint"
            },
            v: {
                format: "uint"
            },
            r: {
                format: "bytes32"
            },
            s: {
                format: "bytes32"
            }
        }
    }
      , Tq = {
        type: "object",
        properties: Object.assign(Object.assign({}, Sq.properties), {
            blockHash: {
                format: "bytes32"
            },
            blockNumber: {
                format: "uint"
            },
            hash: {
                format: "bytes32"
            },
            transactionIndex: {
                format: "uint"
            },
            from: {
                format: "address"
            },
            to: {
                oneOf: [{
                    format: "address"
                }, {
                    type: "null"
                }]
            },
            value: {
                format: "uint"
            },
            gas: {
                format: "uint"
            },
            gasPrice: {
                format: "uint"
            },
            effectiveGasPrice: {
                format: "uint"
            },
            type: {
                format: "uint"
            },
            maxFeePerGas: {
                format: "uint"
            },
            maxPriorityFeePerGas: {
                format: "uint"
            },
            accessList: Object.assign({}, k0),
            data: {
                format: "bytes"
            },
            input: {
                format: "bytes"
            },
            nonce: {
                format: "uint"
            },
            gasLimit: {
                format: "uint"
            },
            v: {
                format: "uint"
            },
            r: {
                format: "bytes32"
            },
            s: {
                format: "bytes32"
            }
        })
    }
      , XE = {
        type: "object",
        properties: {
            index: {
                format: "uint"
            },
            validatorIndex: {
                format: "uint"
            },
            address: {
                format: "address"
            },
            amount: {
                format: "uint"
            }
        }
    };
    Object.assign({}, Tq),
    Object.assign({}, XE);
    Object.assign({}, XE);
    const Aq = {
        type: "object",
        properties: {
            removed: {
                format: "bool"
            },
            logIndex: {
                format: "uint"
            },
            transactionIndex: {
                format: "uint"
            },
            transactionHash: {
                format: "bytes32"
            },
            blockHash: {
                format: "bytes32"
            },
            blockNumber: {
                format: "uint"
            },
            address: {
                format: "address"
            },
            data: {
                format: "bytes"
            },
            topics: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            }
        }
    };
    Object.assign({}, Aq);
    const Oq = {
        type: "object",
        properties: {
            key: {
                format: "bytes32"
            },
            value: {
                format: "uint"
            },
            proof: {
                type: "array",
                items: {
                    format: "bytes32"
                }
            }
        }
    };
    Object.assign({}, Oq);
    Pu.HEX,
    Ru.NUMBER;
    Array.from({
        length: 256
    }, (e, t) => t.toString(16).padStart(2, "0"));
    var Xr;
    (function(e) {
        e.HTTPS = "https",
        e.WebSocket = "wss"
    }
    )(Xr || (Xr = {}));
    var Se;
    (function(e) {
        e.ETH_MAINNET = "eth_mainnet",
        e.ETH_SEPOLIA = "eth_sepolia",
        e.ETH_HOLESKY = "eth_holesky",
        e.POLYGON_MAINNET = "polygon_mainnet",
        e.POLYGON_AMOY = "polygon_amoy",
        e.AVALANCHE_C_MAINNET = "avalanche_c_mainnet",
        e.AVALANCHE_P_MAINNET = "avalanche_p_mainnet",
        e.AVALANCHE_X_MAINNET = "avalanche_x_mainnet",
        e.ARBITRUM_MAINNET = "arbitrum_mainnet",
        e.ARBITRUM_SEPOLIA = "arbitrum_sepolia",
        e.BASE_MAINNET = "base_mainnet",
        e.BASE_SEPOLIA = "base_sepolia",
        e.OPTIMISM_MAINNET = "optimism_mainnet",
        e.OPTIMISM_SEPOLIA = "optimism_sepolia",
        e.FANTOM_MAINNET = "fantom_mainnet",
        e.FANTOM_TESTNET = "fantom_testnet",
        e.DYMENSION_MAINNET = "dymension_mainnet",
        e.DYMENSION_TESTNET = "dymension_testnet",
        e.BNB_MAINNET = "bnb_mainnet",
        e.BNB_TESTNET = "bnb_testnet",
        e.BSC_MAINNET = "bsc_mainnet",
        e.BSC_TESTNET = "bsc_testnet",
        e.ARBITRUM_ONE = "arbitrum_one",
        e.ARBITRUM_NOVA = "arbitrum_nova",
        e.AVALANCHE_FUJI_C = "avalanche_fuji_c",
        e.AVALANCHE_FUJI_P = "avalanche_fuji_p",
        e.AVALANCHE_FUJI_X = "avalanche_fuji_x",
        e.BLAST_MAINNET = "blast_mainnet",
        e.OPBNB_MAINNET = "opbnb_mainnet",
        e.OPBNB_TESTNET = "opbnb_testnet",
        e.GNOSIS_MAINNET = "gnosis_mainnet",
        e.GNOSIS_CHIADO = "gnosis_chiado",
        e.PULSECHAIN_MAINNET = "pulsechain_mainnet",
        e.PULSECHAIN_TESTNET = "pulsechain_testnet",
        e.KAVA_MAINNET = "kava_mainnet",
        e.CRONOS_MAINNET = "cronos_mainnet",
        e.MANTLE_MAINNET = "mantle_mainnet",
        e.CHILIZ_MAINNET = "chiliz_mainnet",
        e.CHILIZ_SPICY = "chiliz_spicy",
        e.MOONBEAM_MAINNET = "moonbeam_mainnet",
        e.TAIKO_MAINNET = "taiko_mainnet",
        e.TAIKO_HEKLA = "taiko_hekla",
        e.LINEA_MAINNET = "linea_mainnet",
        e.LINEA_SEPOLIA = "linea_sepolia",
        e.BAHAMUT_MAINNET = "bahamut_mainnet",
        e.SCROLL_MAINNET = "scroll_mainnet",
        e.SCROLL_SEPOLIA = "scroll_sepolia",
        e.TRON_MAINNET = "tron_mainnet",
        e.SYSCOIN_MAINNET = "syscoin_mainnet",
        e.SYSCOIN_TANENBAUM = "syscoin_tanenbaum",
        e.MOONRIVER_MAINNET = "moonriver_mainnet",
        e.HAQQ_MAINNET = "haqq_mainnet",
        e.EVMOS_MAINNET = "evmos_mainnet",
        e.EVMOS_TESTNET = "evmos_testnet",
        e.BERACHAIN_TESTNET = "berachain_testnet"
    }
    )(Se || (Se = {}));
    const Iq = 1300;
    class Nq extends Sn {
        constructor(t) {
            super("You've reach the rate limit of free RPC calls from our Partner Quick Nodes. There are two options you can either create a paid Quick Nodes account and get 20% off for 2 months using WEB3JS referral code, or use Free public RPC endpoint.", t),
            this.code = Iq
        }
    }
    const xq = 1301;
    class Ew extends Sn {
        constructor(t) {
            super(`Invalid provider config options given for ${t}`),
            this.code = xq
        }
    }
    var $q = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    };
    class QE extends CE {
        constructor(t, n, r, s, o) {
            if (super(),
            o !== void 0 && n === Xr.HTTPS && !("providerOptions"in o))
                throw new Ew("HTTP Provider");
            if (o !== void 0 && n === Xr.WebSocket && !("socketOptions"in o || "reconnectOptions"in o))
                throw new Ew("Websocket Provider");
            this.transport = n,
            n === Xr.HTTPS ? this.provider = new O0(this.getRPCURL(t, n, r, s),o) : n === Xr.WebSocket && (this.provider = new O3(this.getRPCURL(t, n, r, s),o?.socketOptions,o?.reconnectOptions))
        }
        request(t, n) {
            return $q(this, void 0, void 0, function*() {
                return this.transport === Xr.HTTPS ? yield this.provider.request(t, n) : this.provider.request(t)
            })
        }
        getStatus() {
            return this.provider.getStatus()
        }
        supportsSubscriptions() {
            return this.provider.supportsSubscriptions()
        }
        once(t, n) {
            var r;
            !((r = this.provider) === null || r === void 0) && r.once && this.provider.once(t, n)
        }
        removeAllListeners(t) {
            var n;
            !((n = this.provider) === null || n === void 0) && n.removeAllListeners && this.provider.removeAllListeners(t)
        }
        connect() {
            var t;
            !((t = this.provider) === null || t === void 0) && t.connect && this.provider.connect()
        }
        disconnect(t, n) {
            var r;
            !((r = this.provider) === null || r === void 0) && r.disconnect && this.provider.disconnect(t, n)
        }
        reset() {
            var t;
            !((t = this.provider) === null || t === void 0) && t.reset && this.provider.reset()
        }
        on(t, n) {
            this.provider && this.provider.on(t, n)
        }
        removeListener(t, n) {
            this.provider && this.provider.removeListener(t, n)
        }
    }
    var Rq = function(e, t, n, r) {
        function s(o) {
            return o instanceof n ? o : new n(function(c) {
                c(o)
            }
            )
        }
        return new (n || (n = Promise))(function(o, c) {
            function l(h) {
                try {
                    d(r.next(h))
                } catch (y) {
                    c(y)
                }
            }
            function f(h) {
                try {
                    d(r.throw(h))
                } catch (y) {
                    c(y)
                }
            }
            function d(h) {
                h.done ? o(h.value) : s(h.value).then(l, f)
            }
            d((r = r.apply(e, t || [])).next())
        }
        )
    };
    const nn = e => e !== void 0 && e.trim().length > 0;
    class Pq extends QE {
        constructor(t=Se.ETH_MAINNET, n=Xr.HTTPS, r="", s="", o) {
            super(t, n, r, s, o)
        }
        request(t, n) {
            const r = Object.create(null, {
                request: {
                    get: () => super.request
                }
            });
            return Rq(this, void 0, void 0, function*() {
                try {
                    return yield r.request.call(this, t, n)
                } catch (s) {
                    throw s instanceof y0 && s.statusCode === 429 ? new Nq(s) : s
                }
            })
        }
        getRPCURL(t, n, r, s) {
            let o = ""
              , c = "";
            switch (t) {
            case Se.ETH_MAINNET:
                o = nn(s) ? s : "powerful-holy-bush.quiknode.pro",
                c = nn(r) ? r : "3240624a343867035925ff7561eb60dfdba2a668";
                break;
            case Se.ETH_SEPOLIA:
                o = nn(s) ? s : "dimensional-fabled-glitter.ethereum-sepolia.quiknode.pro",
                c = nn(r) ? r : "382a3b5a4b938f2d6e8686c19af4b22921fde2cd";
                break;
            case Se.ETH_HOLESKY:
                o = nn(s) ? s : "yolo-morning-card.ethereum-holesky.quiknode.pro",
                c = nn(r) ? r : "481ebe70638c4dcf176af617a16d02ab866b9af9";
                break;
            case Se.ARBITRUM_MAINNET:
                o = nn(s) ? s : "autumn-divine-dinghy.arbitrum-mainnet.quiknode.pro",
                c = nn(r) ? r : "a5d7bfbf60b5ae9ce3628e53d69ef50d529e9a8c";
                break;
            case Se.ARBITRUM_SEPOLIA:
                o = nn(s) ? s : "few-patient-pond.arbitrum-sepolia.quiknode.pro",
                c = nn(r) ? r : "3be985450970628c860b959c65cd2642dcafe53c";
                break;
            case Se.BNB_MAINNET:
                o = nn(s) ? s : "purple-empty-reel.bsc.quiknode.pro",
                c = nn(r) ? r : "ebf6c532961e21f092ff2facce1ec4c89c540158";
                break;
            case Se.BNB_TESTNET:
                o = nn(s) ? s : "floral-rough-scion.bsc-testnet.quiknode.pro",
                c = nn(r) ? r : "5b297e5acff5f81f4c37ebf6f235f7299b6f9d28";
                break;
            case Se.POLYGON_MAINNET:
                o = nn(s) ? s : "small-chaotic-moon.matic.quiknode.pro",
                c = nn(r) ? r : "847569f8a017e84d985e10d0f44365d965a951f1";
                break;
            case Se.POLYGON_AMOY:
                o = nn(s) ? s : "prettiest-side-shape.matic-amoy.quiknode.pro",
                c = nn(r) ? r : "79a9476eea661d4f82de614db1d8a895b14b881c";
                break;
            default:
                throw new Error("Network info not avalible.")
            }
            return `${n}://${o}/${c}`
        }
    }
    const kq = e => e !== void 0 && e.trim().length > 0
      , Cq = [Se.DYMENSION_MAINNET, Se.DYMENSION_TESTNET, Se.KAVA_MAINNET, Se.CRONOS_MAINNET, Se.POLYGON_MAINNET];
    class ad extends QE {
        constructor(t=Se.ETH_MAINNET, n=Xr.HTTPS, r="", s) {
            super(t, n, "", r, s)
        }
        getRPCURL(t, n, r, s) {
            if (!ad.networkHostMap[t])
                throw new Error("Network info not avalible.");
            const o = `${ad.networkHostMap[t]}.publicnode.com`
              , c = kq(s) ? s : o;
            return Cq.includes(t) && n === Xr.WebSocket ? `${n}://${c}/websocket` : `${n}://${c}`
        }
    }
    ad.networkHostMap = {
        [Se.POLYGON_AMOY]: "polygon-amoy-bor-rpc",
        [Se.DYMENSION_MAINNET]: "dymension-evm-rpc",
        [Se.DYMENSION_TESTNET]: "dymension-testnet-evm-rpc",
        [Se.BLAST_MAINNET]: "blast-rpc",
        [Se.GNOSIS_MAINNET]: "gnosis-rpc",
        [Se.PULSECHAIN_MAINNET]: "pulsechain-rpc",
        [Se.PULSECHAIN_TESTNET]: "pulsechain-testnet-rpc",
        [Se.KAVA_MAINNET]: "kava-evm-rpc",
        [Se.CRONOS_MAINNET]: "cronos-evm-rpc",
        [Se.MANTLE_MAINNET]: "mantle-rpc",
        [Se.TAIKO_MAINNET]: "taiko-rpc",
        [Se.TAIKO_HEKLA]: "taiko-hekla-rpc",
        [Se.LINEA_MAINNET]: "linea-rpc",
        [Se.LINEA_SEPOLIA]: "linea-sepolia-rpc",
        [Se.SCROLL_MAINNET]: "scroll-rpc",
        [Se.SCROLL_SEPOLIA]: "scroll-sepolia-rpc",
        [Se.SYSCOIN_MAINNET]: "syscoin-evm-rpc",
        [Se.SYSCOIN_TANENBAUM]: "syscoin-tanenbaum-evm-rpc",
        [Se.HAQQ_MAINNET]: "haqq-evm-rpc",
        [Se.EVMOS_MAINNET]: "evmos-evm-rpc",
        [Se.EVMOS_TESTNET]: "evmos-testnet-evm-rpc",
        [Se.BERACHAIN_TESTNET]: "berachain-testnet-evm-rpc",
        [Se.ETH_MAINNET]: "ethereum-rpc",
        [Se.ETH_SEPOLIA]: "ethereum-sepolia-rpc",
        [Se.ETH_HOLESKY]: "ethereum-holesky-rpc",
        [Se.BSC_MAINNET]: "bsc-rpc",
        [Se.BSC_TESTNET]: "bsc-testnet-rpc",
        [Se.POLYGON_MAINNET]: "polygon-bor-rpc",
        [Se.BASE_MAINNET]: "base-rpc",
        [Se.BASE_SEPOLIA]: "base-sepolia-rpc",
        [Se.ARBITRUM_ONE]: "arbitrum-one-rpc",
        [Se.ARBITRUM_NOVA]: "arbitrum-nova-rpc",
        [Se.ARBITRUM_SEPOLIA]: "arbitrum-sepolia-rpc",
        [Se.AVALANCHE_C_MAINNET]: "avalanche-c-chain-rpc",
        [Se.AVALANCHE_P_MAINNET]: "avalanche-p-chain-rpc",
        [Se.AVALANCHE_X_MAINNET]: "avalanche-x-chain-rpc",
        [Se.AVALANCHE_FUJI_C]: "avalanche-fuji-c-chain-rpc",
        [Se.AVALANCHE_FUJI_P]: "avalanche-fuji-p-chain-rpc",
        [Se.AVALANCHE_FUJI_X]: "avalanche-fuji-x-chain-rpc",
        [Se.OPTIMISM_MAINNET]: "optimism-rpc",
        [Se.OPTIMISM_SEPOLIA]: "optimism-sepolia-rpc",
        [Se.FANTOM_MAINNET]: "fantom-rpc",
        [Se.FANTOM_TESTNET]: "fantom-testnet-rpc",
        [Se.OPBNB_MAINNET]: "opbnb-rpc",
        [Se.OPBNB_TESTNET]: "opbnb-testnet-rpc",
        [Se.GNOSIS_CHIADO]: "gnosis-chiado-rpc",
        [Se.CHILIZ_MAINNET]: "chiliz-rpc",
        [Se.CHILIZ_SPICY]: "chiliz-spicy-rpc",
        [Se.MOONBEAM_MAINNET]: "moonbeam-rpc",
        [Se.BAHAMUT_MAINNET]: "bahamut-rpc",
        [Se.TRON_MAINNET]: "tron-evm-rpc",
        [Se.MOONRIVER_MAINNET]: "moonriver-rpc"
    };
    new Pq;
    var Sw;
    (function(e) {
        e.eip6963announceProvider = "eip6963:announceProvider",
        e.eip6963requestProvider = "eip6963:requestProvider"
    }
    )(Sw || (Sw = {}));
    const Cc = "chains";
    var Tw;
    (function(e) {
        e.notFound = "CHAIN_NOT_FOUND",
        e.notDeletable = "CHAIN_NOT_DELETABLE"
    }
    )(Tw || (Tw = {}));
    var co;
    (function(e) {
        e[e.v1Create = `v1/${Cc}`] = "v1Create",
        e[e.v1Delete = `v1/${Cc}/:chainId`] = "v1Delete",
        e[e.v1Read = `v1/${Cc}/:chainId`] = "v1Read",
        e[e.v1Update = `v1/${Cc}/:chainId`] = "v1Update",
        e[e.v1Search = `v1/${Cc}`] = "v1Search"
    }
    )(co || (co = {}));
    function Mq(e) {
        return {
            search: t => e.request({
                url: co.v1Search,
                method: "GET",
                responseType: "json",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: co.v1Search,
                method: "GET",
                responseType: "json",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: co.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            ),
            readOne: t => e.request({
                url: co.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const {data: r} = n.data;
                if (!r.length)
                    throw Error("Not found");
                return r[0]
            }
            )
        }
    }
    const Mc = "vault-blocks"
      , Lc = "vault-epochs";
    var ms;
    (function(e) {
        e[e.v1Create = `v1/${Lc}`] = "v1Create",
        e[e.v1Delete = `v1/${Lc}/:vaultEpochId`] = "v1Delete",
        e[e.v1Read = `v1/${Lc}/:vaultEpochId`] = "v1Read",
        e[e.v1Update = `v1/${Lc}/:vaultEpochId`] = "v1Update",
        e[e.v1Search = `v1/${Lc}`] = "v1Search"
    }
    )(ms || (ms = {}));
    class Lq extends Cu {
        create(t) {
            return this._create(ms.v1Create, t)
        }
        search(t) {
            return this._search(ms.v1Search, t)
        }
        searchAll(t) {
            return this._searchAll(ms.v1Search, t)
        }
        list(t) {
            return this._list(ms.v1Search, t)
        }
        listAll(t) {
            return this._listAll(ms.v1Search, t)
        }
        findOne(t) {
            return this._findOne(ms.v1Search, t)
        }
        constructor(t) {
            super(t)
        }
    }
    const Dc = "tokens";
    var Aw;
    (function(e) {
        e.notDeletable = "TOKEN_NOT_DELETABLE",
        e.dataNotValid = "TOKEN_DATA_NOT_VALID",
        e.addressMalformed = "TOKEN_ADDRESS_MALFORMED"
    }
    )(Aw || (Aw = {}));
    var Js;
    (function(e) {
        e[e.v1Create = `v1/${Dc}`] = "v1Create",
        e[e.v1Delete = `v1/${Dc}/:tokenId`] = "v1Delete",
        e[e.v1Read = `v1/${Dc}/:tokenId`] = "v1Read",
        e[e.v1Update = `v1/${Dc}/:tokenId`] = "v1Update",
        e[e.v1Search = `v1/${Dc}`] = "v1Search"
    }
    )(Js || (Js = {}));
    function Dq(e) {
        return {
            create: t => e.request({
                url: Js.v1Create,
                method: "POST",
                data: un(t)
            }).then(n => n.data),
            search: t => e.request({
                url: Js.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: Js.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: Js.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            ),
            readOne: t => e.request({
                url: Js.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const {data: r} = n.data;
                if (!r.length)
                    throw Error("Not found");
                return r[0]
            }
            )
        }
    }
    var Ow;
    (function(e) {
        e.notFound = "VAULT_BLOCK_NOT_FOUND",
        e.alreadyExists = "VAULT_BLOCK_ALREADY_EXISTS",
        e.wrontContractType = "VAULT_BLOCK_WRONG_CONTRACT_TYPE"
    }
    )(Ow || (Ow = {}));
    var Iw;
    (function(e) {
        e.tokenNotFound = "VAULT_BLOCK_REWARD_PROGRAM_TOKEN_NOT_FOUND"
    }
    )(Iw || (Iw = {}));
    var Nw;
    (function(e) {
        e.notMatching = "VAULT_BLOCK_REQUEST_NOT_MATCHING",
        e.notClaimable = "VAULT_BLOCK_REQUEST_NOT_CLAIMABLE",
        e.epochNumber = "VAULT_BLOCK_REQUEST_INVALID_EPOCH_NUMBER",
        e.wrongStatus = "VAULT_BLOCK_REQUEST_WRONG_STATUS",
        e.wrongType = "VAULT_BLOCK_REQUEST_WRONG_TYPE"
    }
    )(Nw || (Nw = {}));
    var Xs;
    (function(e) {
        e[e.v1Create = `v1/${Mc}`] = "v1Create",
        e[e.v1Delete = `v1/${Mc}/:vaultBlockId`] = "v1Delete",
        e[e.v1Read = `v1/${Mc}/:vaultBlockId`] = "v1Read",
        e[e.v1Update = `v1/${Mc}/:vaultBlockId`] = "v1Update",
        e[e.v1Search = `v1/${Mc}`] = "v1Search"
    }
    )(Xs || (Xs = {}));
    function Uq(e) {
        return {
            create: t => e.request({
                url: Xs.v1Create,
                method: "POST",
                data: un(t)
            }).then(n => n.data),
            search: t => e.request({
                url: Xs.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: Xs.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: Xs.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            ),
            readOne: t => e.request({
                url: Xs.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const {data: r} = n.data;
                if (!r.length)
                    throw Error("Not found");
                return r[0]
            }
            )
        }
    }
    const qt = "vaults";
    var xw;
    (function(e) {
        e.collision = "VAULT_COLLISION",
        e.notFound = "VAULT_NOT_FOUND",
        e.notDeletable = "VAULT_NOT_DELETABLE",
        e.blockNotValid = "VAULT_BLOCK_NOT_VALID",
        e.walletRequired = "VAULT_WALLET_REQUIRED",
        e.integrationError = "VAULT_INTEGRATION_ERROR",
        e.rewardProgramNotFound = "VAULT_REWARD_PROGRAM_NOT_FOUND",
        e.paretoDollarWalletNotFound = "VAULT_PARETO_DOLLAR_WALLET_NOT_FOUND"
    }
    )(xw || (xw = {}));
    var $w;
    (function(e) {
        e.idleEvents = "idle.vault.*",
        e.idleSync = "idle.vault.sync",
        e.idleCreated = "idle.vault.created",
        e.idleUpdate = "idle.vault.update",
        e.idleTransfered = "idle.vault.transfered",
        e.idlePerformed = "idle.vault.performed",
        e.bcEvents = "bc.vault.*",
        e.bcTransfer = "bc.vault.transfer"
    }
    )($w || ($w = {}));
    var Yt;
    (function(e) {
        e[e.v1Create = `v1/${qt}`] = "v1Create",
        e[e.v1Delete = `v1/${qt}/:vaultId`] = "v1Delete",
        e[e.v1Read = `v1/${qt}/:vaultId`] = "v1Read",
        e[e.v1Update = `v1/${qt}/:vaultId`] = "v1Update",
        e[e.v1Search = `v1/${qt}`] = "v1Search",
        e[e.v1Usp = `v1/${qt}/:vaultId/usp`] = "v1Usp",
        e[e.v1Sync = `v1/${qt}/:vaultId/sync`] = "v1Sync",
        e[e.v1Mint = `v1/${qt}/:vaultId/mint`] = "v1Mint",
        e[e.v1Rewards = `v1/${qt}/:vaultId/rewards`] = "v1Rewards",
        e[e.v1Block = `v1/${qt}/:vaultId/block`] = "v1Block",
        e[e.v1Epoch = `v1/${qt}/:vaultId/epoch`] = "v1Epoch",
        e[e.v1Redeem = `v1/${qt}/:vaultId/redeem`] = "v1Redeem",
        e[e.v1Transfer = `v1/${qt}/:vaultId/transfer`] = "v1Transfer",
        e[e.v1Perform = `v1/${qt}/:vaultId/perform`] = "v1Perform",
        e[e.v1Cure = `v1/${qt}/:vaultId/cure`] = "v1Cure",
        e[e.v1Performances = `v1/${qt}/performances`] = "v1Performances",
        e[e.v1Position = `v1/${qt}/:vaultId/position`] = "v1Position",
        e[e.v1SyncBlock = `v1/${qt}/:vaultId/sync-block`] = "v1SyncBlock",
        e[e.v1Integrations = `v1/${qt}/:vaultId/integrations`] = "v1Integrations",
        e[e.v1PerformBlocks = `v1/${qt}/:vaultId/perform-blocks`] = "v1PerformBlocks",
        e[e.v1PerformWallets = `v1/${qt}/:vaultId/perform-wallets`] = "v1PerformWallets"
    }
    )(Yt || (Yt = {}));
    function Bq(e) {
        return {
            create: t => e.request({
                url: Yt.v1Create,
                method: "POST",
                data: un(t)
            }).then(n => n.data),
            search: t => e.request({
                url: Yt.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: Yt.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: Yt.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            ),
            readOne: t => e.request({
                url: Yt.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const {data: r} = n.data;
                if (!r.length)
                    throw Error("Not found");
                return r[0]
            }
            ),
            position: (t, n) => e.request({
                url: Yt.v1Position.replace(":vaultId", t),
                method: "GET",
                params: new URLSearchParams(ze(n))
            }).then(r => r.data),
            performances: t => e.request({
                url: Yt.v1Performances,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => n.data),
            integrations: (t, n) => e.request({
                url: Yt.v1Integrations.replace(":vaultId", t),
                method: "GET",
                params: new URLSearchParams(ze(n))
            }).then(r => r.data),
            mint: (t, n) => e.request({
                url: Yt.v1Mint.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            redeem: (t, n) => e.request({
                url: Yt.v1Redeem.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            transfer: (t, n) => e.request({
                url: Yt.v1Transfer.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            rewards: (t, n) => e.request({
                url: Yt.v1Rewards.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            usp: (t, n) => e.request({
                url: Yt.v1Usp.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            epoch: (t, n) => e.request({
                url: Yt.v1Epoch.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            sync: (t, n) => e.request({
                url: Yt.v1Sync.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            syncBlock: (t, n) => e.request({
                url: Yt.v1SyncBlock.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            block: (t, n) => e.request({
                url: Yt.v1Block.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            perform: (t, n) => e.request({
                url: Yt.v1Perform.replace(":vaultId", t),
                method: "POST",
                data: un(n)
            }).then(r => r.data),
            cure: t => e.request({
                url: Yt.v1Cure.replace(":vaultId", t),
                method: "POST"
            })
        }
    }
    var Rw;
    (function(e) {
        e.alreadyExists = "WALLET_BLOCK_ALREADY_EXISTS"
    }
    )(Rw || (Rw = {}));
    var Pw;
    (function(e) {
        e[e.v1Create = `v1/${kc}`] = "v1Create",
        e[e.v1Delete = `v1/${kc}/:walletBlockId`] = "v1Delete",
        e[e.v1Read = `v1/${kc}/:walletBlockId`] = "v1Read",
        e[e.v1Update = `v1/${kc}/:walletBlockId`] = "v1Update",
        e[e.v1Search = `v1/${kc}`] = "v1Search"
    }
    )(Pw || (Pw = {}));
    const Ws = "signatures";
    var kw;
    (function(e) {
        e.alreadyExists = "SIGNATURE_ALREADY_EXISTS",
        e.notDeletable = "SIGNATURE_NOT_DELETABLE",
        e.notExists = "SIGNATURE_NOT_EXISTS",
        e.verificationFailed = "SIGNATURE_VERIFICATION_FAILED"
    }
    )(kw || (kw = {}));
    var Ir;
    (function(e) {
        e[e.v1Create = `v1/${Ws}`] = "v1Create",
        e[e.v1Check = `v1/${Ws}/:signatureId/check`] = "v1Check",
        e[e.v1Sign = `v1/${Ws}/:signatureId/sign`] = "v1Sign",
        e[e.v1Delete = `v1/${Ws}/:signatureId`] = "v1Delete",
        e[e.v1Read = `v1/${Ws}/:signatureId`] = "v1Read",
        e[e.v1Update = `v1/${Ws}/:signatureId`] = "v1Update",
        e[e.v1Search = `v1/${Ws}`] = "v1Search"
    }
    )(Ir || (Ir = {}));
    class Fq extends Cu {
        create(t) {
            return this._create(Ir.v1Create, t)
        }
        search(t) {
            return this._search(Ir.v1Search, t)
        }
        searchAll(t) {
            return this._searchAll(Ir.v1Search, t)
        }
        list(t) {
            return this._list(Ir.v1Search, t)
        }
        listAll(t) {
            return this._listAll(Ir.v1Search, t)
        }
        findOne(t) {
            return this._findOne(Ir.v1Search, t)
        }
        readOne(t) {
            return this._readOne(Ir.v1Read, t)
        }
        check(t, n) {
            return this.axios.request({
                url: Ir.v1Check.replace(":signatureId", t),
                method: "GET",
                responseType: "json",
                params: new URLSearchParams(ze(n))
            }).then(r => r.data)
        }
        sign(t, n) {
            return this.axios.request({
                url: Ir.v1Sign.replace(":signatureId", t),
                method: "POST",
                responseType: "json",
                data: un(n)
            }).then(r => r.data)
        }
        constructor(t) {
            super(t)
        }
    }
    const eo = "users";
    var Cw;
    (function(e) {
        e.userCollision = "USER_COLLISION",
        e.notFound = "USER_NOT_FOUND",
        e.notDeletable = "USER_NOT_DELETABLE",
        e.samePassword = "USER_SAME_PASSWORD",
        e.wrongPassword = "USER_WRONG_PASSWORD"
    }
    )(Cw || (Cw = {}));
    var iu;
    (function(e) {
        e[e.v1Create = `v1/${eo}`] = "v1Create",
        e[e.v1Delete = `v1/${eo}/:userId`] = "v1Delete",
        e[e.v1Read = `v1/${eo}/:userId`] = "v1Read",
        e[e.v1Update = `v1/${eo}/:userId`] = "v1Update",
        e[e.v1Search = `v1/${eo}`] = "v1Search",
        e[e.v1ChangePassword = `v1/${eo}/:userId/change-password`] = "v1ChangePassword"
    }
    )(iu || (iu = {}));
    class jq extends Cu {
        search(t) {
            return this._search(iu.v1Search, t)
        }
        list(t) {
            return this._list(iu.v1Search, t)
        }
        findOne(t) {
            return this._findOne(iu.v1Search, t)
        }
        constructor(t) {
            super(t)
        }
    }
    const Uc = "operators";
    var Mw;
    (function(e) {
        e.notFound = "OPERATOR_NOT_FOUND",
        e.notDeletable = "OPERATOR_NOT_DELETABLE"
    }
    )(Mw || (Mw = {}));
    var su;
    (function(e) {
        e[e.v1Create = `v1/${Uc}`] = "v1Create",
        e[e.v1Delete = `v1/${Uc}/:operatorId`] = "v1Delete",
        e[e.v1Read = `v1/${Uc}/:operatorId`] = "v1Read",
        e[e.v1Update = `v1/${Uc}/:operatorId`] = "v1Update",
        e[e.v1Search = `v1/${Uc}`] = "v1Search"
    }
    )(su || (su = {}));
    function qq(e) {
        return {
            search: t => e.request({
                url: su.v1Search,
                method: "GET",
                responseType: "json",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: su.v1Search,
                method: "GET",
                responseType: "json",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: su.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            )
        }
    }
    const Bc = "vault-categories";
    var Lw;
    (function(e) {
        e.collision = "VAULT_CATEGORY_COLLISION",
        e.notFound = "VAULT_CATEGORY_NOT_FOUND",
        e.notDeletable = "VAULT_CATEGORY_NOT_DELETABLE",
        e.alreadyExists = "VAULT_CATEGORY_ALREADY_EXISTS"
    }
    )(Lw || (Lw = {}));
    var uo;
    (function(e) {
        e[e.v1Create = `v1/${Bc}`] = "v1Create",
        e[e.v1Delete = `v1/${Bc}/:typeId`] = "v1Delete",
        e[e.v1Read = `v1/${Bc}/:typeId`] = "v1Read",
        e[e.v1Update = `v1/${Bc}/:typeId`] = "v1Update",
        e[e.v1Search = `v1/${Bc}`] = "v1Search"
    }
    )(uo || (uo = {}));
    function Hq(e) {
        return {
            create: t => e.request({
                url: uo.v1Create,
                method: "POST",
                data: un(t)
            }).then(n => n.data),
            search: t => e.request({
                url: uo.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: uo.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: uo.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            )
        }
    }
    const Yq = "vault-latest-blocks";
    var au;
    (function(e) {
        e[e.v1Search = `v1/${Yq}`] = "v1Search"
    }
    )(au || (au = {}));
    function Vq(e) {
        return {
            search: t => e.request({
                url: au.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: au.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            readOne: t => e.request({
                url: au.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const {data: r} = n.data;
                if (!r.length)
                    throw Error("Not found");
                return r[0]
            }
            )
        }
    }
    const Fc = "vault-types";
    var Dw;
    (function(e) {
        e.collision = "VAULT_TYPE_COLLISION",
        e.notFound = "VAULT_TYPE_NOT_FOUND",
        e.notDeletable = "VAULT_TYPE_NOT_DELETABLE",
        e.alreadyExists = "VAULT_TYPE_ALREADY_EXISTS"
    }
    )(Dw || (Dw = {}));
    var lo;
    (function(e) {
        e[e.v1Create = `v1/${Fc}`] = "v1Create",
        e[e.v1Delete = `v1/${Fc}/:typeId`] = "v1Delete",
        e[e.v1Read = `v1/${Fc}/:typeId`] = "v1Read",
        e[e.v1Update = `v1/${Fc}/:typeId`] = "v1Update",
        e[e.v1Search = `v1/${Fc}`] = "v1Search"
    }
    )(lo || (lo = {}));
    function Wq(e) {
        return {
            create: t => e.request({
                url: lo.v1Create,
                method: "POST",
                data: un(t)
            }).then(n => n.data),
            search: t => e.request({
                url: lo.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: lo.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: lo.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            )
        }
    }
    const zq = "wallet-latest-blocks";
    var ou;
    (function(e) {
        e[e.v1Search = `v1/${zq}`] = "v1Search"
    }
    )(ou || (ou = {}));
    function Gq(e) {
        return {
            search: t => e.request({
                url: ou.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: ou.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: ou.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            )
        }
    }
    const Ar = "wallets";
    var Uw;
    (function(e) {
        e.vaultsMissing = "VAULT_IDS_MISSING",
        e.alreadyExists = "WALLET_ALREADY_EXISTS",
        e.notDeletable = "WALLET_NOT_DELETABLE",
        e.malformed = "WALLET_ADDRESS_MALFORMED",
        e.notFound = "WALLET_NOT_FOUND"
    }
    )(Uw || (Uw = {}));
    var Nr;
    (function(e) {
        e[e.v1Create = `v1/${Ar}`] = "v1Create",
        e[e.v1Delete = `v1/${Ar}/:walletId`] = "v1Delete",
        e[e.v1Ensure = `v1/${Ar}/ensure`] = "v1Ensure",
        e[e.v1Perform = `v1/${Ar}/:walletId/perform`] = "v1Perform",
        e[e.v1Portfolio = `v1/${Ar}/:walletId/portfolio`] = "v1Portfolio",
        e[e.v1Read = `v1/${Ar}/:walletId`] = "v1Read",
        e[e.v1Referral = `v1/${Ar}/:walletId/referral`] = "v1Referral",
        e[e.v1Search = `v1/${Ar}`] = "v1Search",
        e[e.v1Update = `v1/${Ar}/:walletId`] = "v1Update",
        e[e.v1User = `v1/${Ar}/:walletId/user`] = "v1User",
        e[e.v1Vaults = `v1/${Ar}/:walletId/vaults`] = "v1Vaults"
    }
    )(Nr || (Nr = {}));
    var Bw;
    (function(e) {
        e.idleEvents = "idle.wallet.*",
        e.idlePerform = "idle.wallet.perform"
    }
    )(Bw || (Bw = {}));
    function Zq(e) {
        return {
            search: t => e.request({
                url: Nr.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data),
            list: t => e.request({
                url: Nr.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => n.data.data),
            findOne: t => e.request({
                url: Nr.v1Search,
                method: "GET",
                params: t ? new URLSearchParams(ze(t)) : void 0
            }).then(n => {
                const r = n.data;
                return r.data ? r.data[0] : void 0
            }
            ),
            readOne: t => e.request({
                url: Nr.v1Search,
                method: "GET",
                params: new URLSearchParams(ze(t))
            }).then(n => {
                const {data: r} = n.data;
                if (!r.length)
                    throw Error("Not found");
                return r[0]
            }
            ),
            portfolio: (t, n) => e.request({
                url: Nr.v1Portfolio.replace(":walletId", t),
                method: "GET",
                params: new URLSearchParams(ze(n))
            }).then(r => r.data),
            vaults: (t, n) => e.request({
                url: TB(Nr.v1Vaults, {
                    ":walletId": t
                }),
                method: "GET",
                params: n ? new URLSearchParams(ze(n)) : void 0
            }).then(r => r.data),
            ensure: t => e.request({
                url: Nr.v1Ensure,
                method: "POST",
                data: {
                    address: t
                }
            }).then(n => n.data),
            user: (t, n) => e.request({
                url: Nr.v1User.replace(":walletId", t),
                method: "POST",
                data: n
            }).then(r => r.data),
            referral: (t, n) => e.request({
                url: Nr.v1Referral.replace(":walletId", t),
                method: "POST",
                data: {
                    referral: n
                }
            }).then(r => r.data)
        }
    }
    class Kq {
        initAxios(t, n) {
            const r = {
                baseURL: `${t}`,
                headers: {
                    Authorization: `Bearer ${n}`,
                    "content-type": "application/json"
                }
            };
            return v3.create(r)
        }
        constructor(t, n) {
            this.axios = this.initAxios(t, n),
            this.campaigns = new w3(this.axios),
            this.chains = Mq(this.axios),
            this.operators = qq(this.axios),
            this.signatures = new Fq(this.axios),
            this.tokens = Dq(this.axios),
            this.transactions = new b3(this.axios),
            this.users = new jq(this.axios),
            this.vaultBlocks = Uq(this.axios),
            this.vaultCategories = Hq(this.axios),
            this.vaultEpochs = new Lq(this.axios),
            this.vaultLatestBlocks = Vq(this.axios),
            this.vaultTypes = Wq(this.axios),
            this.vaults = Bq(this.axios),
            this.walletLatestBlocks = Gq(this.axios),
            this.wallets = Zq(this.axios)
        }
    }
    const jc = "auth";
    var Fw;
    (function(e) {
        e.invalid = "INVALID_CREDENTIALS",
        e.conflict = "SESSION_CONFLICT",
        e.authUnexpected = "UNEXPECTED_AUTHORIZATION_HEADER",
        e.authUnsupported = "UNSUPPORTED_AUTHORIZATION_HEADER",
        e.notAuthenticated = "NOT_AUTHENTICATED",
        e.notAuthorized = "NOT_AUTHORIZED",
        e.userSamePassword = "USER_SAME_PASSWORD",
        e.userWrongPassword = "USER_WRONG_PASSWORD"
    }
    )(Fw || (Fw = {}));
    var jw;
    (function(e) {
        e[e.authenticate = `${jc}/authenticate`] = "authenticate",
        e[e.changePassword = `${jc}/change-password`] = "changePassword",
        e[e.logout = `${jc}/logout`] = "logout",
        e[e.resetPassword = `${jc}/reset-password`] = "resetPassword",
        e[e.signIn = `${jc}/sign-in`] = "signIn"
    }
    )(jw || (jw = {}));
    const qc = "token-blocks";
    var qw;
    (function(e) {
        e[e.v1Create = `v1/${qc}`] = "v1Create",
        e[e.v1Delete = `v1/${qc}/:tokenBlockId`] = "v1Delete",
        e[e.v1Read = `v1/${qc}/:tokenBlockId`] = "v1Read",
        e[e.v1Update = `v1/${qc}/:tokenBlockId`] = "v1Update",
        e[e.v1Search = `v1/${qc}`] = "v1Search"
    }
    )(qw || (qw = {}));
    const Hc = "vault-performances";
    var Hw;
    (function(e) {
        e.alreadyExists = "VAULT_PERFORMANCE_ALREADY_EXISTS"
    }
    )(Hw || (Hw = {}));
    var Yw;
    (function(e) {
        e[e.v1Create = `v1/${Hc}`] = "v1Create",
        e[e.v1Delete = `v1/${Hc}/:vaultPerformanceId`] = "v1Delete",
        e[e.v1Read = `v1/${Hc}/:vaultPerformanceId`] = "v1Read",
        e[e.v1Update = `v1/${Hc}/:vaultPerformanceId`] = "v1Update",
        e[e.v1Search = `v1/${Hc}`] = "v1Search"
    }
    )(Yw || (Yw = {}));
    const Yc = "wallet-performances"
      , eS = {
        age: 0,
        earnings: {
            USD: "0",
            token: "0",
            percentage: 0,
            rewards: {
                USD: "0",
                percentage: 0
            }
        },
        realizedAPY: 0,
        rewardsRealizedAPY: 0,
        poolSharePercentage: 0,
        accruedRewards: [],
        collectedRewards: []
    };
    uu({
        deposits: {
            USD: "0"
        },
        redeemable: {
            USD: "0"
        },
        chains: [],
        tokens: [],
        vaultIds: [],
        operators: []
    }, eS);
    uu({
        tokenId: "",
        chainId: "",
        vaultId: "",
        vaultAddress: "",
        tokenAddress: "",
        avgPrice: "0",
        vaultPrice: "0",
        deposits: {
            USD: "0"
        },
        redeemable: {
            USD: "0"
        },
        balances: []
    }, eS);
    var Vw;
    (function(e) {
        e.alreadyExists = "WALLET_PERFORMANCE_ALREADY_EXISTS",
        e.rewardProgramNotFound = "WALLET_PERFORMANCE_REWARD_PROGRAM_NOT_FOUND"
    }
    )(Vw || (Vw = {}));
    var Ww;
    (function(e) {
        e[e.v1Create = `v1/${Yc}`] = "v1Create",
        e[e.v1Delete = `v1/${Yc}/:walletPerformanceId`] = "v1Delete",
        e[e.v1Read = `v1/${Yc}/:walletPerformanceId`] = "v1Read",
        e[e.v1Update = `v1/${Yc}/:walletPerformanceId`] = "v1Update",
        e[e.v1Search = `v1/${Yc}`] = "v1Search"
    }
    )(Ww || (Ww = {}));
    function tS() {
        return new Kq("https://api.pareto.credit/","eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2NjRkYTZjODM3NTIxMDBiNmM3NjI2YmEiLCJ0b2tlbklkIjoiNjgxMDk3ZDJiMmM0OGUzNWNjZGU1ODA1IiwiaWF0IjoxNzQ1OTE3OTA2fQ.djV5GZGVcmZ7uNhOpjwrE1OgrIZfT-kqEZp8HlLEjcc")
    }
    class od extends qi {
        tabsComponent;
        get _tabs() {
            return this.element.querySelectorAll(".tabs-list__item")
        }
        get _links() {
            return this.element.querySelectorAll(".tabs-links__item")
        }
        touchStartX = 0;
        touchEndX = 0;
        minSwipeDistance = 50;
        constructor(t) {
            super(t)
        }
        async loadVaults() {
            const t = tS()
              , [n,r] = await Promise.all([t.vaults.search({
                status: "READY",
                contractType: "CDO_EPOCH",
                fields: ["_id", "address", "visibility", "siblings"]
            }), t.vaults.performances({
                status: "READY"
            })])
              , s = document.querySelector('.hero-section__info-blocks-item[data-id="TVL"] p');
            if (s) {
                const f = {
                    maximumFractionDigits: 0,
                    currency: "USD",
                    style: "currency"
                }
                  , d = new Intl.NumberFormat("en-US",f);
                s.innerHTML = d.format(Number(r.TVL))
            }
            const o = document.querySelector('.hero-section__info-blocks-item[data-id="CE"] p');
            if (o) {
                const f = {
                    maximumFractionDigits: 0,
                    currency: "USD",
                    style: "currency"
                }
                  , d = new Intl.NumberFormat("en-US",f);
                o.innerHTML = d.format(Number(r.creditExtended))
            }
            const c = n.data.reduce( (f, d) => {
                const h = d.siblings ? d.siblings.map(y => y._id) : [];
                return [...f, ...h, d._id]
            }
            , [])
              , l = await t.vaultLatestBlocks.search({
                vaultId: c
            });
            n.data.filter(f => f.visibility === "PUBLIC").forEach(f => {
                const d = document.querySelector('.tabs-list__item[data-address="' + f.address + '"]')
                  , h = l.data.find($ => $.vaultId === f._id);
                if (!d || !h)
                    return !1;
                const y = d.querySelector('.info-block__item[data-id="APY"] .value h4');
                y && (y.innerHTML = Number(h.APYs.NET).toFixed(2) + "%");
                const I = d.querySelector('.info-block__item[data-id="TVL"] .value h4');
                if (I) {
                    const $ = {
                        maximumFractionDigits: 1,
                        notation: "compact",
                        currency: "USD",
                        style: "currency",
                        compactDisplay: "short"
                    }
                      , O = new Intl.NumberFormat("en-US",$);
                    let A = Number(h.TVL.withRequestsUSD || h.TVL.USD);
                    f.siblings?.forEach(N => {
                        const m = l.data.find(g => g.vaultId === N._id);
                        A += Number(m.TVL.withRequestsUSD || m.TVL.USD)
                    }
                    ),
                    I.innerHTML = O.format(A / 1e6)
                }
            }
            )
        }
        initializeHeroTabs() {
            new od({
                el: document.querySelector(".tabs")
            }).setup()
        }
        async doSetup() {
            this.tabsComponent = new qx({
                el: this.element,
                tabs: Array.from(this._tabs),
                links: Array.from(this._links),
                syncActivate: !0,
                clicksEnabled: !0,
                hoversEnabled: !0,
                onChanging: (t, n, r) => {
                    if (!t) {
                        En.set(n.tabs[0].element, {
                            opacity: 1,
                            zIndex: 1
                        });
                        return
                    }
                    if (Mn.isMobile) {
                        const o = En.timeline();
                        if (r > 0) {
                            o.set(".tabs-list__placeholder", {
                                opacity: 0,
                                zIndex: 0
                            }).fromTo(t.tabs[0].element, {
                                opacity: 1,
                                xPercent: 0
                            }, {
                                opacity: 0,
                                xPercent: -30,
                                zIndex: 0,
                                duration: .3
                            }).fromTo(n.tabs[0].element, {
                                opacity: 0,
                                xPercent: 30
                            }, {
                                opacity: 1,
                                xPercent: 0,
                                zIndex: 1,
                                duration: .3
                            }, "<").fromTo(".tabs-list__placeholder", {
                                zIndex: 0,
                                xPercent: 30
                            }, {
                                xPercent: 0,
                                zIndex: 1,
                                duration: .3
                            }, "<");
                            return
                        } else {
                            o.set(".tabs-list__placeholder", {
                                opacity: 0,
                                zIndex: 0
                            }).fromTo(t.tabs[0].element, {
                                opacity: 1,
                                xPercent: 0
                            }, {
                                opacity: 0,
                                xPercent: 30,
                                zIndex: 0,
                                duration: .3
                            }).fromTo(n.tabs[0].element, {
                                opacity: 0,
                                xPercent: -30
                            }, {
                                opacity: 1,
                                xPercent: 0,
                                zIndex: 1,
                                duration: .3
                            }, "<").fromTo(".tabs-list__placeholder", {
                                zIndex: 0,
                                xPercent: -30
                            }, {
                                xPercent: 0,
                                zIndex: 1,
                                duration: .3
                            }, "<");
                            return
                        }
                    }
                    En.timeline().fromTo(t.tabs[0].element, {
                        opacity: 1
                    }, {
                        opacity: 0,
                        zIndex: 0,
                        duration: Af(20),
                        ease: r$
                    }).fromTo(n.tabs[0].element, {
                        opacity: 0
                    }, {
                        opacity: 1,
                        zIndex: 1,
                        duration: Af(20),
                        ease: i$
                    }, "<+=0.1999")
                }
            }),
            await this.tabsComponent.setup(),
            this.tabsComponent.setActiveIndex(0),
            Mn.isMobile && this.initializeSwipeHandlers()
        }
        initializeSwipeHandlers() {
            const t = this.element;
            t.addEventListener("touchstart", n => {
                this.touchStartX = n.touches[0].clientX
            }
            , {
                passive: !0
            }),
            t.addEventListener("touchend", n => {
                this.touchEndX = n.changedTouches[0].clientX,
                this.handleSwipe()
            }
            , {
                passive: !0
            })
        }
        handleSwipe() {
            const t = this.touchEndX - this.touchStartX
              , n = this.tabsComponent.currentIndex
              , r = this._tabs.length;
            if (Math.abs(t) >= this.minSwipeDistance) {
                if (t > 0) {
                    const s = n === 0 ? r - 1 : n - 1;
                    this.tabsComponent.setActiveIndex(s)
                } else if (t < 0) {
                    const s = n === r - 1 ? 0 : n + 1;
                    this.tabsComponent.setActiveIndex(s)
                }
            }
        }
    }
    var ci = (e => (e.Hero = "homepage-hero",
    e.Solution = "homepage-solution",
    e.HowItWorks = "homepage-how-it-works",
    e.OurAdvantage = "homepage-our-advantage",
    e.Transparent = "homepage-transparent",
    e.Ecosystem = "homepage-ecosystem",
    e.GetInTouch = "homepage-get-in-touch",
    e.Community = "homepage-community",
    e.News = "homepage-news",
    e.OurProducts = "homepage-our-products",
    e))(ci || {});
    class zi extends qi {
        _sectionTrigger = null;
        _activationTriggerProps = null;
        get sectionTrigger() {
            return this._sectionTrigger
        }
        constructor(t) {
            super(t)
        }
        async doSetup() {
            Mn.resizeEvent.on(t => this.resize(t.width, t.height)),
            this.element && this.element.style && (this.element.style.visibility = "visible"),
            await this.setupSection(),
            this.element && Px.on(async () => {
                this._setupScrollTrigger()
            }
            ),
            this.resize(Mn.Current.width, Mn.Current.height)
        }
        _setupScrollTrigger() {
            this._sectionTrigger = c1({
                trigger: this.element,
                start: "top bottom-=10%",
                end: "bottom top-=10%",
                ...this._activationTriggerProps,
                onEnter: () => this.activate({
                    direction: 1
                }),
                onEnterBack: () => this.activate({
                    direction: -1
                }),
                onLeave: () => this.deactivate({
                    direction: 1
                }),
                onLeaveBack: () => this.deactivate({
                    direction: -1
                }),
                markers: !1
            })
        }
        start() {}
        setupSection() {}
        resize(t, n) {}
        wheel(t, n) {}
        unmount() {
            this.sectionTrigger.kill()
        }
    }
    class Jq extends qi {
        isActivated;
        _currentFrame = {
            contents: 1
        };
        _canvas;
        _ctx;
        _frameImages = new Map;
        isLooping = !1;
        lastScrollPosition = 0;
        scrollTrigger;
        _rem;
        animationTimeline;
        triggerElement;
        _canvasElement;
        totalFrames;
        offsetVideoEnd;
        countPreloadFrames;
        isLoopActive;
        loopDuration;
        framesPerLoop;
        transitionStartScrollOffset;
        loopStartFrame;
        loopEndFrame;
        transitionDuration;
        idAnimation;
        get _currentBreakpointType() {
            return Mn.Current.breakpoint.name
        }
        constructor(t) {
            const n = {
                [fo.Desktop]: 0,
                [fo.Tablet]: 0,
                [fo.Mobile]: 0
            }
              , r = 10;
            if (super(t),
            this.animationTimeline = t.animationTimeline,
            this.triggerElement = t.triggerElement,
            this._canvasElement = t.canvasElement,
            this.totalFrames = t.totalFrames,
            this.offsetVideoEnd = t.offsetVideoEnd || n,
            this.countPreloadFrames = t.countPreloadFrames || r,
            this.isLoopActive = t.loopConfig !== void 0,
            this.isLoopActive) {
                const s = t.loopConfig;
                this.loopDuration = s.loopDuration,
                this.framesPerLoop = s.framesPerLoop,
                this.transitionStartScrollOffset = s.transitionStartScrollOffset,
                this.loopStartFrame = s.loopStartFrame,
                this.loopEndFrame = s.loopEndFrame,
                this.transitionDuration = s.transitionDuration
            }
        }
        unmount() {
            this.scrollTrigger && this.scrollTrigger.kill(),
            this._canvas && this._canvas.remove(),
            this._ctx && this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height),
            this._frameImages.clear(),
            this.idAnimation && cancelAnimationFrame(this.idAnimation)
        }
        async playLoop() {
            if (!this.isLoopActive || !this.isLooping)
                return;
            const t = Date.now()
              , n = () => {
                if (!this.isLooping)
                    return;
                const s = (Date.now() - t) % (this.loopDuration * 1e3) / (this.loopDuration * 1e3)
                  , o = Math.round(this.loopStartFrame + s * this.framesPerLoop);
                o !== this._currentFrame.contents && (this._currentFrame.contents = o,
                this.renderFrame(this._currentFrame.contents)),
                this.idAnimation = requestAnimationFrame(n)
            }
            ;
            await this.preloadFrames(this.loopStartFrame, this.loopEndFrame),
            n()
        }
        handleScrollTransition(t) {
            this.isLoopActive && (this.isLooping && t > 0 ? (this.isLooping = !1,
            En.to(this._currentFrame, {
                onComplete: () => this.isLooping = !1,
                duration: this.transitionDuration,
                contents: this.framesPerLoop - this.transitionStartScrollOffset,
                ease: "power2.inOut"
            })) : !this.isLooping && t === 0 && (this.preloadFrames(this.loopStartFrame, this.loopEndFrame),
            this.isLooping = !0,
            this.playLoop()))
        }
        async loadFrame(t) {
            return new Promise( (n, r) => {
                const s = new Image
                  , o = String(t).padStart(3, "0");
                s.style.width = "100%",
                s.style.height = "100%",
                s.style.objectFit = "cover",
                s.src = `/desktop/frame_${o}.webp`,
                s.onload = () => n(s),
                s.onerror = r
            }
            )
        }
        async preloadFrames(t, n) {
            t < 1 && (t = 1),
            n > this.totalFrames[this._currentBreakpointType] && (n = this.totalFrames[this._currentBreakpointType]);
            for (let r = t; r <= n; r++)
                if (!this._frameImages.has(r)) {
                    const s = await this.loadFrame(r);
                    this._frameImages.set(r, s)
                }
        }
        loadFramesToHash() {
            const t = new kx;
            for (let n = this.countPreloadFrames; n <= this.totalFrames[this._currentBreakpointType]; n++)
                t.enqueue(async () => {
                    const r = await this.loadFrame(n);
                    this._frameImages.set(n, r)
                }
                );
            t.start()
        }
        renderFrame(t) {
            const n = this._frameImages.get(t);
            if (n && this._ctx) {
                this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
                const r = window.devicePixelRatio || 1
                  , s = this._canvas.width
                  , o = this._canvas.height;
                if (Mn.isTablet) {
                    this._ctx.drawImage(n, -s / r * .2, 0, s / r * 1.4, o / r);
                    return
                }
                this._ctx.drawImage(n, 0, 0, s / r, o / r)
            }
        }
        async doSetup() {
            this._canvas = this._canvasElement,
            this._ctx = this._canvas.getContext("2d"),
            this.isLooping = this.isLoopActive,
            this.playLoop();
            const t = () => {
                const n = window.devicePixelRatio || 1
                  , r = window.innerWidth
                  , s = window.innerHeight;
                this._canvas.style.width = r + "px",
                this._canvas.style.height = s + "px",
                this._canvas.width = r * n,
                this._canvas.height = s * n,
                this._ctx.scale(n, n),
                this.renderFrame(this._currentFrame.contents)
            }
            ;
            t(),
            window.addEventListener("resize", t),
            await this.preloadFrames(1, this.countPreloadFrames),
            this.renderFrame(1),
            this.loadFramesToHash()
        }
        _containerSequenceUpdate = async t => {
            const n = window.scrollY
              , r = n < this.lastScrollPosition;
            this.lastScrollPosition = n;
            const s = document.documentElement.scrollHeight - window.innerHeight
              , o = Math.min(1, n / (s - this.offsetVideoEnd[this._currentBreakpointType]));
            if (this.handleScrollTransition(t.progress),
            !this.isLooping) {
                const c = Math.round(o * this.totalFrames[this._currentBreakpointType]);
                if (c !== this._currentFrame.contents) {
                    this._currentFrame.contents = c;
                    const l = 5;
                    await this.preloadFrames(c + (r ? -l : 1), c + (r ? -1 : l)),
                    this.renderFrame(c)
                }
            }
        }
        ;
        scrollToTween(t) {
            if (!this.scrollTrigger)
                return;
            const n = this.scrollTrigger.labelToScroll(t);
            n && window.scrollTo({
                top: n,
                behavior: "smooth"
            })
        }
        playSequenceOnScroll() {
            this.scrollTrigger = mf.create({
                trigger: this.triggerElement,
                markers: !0,
                start: "top top",
                end: "bottom bottom",
                pinSpacing: !1,
                animation: this.animationTimeline ? this.animationTimeline[this._currentBreakpointType] : En.timeline(),
                scrub: !0,
                onUpdate: this._containerSequenceUpdate
            })
        }
        getLabelPosition(t) {
            return this.scrollTrigger ? this.scrollTrigger.labelToScroll(t) : void 0
        }
        _activate() {
            this.playSequenceOnScroll()
        }
        _deactivate() {}
    }
    class Xq extends zi {
        isActivated;
        seq;
        async setupSection() {
            od.prototype.initializeHeroTabs(),
            od.prototype.loadVaults(),
            this.setupSequence()
        }
        async _activate() {
            this.isActivated
        }
        setupSequence() {
            if (Mn.isMobile)
                return;
            const t = {
                loopConfig: {
                    loopDuration: 4.2,
                    framesPerLoop: 126,
                    transitionStartScrollOffset: 1,
                    loopStartFrame: 0,
                    loopEndFrame: 126,
                    transitionDuration: 1
                },
                el: this.element,
                triggerElement: this.element.querySelector(".timeline"),
                canvasElement: this.element.querySelector(".canvas"),
                totalFrames: {
                    Desktop: 126,
                    Tablet: 126,
                    Mobile: 126
                },
                countPreloadFrames: 30
            };
            this.seq = new Jq(t),
            this.seq.setup()
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let cd;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.Hero);
        e && (cd = new Xq({
            el: e
        }),
        cd.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        cd && cd.unmount()
    }
    );
    class Qq extends zi {
        _rem;
        scrollTrigger;
        scrollTrigger1;
        scrollTrigger2;
        scrollDirection;
        setupPinAnimation() {
            const t = En.timeline({});
            t.fromTo({
                pause: 0
            }, {
                pause: 0
            }, {
                pause: 1,
                duration: 100,
                ease: "none"
            }).fromTo(".lend .solution-item__futures", {
                opacity: 1,
                y: 0
            }, {
                opacity: 0,
                y: -100,
                duration: 35,
                ease: "none"
            }, 20).fromTo(".borrow .solution-item__futures", {
                opacity: 0
            }, {
                opacity: 1,
                y: 0,
                duration: 45,
                ease: "none"
            }, 55).fromTo(".lend .solution-item__card", {
                opacity: 1
            }, {
                opacity: 0,
                duration: 5,
                ease: "none"
            }, 95);
            const n = En.timeline({});
            n.fromTo({
                pause: 0
            }, {
                pause: 0
            }, {
                pause: 1,
                duration: 100,
                ease: "none"
            }).fromTo(".borrow .solution-item__futures", {
                y: 0,
                opacity: 1
            }, {
                opacity: 0,
                y: -100,
                duration: 35,
                ease: "none"
            }, 20).fromTo(".curate .solution-item__futures", {
                opacity: 0
            }, {
                opacity: 1,
                duration: 45,
                ease: "none"
            }, 55).fromTo(".borrow .solution-item__card", {
                opacity: 1
            }, {
                opacity: 0,
                duration: 5,
                ease: "none"
            }, 95);
            const r = En.timeline({});
            r.fromTo({
                pause: 0
            }, {
                pause: 0
            }, {
                pause: 1,
                duration: 100,
                ease: "none"
            }),
            this.scrollTrigger1 = mf.create({
                trigger: ".borrow",
                start: "top top+=15%",
                end: "bottom top",
                pinSpacing: !1,
                scrub: !0,
                animation: n,
                pin: !0,
                onUpdate: s => {
                    const o = Math.sign(s.getVelocity());
                    o !== 0 && this.handleDirectionChange(o)
                }
            }),
            this.scrollTrigger2 = mf.create({
                trigger: ".curate",
                start: "top top+=15%",
                end: "bottom center+=10%",
                scrub: !0,
                animation: r,
                pin: !0,
                onUpdate: s => {
                    const o = Math.sign(s.getVelocity());
                    o !== 0 && this.handleDirectionChange(o)
                }
            }),
            this.scrollTrigger = mf.create({
                trigger: ".lend",
                start: "top top+=15%",
                end: "bottom top",
                pinSpacing: !1,
                scrub: !0,
                animation: t,
                pin: !0,
                onUpdate: s => {
                    const o = Math.sign(s.getVelocity());
                    o !== 0 && this.handleDirectionChange(o)
                }
            })
        }
        unmount() {
            this.scrollTrigger && this.scrollTrigger.kill(),
            this.scrollTrigger1 && this.scrollTrigger1.kill(),
            this.scrollTrigger2 && this.scrollTrigger2.kill(),
            super.unmount()
        }
        handleDirectionChange(t) {
            t > 0 ? this.scrollDirection = 1 : t < 0 && (this.scrollDirection = -1)
        }
        setupContactUsBtns() {
            document.querySelectorAll(".contact-us-btn").forEach(n => n.addEventListener("click", function() {
                const r = this.attributes["data-parentid"].value
                  , s = document.querySelector('[for="' + r + '"]');
                s && s.click()
            }))
        }
        async setupSection() {
            this.setupContactUsBtns(),
            Mn.isDesktop && setTimeout( () => {
                this.setupPinAnimation()
            }
            , u1)
        }
        _activate() {}
        _deactivate() {}
        resize() {
            this._rem = Mn.Current.rem
        }
    }
    let ud;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.Solution);
        e && (ud = new Qq({
            el: e
        }),
        ud.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        ud && ud.unmount()
    }
    );
    class e6 extends zi {
        isActivated;
        async _setupStates() {}
        async _activate() {
            this.isActivated
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let ld;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.HowItWorks);
        e && (ld = new e6({
            el: e
        }),
        ld.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        ld && ld.unmount()
    }
    );
    class t6 extends qi {
        constructor(t) {
            super(t)
        }
        async doSetup() {
            const t = document.querySelectorAll(".accordion button")
              , n = r => {
                const s = r.currentTarget
                  , o = s.getAttribute("aria-expanded");
                t.forEach(c => {
                    c.setAttribute("aria-expanded", "false")
                }
                ),
                o == "false" && s.setAttribute("aria-expanded", "true")
            }
            ;
            t.forEach(r => r.addEventListener("click", n))
        }
    }
    class n6 extends zi {
        isActivated;
        async setupSection() {
            (async () => {
                const t = document.getElementById(Cx.AccordionsList);
                t && await new t6({
                    el: t
                }).setup()
            }
            )()
        }
        async _activate() {
            this.isActivated
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let fd;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.OurAdvantage);
        e && (fd = new n6({
            el: e
        }),
        fd.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        fd && fd.unmount()
    }
    );
    var Fm = (e => (e.Black = "color-black",
    e))(Fm || {});
    function r6(e) {
        e?.classList.forEach(t => {
            t.startsWith("color-") && e.classList.remove(t)
        }
        )
    }
    function i6() {
        r6(document.querySelector(".header"))
    }
    function s6(e) {
        document.querySelector(".header").classList.add(e)
    }
    function zw(e) {
        const {element: t, color: n, triggerVars: r} = e;
        return c1({
            trigger: t,
            onEnter: () => hf(n),
            onEnterBack: () => hf(n),
            onLeave: () => hf(),
            onLeaveBack: () => hf(),
            ...r
        })
    }
    function hf(e) {
        i6(),
        e && s6(e)
    }
    class a6 extends zi {
        isActivated;
        direction;
        trigger;
        trigger1;
        async setupSection() {
            setTimeout( () => {
                this._setupChangeColorHeader(),
                this.trigger.refresh(),
                this.trigger1 && (this.trigger1.refresh(),
                this.trigger1.update())
            }
            , u1)
        }
        _setupChangeColorHeader() {
            const t = {
                element: document.querySelector(".transparent-section"),
                color: Fm.Black,
                triggerVars: {
                    start: "top top+=10%",
                    end: "bottom top+=10%",
                    onUpdate: n => {
                        this.direction = n.direction
                    }
                }
            };
            if (this.trigger = zw(t),
            Mn.isMobile) {
                const n = {
                    element: document.querySelector(".footer"),
                    color: Fm.Black,
                    triggerVars: {
                        start: "top top+=10%",
                        end: "bottom top+=10%",
                        onUpdate: r => {
                            this.direction = r.direction
                        }
                    }
                };
                this.trigger1 = zw(n)
            }
        }
        async _activate() {
            this.isActivated
        }
        unmount() {
            this.trigger.kill(),
            this.trigger1 && this.trigger1.kill(),
            super.unmount()
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let dd;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.Transparent);
        e && (dd = new a6({
            el: e
        }),
        dd.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        dd && dd.unmount()
    }
    );
    const o6 = {
        [fo.Desktop]: 0,
        [fo.Tablet]: 150,
        [fo.Mobile]: 200
    }
      , Gw = "ticker-items";
    class c6 extends qi {
        tickerWidth;
        tickerAnim;
        get tickerElement() {
            return this.element.querySelectorAll(".ticker")
        }
        constructor(t) {
            super(t)
        }
        async doSetup() {
            const t = document.querySelectorAll(".text-js");
            t.forEach(n => {
                this.setupTickerLine(n, Gw)
            }
            ),
            this.tickerWidth = t[0].offsetWidth
        }
        setupTickerLine(t, n) {
            const r = t.innerHTML
              , s = `<div class='${n}'>` + r + "</div>";
            t.innerHTML = s,
            t.innerHTML += s
        }
        stop() {
            this.tickerAnim.kill()
        }
        get breakpointType() {
            return Mn.Current.breakpoint.name
        }
        activate = async () => {
            const t = this.tickerWidth / o6[this.breakpointType];
            this.tickerAnim = En.fromTo(`.${Gw}`, {
                xPercent: -100
            }, {
                duration: t,
                xPercent: 0,
                ease: "none",
                repeat: -1
            })
        }
        ;
        deactivate = async () => {
            this.tickerAnim.kill()
        }
        ;
        show = async () => (En.set(this.element, {
            autoAlpha: 1
        }),
        En.timeline().add( () => {
            this.activate()
        }
        , Af(10)));
        hide = async () => En.timeline().add( () => {
            this.deactivate()
        }
        , Af(20))
    }
    class u6 extends zi {
        isActivated;
        line;
        async setupSection() {
            Mn.isDesktop || (this.line = await new c6({
                el: document.getElementById("ticker-container")
            }).setup(),
            this.line.show())
        }
        async _activate() {
            this.isActivated
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let hd;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.Ecosystem);
        e && (hd = new u6({
            el: e
        }),
        hd.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        hd && hd.unmount()
    }
    );
    class l6 extends qi {
        roleSections;
        roleRadios;
        constructor(t) {
            super(t)
        }
        async doSetup() {
            this.setupRoleRadios()
        }
        setupRoleRadios() {
            this.roleRadios = document.querySelectorAll('input[type="radio"][name="role"]'),
            this.roleSections = {
                lender: document.querySelectorAll(".form-list-item--deposit"),
                borrower: document.querySelectorAll(".form-list-item--borrow"),
                curator: document.querySelectorAll(".form-list-item--focus")
            },
            this.roleRadios.length && (this.roleRadios.forEach(t => t.addEventListener("change", () => this.updateVisibleSection())),
            this.updateVisibleSection())
        }
        updateVisibleSection() {
            Object.values(this.roleSections).forEach(n => {
                En.set(n, {
                    display: "none"
                }),
                n.forEach(r => r.querySelectorAll("input").forEach(s => s.removeAttribute("required")))
            }
            );
            const t = this.getSelectedRole();
            t && (En.set(this.roleSections[t], {
                display: "flex"
            }),
            this.roleSections[t].forEach(n => n.querySelectorAll("input").forEach(r => r.setAttribute("required", "required"))))
        }
        getSelectedRole() {
            const t = Array.from(this.roleRadios).find(n => n.checked);
            return t ? t.value : null
        }
        get currentBreakpoint() {
            return Mn.Current.breakpoint.name
        }
    }
    class f6 extends zi {
        isActivated;
        _form;
        async setupSection() {
            this._form = new l6({
                el: this.element.querySelector(".form")
            }),
            this._form.setup()
        }
        async _activate() {
            this.isActivated
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let pd;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.GetInTouch);
        e && (pd = new f6({
            el: e
        }),
        pd.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        pd && pd.unmount()
    }
    );
    var nS = {}, Dp = {}, Up = {}, Zw;
    function C0() {
        return Zw || (Zw = 1,
        function(e) {
            const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD"
              , n = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040"
              , r = "[" + t + "][" + n + "]*"
              , s = new RegExp("^" + r + "$")
              , o = function(l, f) {
                const d = [];
                let h = f.exec(l);
                for (; h; ) {
                    const y = [];
                    y.startIndex = f.lastIndex - h[0].length;
                    const I = h.length;
                    for (let $ = 0; $ < I; $++)
                        y.push(h[$]);
                    d.push(y),
                    h = f.exec(l)
                }
                return d
            }
              , c = function(l) {
                const f = s.exec(l);
                return !(f === null || typeof f > "u")
            };
            e.isExist = function(l) {
                return typeof l < "u"
            }
            ,
            e.isEmptyObject = function(l) {
                return Object.keys(l).length === 0
            }
            ,
            e.merge = function(l, f, d) {
                if (f) {
                    const h = Object.keys(f)
                      , y = h.length;
                    for (let I = 0; I < y; I++)
                        d === "strict" ? l[h[I]] = [f[h[I]]] : l[h[I]] = f[h[I]]
                }
            }
            ,
            e.getValue = function(l) {
                return e.isExist(l) ? l : ""
            }
            ,
            e.isName = c,
            e.getAllMatches = o,
            e.nameRegexp = r
        }(Up)),
        Up
    }
    var Kw;
    function rS() {
        if (Kw)
            return Dp;
        Kw = 1;
        const e = C0()
          , t = {
            allowBooleanAttributes: !1,
            unpairedTags: []
        };
        Dp.validate = function(m, g) {
            g = Object.assign({}, t, g);
            const M = [];
            let G = !1
              , U = !1;
            m[0] === "\uFEFF" && (m = m.substr(1));
            for (let D = 0; D < m.length; D++)
                if (m[D] === "<" && m[D + 1] === "?") {
                    if (D += 2,
                    D = r(m, D),
                    D.err)
                        return D
                } else if (m[D] === "<") {
                    let K = D;
                    if (D++,
                    m[D] === "!") {
                        D = s(m, D);
                        continue
                    } else {
                        let _ = !1;
                        m[D] === "/" && (_ = !0,
                        D++);
                        let T = "";
                        for (; D < m.length && m[D] !== ">" && m[D] !== " " && m[D] !== "	" && m[D] !== `
` && m[D] !== "\r"; D++)
                            T += m[D];
                        if (T = T.trim(),
                        T[T.length - 1] === "/" && (T = T.substring(0, T.length - 1),
                        D--),
                        !O(T)) {
                            let C;
                            return T.trim().length === 0 ? C = "Invalid space after '<'." : C = "Tag '" + T + "' is an invalid name.",
                            I("InvalidTag", C, A(m, D))
                        }
                        const S = l(m, D);
                        if (S === !1)
                            return I("InvalidAttr", "Attributes for '" + T + "' have open quote.", A(m, D));
                        let q = S.value;
                        if (D = S.index,
                        q[q.length - 1] === "/") {
                            const C = D - q.length;
                            q = q.substring(0, q.length - 1);
                            const F = d(q, g);
                            if (F === !0)
                                G = !0;
                            else
                                return I(F.err.code, F.err.msg, A(m, C + F.err.line))
                        } else if (_)
                            if (S.tagClosed) {
                                if (q.trim().length > 0)
                                    return I("InvalidTag", "Closing tag '" + T + "' can't have attributes or invalid starting.", A(m, K));
                                if (M.length === 0)
                                    return I("InvalidTag", "Closing tag '" + T + "' has not been opened.", A(m, K));
                                {
                                    const C = M.pop();
                                    if (T !== C.tagName) {
                                        let F = A(m, C.tagStartPos);
                                        return I("InvalidTag", "Expected closing tag '" + C.tagName + "' (opened in line " + F.line + ", col " + F.col + ") instead of closing tag '" + T + "'.", A(m, K))
                                    }
                                    M.length == 0 && (U = !0)
                                }
                            } else
                                return I("InvalidTag", "Closing tag '" + T + "' doesn't have proper closing.", A(m, D));
                        else {
                            const C = d(q, g);
                            if (C !== !0)
                                return I(C.err.code, C.err.msg, A(m, D - q.length + C.err.line));
                            if (U === !0)
                                return I("InvalidXml", "Multiple possible root nodes found.", A(m, D));
                            g.unpairedTags.indexOf(T) !== -1 || M.push({
                                tagName: T,
                                tagStartPos: K
                            }),
                            G = !0
                        }
                        for (D++; D < m.length; D++)
                            if (m[D] === "<")
                                if (m[D + 1] === "!") {
                                    D++,
                                    D = s(m, D);
                                    continue
                                } else if (m[D + 1] === "?") {
                                    if (D = r(m, ++D),
                                    D.err)
                                        return D
                                } else
                                    break;
                            else if (m[D] === "&") {
                                const C = y(m, D);
                                if (C == -1)
                                    return I("InvalidChar", "char '&' is not expected.", A(m, D));
                                D = C
                            } else if (U === !0 && !n(m[D]))
                                return I("InvalidXml", "Extra text at the end", A(m, D));
                        m[D] === "<" && D--
                    }
                } else {
                    if (n(m[D]))
                        continue;
                    return I("InvalidChar", "char '" + m[D] + "' is not expected.", A(m, D))
                }
            if (G) {
                if (M.length == 1)
                    return I("InvalidTag", "Unclosed tag '" + M[0].tagName + "'.", A(m, M[0].tagStartPos));
                if (M.length > 0)
                    return I("InvalidXml", "Invalid '" + JSON.stringify(M.map(D => D.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", {
                        line: 1,
                        col: 1
                    })
            } else
                return I("InvalidXml", "Start tag expected.", 1);
            return !0
        }
        ;
        function n(m) {
            return m === " " || m === "	" || m === `
` || m === "\r"
        }
        function r(m, g) {
            const M = g;
            for (; g < m.length; g++)
                if (m[g] == "?" || m[g] == " ") {
                    const G = m.substr(M, g - M);
                    if (g > 5 && G === "xml")
                        return I("InvalidXml", "XML declaration allowed only at the start of the document.", A(m, g));
                    if (m[g] == "?" && m[g + 1] == ">") {
                        g++;
                        break
                    } else
                        continue
                }
            return g
        }
        function s(m, g) {
            if (m.length > g + 5 && m[g + 1] === "-" && m[g + 2] === "-") {
                for (g += 3; g < m.length; g++)
                    if (m[g] === "-" && m[g + 1] === "-" && m[g + 2] === ">") {
                        g += 2;
                        break
                    }
            } else if (m.length > g + 8 && m[g + 1] === "D" && m[g + 2] === "O" && m[g + 3] === "C" && m[g + 4] === "T" && m[g + 5] === "Y" && m[g + 6] === "P" && m[g + 7] === "E") {
                let M = 1;
                for (g += 8; g < m.length; g++)
                    if (m[g] === "<")
                        M++;
                    else if (m[g] === ">" && (M--,
                    M === 0))
                        break
            } else if (m.length > g + 9 && m[g + 1] === "[" && m[g + 2] === "C" && m[g + 3] === "D" && m[g + 4] === "A" && m[g + 5] === "T" && m[g + 6] === "A" && m[g + 7] === "[") {
                for (g += 8; g < m.length; g++)
                    if (m[g] === "]" && m[g + 1] === "]" && m[g + 2] === ">") {
                        g += 2;
                        break
                    }
            }
            return g
        }
        const o = '"'
          , c = "'";
        function l(m, g) {
            let M = ""
              , G = ""
              , U = !1;
            for (; g < m.length; g++) {
                if (m[g] === o || m[g] === c)
                    G === "" ? G = m[g] : G !== m[g] || (G = "");
                else if (m[g] === ">" && G === "") {
                    U = !0;
                    break
                }
                M += m[g]
            }
            return G !== "" ? !1 : {
                value: M,
                index: g,
                tagClosed: U
            }
        }
        const f = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,"g");
        function d(m, g) {
            const M = e.getAllMatches(m, f)
              , G = {};
            for (let U = 0; U < M.length; U++) {
                if (M[U][1].length === 0)
                    return I("InvalidAttr", "Attribute '" + M[U][2] + "' has no space in starting.", N(M[U]));
                if (M[U][3] !== void 0 && M[U][4] === void 0)
                    return I("InvalidAttr", "Attribute '" + M[U][2] + "' is without value.", N(M[U]));
                if (M[U][3] === void 0 && !g.allowBooleanAttributes)
                    return I("InvalidAttr", "boolean attribute '" + M[U][2] + "' is not allowed.", N(M[U]));
                const D = M[U][2];
                if (!$(D))
                    return I("InvalidAttr", "Attribute '" + D + "' is an invalid name.", N(M[U]));
                if (!G.hasOwnProperty(D))
                    G[D] = 1;
                else
                    return I("InvalidAttr", "Attribute '" + D + "' is repeated.", N(M[U]))
            }
            return !0
        }
        function h(m, g) {
            let M = /\d/;
            for (m[g] === "x" && (g++,
            M = /[\da-fA-F]/); g < m.length; g++) {
                if (m[g] === ";")
                    return g;
                if (!m[g].match(M))
                    break
            }
            return -1
        }
        function y(m, g) {
            if (g++,
            m[g] === ";")
                return -1;
            if (m[g] === "#")
                return g++,
                h(m, g);
            let M = 0;
            for (; g < m.length; g++,
            M++)
                if (!(m[g].match(/\w/) && M < 20)) {
                    if (m[g] === ";")
                        break;
                    return -1
                }
            return g
        }
        function I(m, g, M) {
            return {
                err: {
                    code: m,
                    msg: g,
                    line: M.line || M,
                    col: M.col
                }
            }
        }
        function $(m) {
            return e.isName(m)
        }
        function O(m) {
            return e.isName(m)
        }
        function A(m, g) {
            const M = m.substring(0, g).split(/\r?\n/);
            return {
                line: M.length,
                col: M[M.length - 1].length + 1
            }
        }
        function N(m) {
            return m.startIndex + m[1].length
        }
        return Dp
    }
    var pf = {}, Jw;
    function d6() {
        if (Jw)
            return pf;
        Jw = 1;
        const e = {
            preserveOrder: !1,
            attributeNamePrefix: "@_",
            attributesGroupName: !1,
            textNodeName: "#text",
            ignoreAttributes: !0,
            removeNSPrefix: !1,
            allowBooleanAttributes: !1,
            parseTagValue: !0,
            parseAttributeValue: !1,
            trimValues: !0,
            cdataPropName: !1,
            numberParseOptions: {
                hex: !0,
                leadingZeros: !0,
                eNotation: !0
            },
            tagValueProcessor: function(n, r) {
                return r
            },
            attributeValueProcessor: function(n, r) {
                return r
            },
            stopNodes: [],
            alwaysCreateTextNode: !1,
            isArray: () => !1,
            commentPropName: !1,
            unpairedTags: [],
            processEntities: !0,
            htmlEntities: !1,
            ignoreDeclaration: !1,
            ignorePiTags: !1,
            transformTagName: !1,
            transformAttributeName: !1,
            updateTag: function(n, r, s) {
                return n
            }
        }
          , t = function(n) {
            return Object.assign({}, e, n)
        };
        return pf.buildOptions = t,
        pf.defaultOptions = e,
        pf
    }
    var Bp, Xw;
    function h6() {
        if (Xw)
            return Bp;
        Xw = 1;
        class e {
            constructor(n) {
                this.tagname = n,
                this.child = [],
                this[":@"] = {}
            }
            add(n, r) {
                n === "__proto__" && (n = "#__proto__"),
                this.child.push({
                    [n]: r
                })
            }
            addChild(n) {
                n.tagname === "__proto__" && (n.tagname = "#__proto__"),
                n[":@"] && Object.keys(n[":@"]).length > 0 ? this.child.push({
                    [n.tagname]: n.child,
                    ":@": n[":@"]
                }) : this.child.push({
                    [n.tagname]: n.child
                })
            }
        }
        return Bp = e,
        Bp
    }
    var Fp, Qw;
    function p6() {
        if (Qw)
            return Fp;
        Qw = 1;
        const e = C0();
        function t(d, h) {
            const y = {};
            if (d[h + 3] === "O" && d[h + 4] === "C" && d[h + 5] === "T" && d[h + 6] === "Y" && d[h + 7] === "P" && d[h + 8] === "E") {
                h = h + 9;
                let I = 1
                  , $ = !1
                  , O = !1
                  , A = "";
                for (; h < d.length; h++)
                    if (d[h] === "<" && !O) {
                        if ($ && s(d, h)) {
                            h += 7;
                            let N, m;
                            [N,m,h] = n(d, h + 1),
                            m.indexOf("&") === -1 && (y[f(N)] = {
                                regx: RegExp(`&${N};`, "g"),
                                val: m
                            })
                        } else if ($ && o(d, h))
                            h += 8;
                        else if ($ && c(d, h))
                            h += 8;
                        else if ($ && l(d, h))
                            h += 9;
                        else if (r)
                            O = !0;
                        else
                            throw new Error("Invalid DOCTYPE");
                        I++,
                        A = ""
                    } else if (d[h] === ">") {
                        if (O ? d[h - 1] === "-" && d[h - 2] === "-" && (O = !1,
                        I--) : I--,
                        I === 0)
                            break
                    } else
                        d[h] === "[" ? $ = !0 : A += d[h];
                if (I !== 0)
                    throw new Error("Unclosed DOCTYPE")
            } else
                throw new Error("Invalid Tag instead of DOCTYPE");
            return {
                entities: y,
                i: h
            }
        }
        function n(d, h) {
            let y = "";
            for (; h < d.length && d[h] !== "'" && d[h] !== '"'; h++)
                y += d[h];
            if (y = y.trim(),
            y.indexOf(" ") !== -1)
                throw new Error("External entites are not supported");
            const I = d[h++];
            let $ = "";
            for (; h < d.length && d[h] !== I; h++)
                $ += d[h];
            return [y, $, h]
        }
        function r(d, h) {
            return d[h + 1] === "!" && d[h + 2] === "-" && d[h + 3] === "-"
        }
        function s(d, h) {
            return d[h + 1] === "!" && d[h + 2] === "E" && d[h + 3] === "N" && d[h + 4] === "T" && d[h + 5] === "I" && d[h + 6] === "T" && d[h + 7] === "Y"
        }
        function o(d, h) {
            return d[h + 1] === "!" && d[h + 2] === "E" && d[h + 3] === "L" && d[h + 4] === "E" && d[h + 5] === "M" && d[h + 6] === "E" && d[h + 7] === "N" && d[h + 8] === "T"
        }
        function c(d, h) {
            return d[h + 1] === "!" && d[h + 2] === "A" && d[h + 3] === "T" && d[h + 4] === "T" && d[h + 5] === "L" && d[h + 6] === "I" && d[h + 7] === "S" && d[h + 8] === "T"
        }
        function l(d, h) {
            return d[h + 1] === "!" && d[h + 2] === "N" && d[h + 3] === "O" && d[h + 4] === "T" && d[h + 5] === "A" && d[h + 6] === "T" && d[h + 7] === "I" && d[h + 8] === "O" && d[h + 9] === "N"
        }
        function f(d) {
            if (e.isName(d))
                return d;
            throw new Error(`Invalid entity name ${d}`)
        }
        return Fp = t,
        Fp
    }
    var jp, e1;
    function m6() {
        if (e1)
            return jp;
        e1 = 1;
        const e = /^[-+]?0x[a-fA-F0-9]+$/
          , t = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/
          , n = {
            hex: !0,
            leadingZeros: !0,
            decimalPoint: ".",
            eNotation: !0
        };
        function r(c, l={}) {
            if (l = Object.assign({}, n, l),
            !c || typeof c != "string")
                return c;
            let f = c.trim();
            if (l.skipLike !== void 0 && l.skipLike.test(f))
                return c;
            if (c === "0")
                return 0;
            if (l.hex && e.test(f))
                return o(f, 16);
            if (f.search(/[eE]/) !== -1) {
                const d = f.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
                if (d) {
                    if (l.leadingZeros)
                        f = (d[1] || "") + d[3];
                    else if (!(d[2] === "0" && d[3][0] === "."))
                        return c;
                    return l.eNotation ? Number(f) : c
                } else
                    return c
            } else {
                const d = t.exec(f);
                if (d) {
                    const h = d[1]
                      , y = d[2];
                    let I = s(d[3]);
                    if (!l.leadingZeros && y.length > 0 && h && f[2] !== ".")
                        return c;
                    if (!l.leadingZeros && y.length > 0 && !h && f[1] !== ".")
                        return c;
                    if (l.leadingZeros && y === c)
                        return 0;
                    {
                        const $ = Number(f)
                          , O = "" + $;
                        return O.search(/[eE]/) !== -1 ? l.eNotation ? $ : c : f.indexOf(".") !== -1 ? O === "0" && I === "" || O === I || h && O === "-" + I ? $ : c : y ? I === O || h + I === O ? $ : c : f === O || f === h + O ? $ : c
                    }
                } else
                    return c
            }
        }
        function s(c) {
            return c && c.indexOf(".") !== -1 && (c = c.replace(/0+$/, ""),
            c === "." ? c = "0" : c[0] === "." ? c = "0" + c : c[c.length - 1] === "." && (c = c.substr(0, c.length - 1))),
            c
        }
        function o(c, l) {
            if (parseInt)
                return parseInt(c, l);
            if (Number.parseInt)
                return Number.parseInt(c, l);
            if (window && window.parseInt)
                return window.parseInt(c, l);
            throw new Error("parseInt, Number.parseInt, window.parseInt are not supported")
        }
        return jp = r,
        jp
    }
    var qp, t1;
    function iS() {
        if (t1)
            return qp;
        t1 = 1;
        function e(t) {
            return typeof t == "function" ? t : Array.isArray(t) ? n => {
                for (const r of t)
                    if (typeof r == "string" && n === r || r instanceof RegExp && r.test(n))
                        return !0
            }
            : () => !1
        }
        return qp = e,
        qp
    }
    var Hp, n1;
    function g6() {
        if (n1)
            return Hp;
        n1 = 1;
        const e = C0()
          , t = h6()
          , n = p6()
          , r = m6()
          , s = iS();
        class o {
            constructor(D) {
                this.options = D,
                this.currentNode = null,
                this.tagsNodeStack = [],
                this.docTypeEntities = {},
                this.lastEntities = {
                    apos: {
                        regex: /&(apos|#39|#x27);/g,
                        val: "'"
                    },
                    gt: {
                        regex: /&(gt|#62|#x3E);/g,
                        val: ">"
                    },
                    lt: {
                        regex: /&(lt|#60|#x3C);/g,
                        val: "<"
                    },
                    quot: {
                        regex: /&(quot|#34|#x22);/g,
                        val: '"'
                    }
                },
                this.ampEntity = {
                    regex: /&(amp|#38|#x26);/g,
                    val: "&"
                },
                this.htmlEntities = {
                    space: {
                        regex: /&(nbsp|#160);/g,
                        val: " "
                    },
                    cent: {
                        regex: /&(cent|#162);/g,
                        val: ""
                    },
                    pound: {
                        regex: /&(pound|#163);/g,
                        val: ""
                    },
                    yen: {
                        regex: /&(yen|#165);/g,
                        val: ""
                    },
                    euro: {
                        regex: /&(euro|#8364);/g,
                        val: ""
                    },
                    copyright: {
                        regex: /&(copy|#169);/g,
                        val: ""
                    },
                    reg: {
                        regex: /&(reg|#174);/g,
                        val: ""
                    },
                    inr: {
                        regex: /&(inr|#8377);/g,
                        val: ""
                    },
                    num_dec: {
                        regex: /&#([0-9]{1,7});/g,
                        val: (K, _) => String.fromCharCode(Number.parseInt(_, 10))
                    },
                    num_hex: {
                        regex: /&#x([0-9a-fA-F]{1,6});/g,
                        val: (K, _) => String.fromCharCode(Number.parseInt(_, 16))
                    }
                },
                this.addExternalEntities = c,
                this.parseXml = y,
                this.parseTextData = l,
                this.resolveNameSpace = f,
                this.buildAttributesMap = h,
                this.isItStopNode = A,
                this.replaceEntitiesValue = $,
                this.readStopNodeData = M,
                this.saveTextToParentTag = O,
                this.addChild = I,
                this.ignoreAttributesFn = s(this.options.ignoreAttributes)
            }
        }
        function c(U) {
            const D = Object.keys(U);
            for (let K = 0; K < D.length; K++) {
                const _ = D[K];
                this.lastEntities[_] = {
                    regex: new RegExp("&" + _ + ";","g"),
                    val: U[_]
                }
            }
        }
        function l(U, D, K, _, T, S, q) {
            if (U !== void 0 && (this.options.trimValues && !_ && (U = U.trim()),
            U.length > 0)) {
                q || (U = this.replaceEntitiesValue(U));
                const C = this.options.tagValueProcessor(D, U, K, T, S);
                return C == null ? U : typeof C != typeof U || C !== U ? C : this.options.trimValues ? G(U, this.options.parseTagValue, this.options.numberParseOptions) : U.trim() === U ? G(U, this.options.parseTagValue, this.options.numberParseOptions) : U
            }
        }
        function f(U) {
            if (this.options.removeNSPrefix) {
                const D = U.split(":")
                  , K = U.charAt(0) === "/" ? "/" : "";
                if (D[0] === "xmlns")
                    return "";
                D.length === 2 && (U = K + D[1])
            }
            return U
        }
        const d = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`,"gm");
        function h(U, D, K) {
            if (this.options.ignoreAttributes !== !0 && typeof U == "string") {
                const _ = e.getAllMatches(U, d)
                  , T = _.length
                  , S = {};
                for (let q = 0; q < T; q++) {
                    const C = this.resolveNameSpace(_[q][1]);
                    if (this.ignoreAttributesFn(C, D))
                        continue;
                    let F = _[q][4]
                      , X = this.options.attributeNamePrefix + C;
                    if (C.length)
                        if (this.options.transformAttributeName && (X = this.options.transformAttributeName(X)),
                        X === "__proto__" && (X = "#__proto__"),
                        F !== void 0) {
                            this.options.trimValues && (F = F.trim()),
                            F = this.replaceEntitiesValue(F);
                            const v = this.options.attributeValueProcessor(C, F, D);
                            v == null ? S[X] = F : typeof v != typeof F || v !== F ? S[X] = v : S[X] = G(F, this.options.parseAttributeValue, this.options.numberParseOptions)
                        } else
                            this.options.allowBooleanAttributes && (S[X] = !0)
                }
                if (!Object.keys(S).length)
                    return;
                if (this.options.attributesGroupName) {
                    const q = {};
                    return q[this.options.attributesGroupName] = S,
                    q
                }
                return S
            }
        }
        const y = function(U) {
            U = U.replace(/\r\n?/g, `
`);
            const D = new t("!xml");
            let K = D
              , _ = ""
              , T = "";
            for (let S = 0; S < U.length; S++)
                if (U[S] === "<")
                    if (U[S + 1] === "/") {
                        const C = m(U, ">", S, "Closing Tag is not closed.");
                        let F = U.substring(S + 2, C).trim();
                        if (this.options.removeNSPrefix) {
                            const x = F.indexOf(":");
                            x !== -1 && (F = F.substr(x + 1))
                        }
                        this.options.transformTagName && (F = this.options.transformTagName(F)),
                        K && (_ = this.saveTextToParentTag(_, K, T));
                        const X = T.substring(T.lastIndexOf(".") + 1);
                        if (F && this.options.unpairedTags.indexOf(F) !== -1)
                            throw new Error(`Unpaired tag can not be used as closing tag: </${F}>`);
                        let v = 0;
                        X && this.options.unpairedTags.indexOf(X) !== -1 ? (v = T.lastIndexOf(".", T.lastIndexOf(".") - 1),
                        this.tagsNodeStack.pop()) : v = T.lastIndexOf("."),
                        T = T.substring(0, v),
                        K = this.tagsNodeStack.pop(),
                        _ = "",
                        S = C
                    } else if (U[S + 1] === "?") {
                        let C = g(U, S, !1, "?>");
                        if (!C)
                            throw new Error("Pi Tag is not closed.");
                        if (_ = this.saveTextToParentTag(_, K, T),
                        !(this.options.ignoreDeclaration && C.tagName === "?xml" || this.options.ignorePiTags)) {
                            const F = new t(C.tagName);
                            F.add(this.options.textNodeName, ""),
                            C.tagName !== C.tagExp && C.attrExpPresent && (F[":@"] = this.buildAttributesMap(C.tagExp, T, C.tagName)),
                            this.addChild(K, F, T)
                        }
                        S = C.closeIndex + 1
                    } else if (U.substr(S + 1, 3) === "!--") {
                        const C = m(U, "-->", S + 4, "Comment is not closed.");
                        if (this.options.commentPropName) {
                            const F = U.substring(S + 4, C - 2);
                            _ = this.saveTextToParentTag(_, K, T),
                            K.add(this.options.commentPropName, [{
                                [this.options.textNodeName]: F
                            }])
                        }
                        S = C
                    } else if (U.substr(S + 1, 2) === "!D") {
                        const C = n(U, S);
                        this.docTypeEntities = C.entities,
                        S = C.i
                    } else if (U.substr(S + 1, 2) === "![") {
                        const C = m(U, "]]>", S, "CDATA is not closed.") - 2
                          , F = U.substring(S + 9, C);
                        _ = this.saveTextToParentTag(_, K, T);
                        let X = this.parseTextData(F, K.tagname, T, !0, !1, !0, !0);
                        X == null && (X = ""),
                        this.options.cdataPropName ? K.add(this.options.cdataPropName, [{
                            [this.options.textNodeName]: F
                        }]) : K.add(this.options.textNodeName, X),
                        S = C + 2
                    } else {
                        let C = g(U, S, this.options.removeNSPrefix)
                          , F = C.tagName;
                        const X = C.rawTagName;
                        let v = C.tagExp
                          , x = C.attrExpPresent
                          , Y = C.closeIndex;
                        this.options.transformTagName && (F = this.options.transformTagName(F)),
                        K && _ && K.tagname !== "!xml" && (_ = this.saveTextToParentTag(_, K, T, !1));
                        const W = K;
                        if (W && this.options.unpairedTags.indexOf(W.tagname) !== -1 && (K = this.tagsNodeStack.pop(),
                        T = T.substring(0, T.lastIndexOf("."))),
                        F !== D.tagname && (T += T ? "." + F : F),
                        this.isItStopNode(this.options.stopNodes, T, F)) {
                            let te = "";
                            if (v.length > 0 && v.lastIndexOf("/") === v.length - 1)
                                F[F.length - 1] === "/" ? (F = F.substr(0, F.length - 1),
                                T = T.substr(0, T.length - 1),
                                v = F) : v = v.substr(0, v.length - 1),
                                S = C.closeIndex;
                            else if (this.options.unpairedTags.indexOf(F) !== -1)
                                S = C.closeIndex;
                            else {
                                const H = this.readStopNodeData(U, X, Y + 1);
                                if (!H)
                                    throw new Error(`Unexpected end of ${X}`);
                                S = H.i,
                                te = H.tagContent
                            }
                            const J = new t(F);
                            F !== v && x && (J[":@"] = this.buildAttributesMap(v, T, F)),
                            te && (te = this.parseTextData(te, F, T, !0, x, !0, !0)),
                            T = T.substr(0, T.lastIndexOf(".")),
                            J.add(this.options.textNodeName, te),
                            this.addChild(K, J, T)
                        } else {
                            if (v.length > 0 && v.lastIndexOf("/") === v.length - 1) {
                                F[F.length - 1] === "/" ? (F = F.substr(0, F.length - 1),
                                T = T.substr(0, T.length - 1),
                                v = F) : v = v.substr(0, v.length - 1),
                                this.options.transformTagName && (F = this.options.transformTagName(F));
                                const te = new t(F);
                                F !== v && x && (te[":@"] = this.buildAttributesMap(v, T, F)),
                                this.addChild(K, te, T),
                                T = T.substr(0, T.lastIndexOf("."))
                            } else {
                                const te = new t(F);
                                this.tagsNodeStack.push(K),
                                F !== v && x && (te[":@"] = this.buildAttributesMap(v, T, F)),
                                this.addChild(K, te, T),
                                K = te
                            }
                            _ = "",
                            S = Y
                        }
                    }
                else
                    _ += U[S];
            return D.child
        };
        function I(U, D, K) {
            const _ = this.options.updateTag(D.tagname, K, D[":@"]);
            _ === !1 || (typeof _ == "string" && (D.tagname = _),
            U.addChild(D))
        }
        const $ = function(U) {
            if (this.options.processEntities) {
                for (let D in this.docTypeEntities) {
                    const K = this.docTypeEntities[D];
                    U = U.replace(K.regx, K.val)
                }
                for (let D in this.lastEntities) {
                    const K = this.lastEntities[D];
                    U = U.replace(K.regex, K.val)
                }
                if (this.options.htmlEntities)
                    for (let D in this.htmlEntities) {
                        const K = this.htmlEntities[D];
                        U = U.replace(K.regex, K.val)
                    }
                U = U.replace(this.ampEntity.regex, this.ampEntity.val)
            }
            return U
        };
        function O(U, D, K, _) {
            return U && (_ === void 0 && (_ = D.child.length === 0),
            U = this.parseTextData(U, D.tagname, K, !1, D[":@"] ? Object.keys(D[":@"]).length !== 0 : !1, _),
            U !== void 0 && U !== "" && D.add(this.options.textNodeName, U),
            U = ""),
            U
        }
        function A(U, D, K) {
            const _ = "*." + K;
            for (const T in U) {
                const S = U[T];
                if (_ === S || D === S)
                    return !0
            }
            return !1
        }
        function N(U, D, K=">") {
            let _, T = "";
            for (let S = D; S < U.length; S++) {
                let q = U[S];
                if (_)
                    q === _ && (_ = "");
                else if (q === '"' || q === "'")
                    _ = q;
                else if (q === K[0])
                    if (K[1]) {
                        if (U[S + 1] === K[1])
                            return {
                                data: T,
                                index: S
                            }
                    } else
                        return {
                            data: T,
                            index: S
                        };
                else
                    q === "	" && (q = " ");
                T += q
            }
        }
        function m(U, D, K, _) {
            const T = U.indexOf(D, K);
            if (T === -1)
                throw new Error(_);
            return T + D.length - 1
        }
        function g(U, D, K, _=">") {
            const T = N(U, D + 1, _);
            if (!T)
                return;
            let S = T.data;
            const q = T.index
              , C = S.search(/\s/);
            let F = S
              , X = !0;
            C !== -1 && (F = S.substring(0, C),
            S = S.substring(C + 1).trimStart());
            const v = F;
            if (K) {
                const x = F.indexOf(":");
                x !== -1 && (F = F.substr(x + 1),
                X = F !== T.data.substr(x + 1))
            }
            return {
                tagName: F,
                tagExp: S,
                closeIndex: q,
                attrExpPresent: X,
                rawTagName: v
            }
        }
        function M(U, D, K) {
            const _ = K;
            let T = 1;
            for (; K < U.length; K++)
                if (U[K] === "<")
                    if (U[K + 1] === "/") {
                        const S = m(U, ">", K, `${D} is not closed`);
                        if (U.substring(K + 2, S).trim() === D && (T--,
                        T === 0))
                            return {
                                tagContent: U.substring(_, K),
                                i: S
                            };
                        K = S
                    } else if (U[K + 1] === "?")
                        K = m(U, "?>", K + 1, "StopNode is not closed.");
                    else if (U.substr(K + 1, 3) === "!--")
                        K = m(U, "-->", K + 3, "StopNode is not closed.");
                    else if (U.substr(K + 1, 2) === "![")
                        K = m(U, "]]>", K, "StopNode is not closed.") - 2;
                    else {
                        const S = g(U, K, ">");
                        S && ((S && S.tagName) === D && S.tagExp[S.tagExp.length - 1] !== "/" && T++,
                        K = S.closeIndex)
                    }
        }
        function G(U, D, K) {
            if (D && typeof U == "string") {
                const _ = U.trim();
                return _ === "true" ? !0 : _ === "false" ? !1 : r(U, K)
            } else
                return e.isExist(U) ? U : ""
        }
        return Hp = o,
        Hp
    }
    var Yp = {}, r1;
    function y6() {
        if (r1)
            return Yp;
        r1 = 1;
        function e(o, c) {
            return t(o, c)
        }
        function t(o, c, l) {
            let f;
            const d = {};
            for (let h = 0; h < o.length; h++) {
                const y = o[h]
                  , I = n(y);
                let $ = "";
                if (l === void 0 ? $ = I : $ = l + "." + I,
                I === c.textNodeName)
                    f === void 0 ? f = y[I] : f += "" + y[I];
                else {
                    if (I === void 0)
                        continue;
                    if (y[I]) {
                        let O = t(y[I], c, $);
                        const A = s(O, c);
                        y[":@"] ? r(O, y[":@"], $, c) : Object.keys(O).length === 1 && O[c.textNodeName] !== void 0 && !c.alwaysCreateTextNode ? O = O[c.textNodeName] : Object.keys(O).length === 0 && (c.alwaysCreateTextNode ? O[c.textNodeName] = "" : O = ""),
                        d[I] !== void 0 && d.hasOwnProperty(I) ? (Array.isArray(d[I]) || (d[I] = [d[I]]),
                        d[I].push(O)) : c.isArray(I, $, A) ? d[I] = [O] : d[I] = O
                    }
                }
            }
            return typeof f == "string" ? f.length > 0 && (d[c.textNodeName] = f) : f !== void 0 && (d[c.textNodeName] = f),
            d
        }
        function n(o) {
            const c = Object.keys(o);
            for (let l = 0; l < c.length; l++) {
                const f = c[l];
                if (f !== ":@")
                    return f
            }
        }
        function r(o, c, l, f) {
            if (c) {
                const d = Object.keys(c)
                  , h = d.length;
                for (let y = 0; y < h; y++) {
                    const I = d[y];
                    f.isArray(I, l + "." + I, !0, !0) ? o[I] = [c[I]] : o[I] = c[I]
                }
            }
        }
        function s(o, c) {
            const {textNodeName: l} = c
              , f = Object.keys(o).length;
            return !!(f === 0 || f === 1 && (o[l] || typeof o[l] == "boolean" || o[l] === 0))
        }
        return Yp.prettify = e,
        Yp
    }
    var Vp, i1;
    function _6() {
        if (i1)
            return Vp;
        i1 = 1;
        const {buildOptions: e} = d6()
          , t = g6()
          , {prettify: n} = y6()
          , r = rS();
        class s {
            constructor(c) {
                this.externalEntities = {},
                this.options = e(c)
            }
            parse(c, l) {
                if (typeof c != "string")
                    if (c.toString)
                        c = c.toString();
                    else
                        throw new Error("XML data is accepted in String or Bytes[] form.");
                if (l) {
                    l === !0 && (l = {});
                    const h = r.validate(c, l);
                    if (h !== !0)
                        throw Error(`${h.err.msg}:${h.err.line}:${h.err.col}`)
                }
                const f = new t(this.options);
                f.addExternalEntities(this.externalEntities);
                const d = f.parseXml(c);
                return this.options.preserveOrder || d === void 0 ? d : n(d, this.options)
            }
            addEntity(c, l) {
                if (l.indexOf("&") !== -1)
                    throw new Error("Entity value can't have '&'");
                if (c.indexOf("&") !== -1 || c.indexOf(";") !== -1)
                    throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
                if (l === "&")
                    throw new Error("An entity with value '&' is not permitted");
                this.externalEntities[c] = l
            }
        }
        return Vp = s,
        Vp
    }
    var Wp, s1;
    function v6() {
        if (s1)
            return Wp;
        s1 = 1;
        const e = `
`;
        function t(l, f) {
            let d = "";
            return f.format && f.indentBy.length > 0 && (d = e),
            n(l, f, "", d)
        }
        function n(l, f, d, h) {
            let y = ""
              , I = !1;
            for (let $ = 0; $ < l.length; $++) {
                const O = l[$]
                  , A = r(O);
                if (A === void 0)
                    continue;
                let N = "";
                if (d.length === 0 ? N = A : N = `${d}.${A}`,
                A === f.textNodeName) {
                    let U = O[A];
                    o(N, f) || (U = f.tagValueProcessor(A, U),
                    U = c(U, f)),
                    I && (y += h),
                    y += U,
                    I = !1;
                    continue
                } else if (A === f.cdataPropName) {
                    I && (y += h),
                    y += `<![CDATA[${O[A][0][f.textNodeName]}]]>`,
                    I = !1;
                    continue
                } else if (A === f.commentPropName) {
                    y += h + `<!--${O[A][0][f.textNodeName]}-->`,
                    I = !0;
                    continue
                } else if (A[0] === "?") {
                    const U = s(O[":@"], f)
                      , D = A === "?xml" ? "" : h;
                    let K = O[A][0][f.textNodeName];
                    K = K.length !== 0 ? " " + K : "",
                    y += D + `<${A}${K}${U}?>`,
                    I = !0;
                    continue
                }
                let m = h;
                m !== "" && (m += f.indentBy);
                const g = s(O[":@"], f)
                  , M = h + `<${A}${g}`
                  , G = n(O[A], f, N, m);
                f.unpairedTags.indexOf(A) !== -1 ? f.suppressUnpairedNode ? y += M + ">" : y += M + "/>" : (!G || G.length === 0) && f.suppressEmptyNode ? y += M + "/>" : G && G.endsWith(">") ? y += M + `>${G}${h}</${A}>` : (y += M + ">",
                G && h !== "" && (G.includes("/>") || G.includes("</")) ? y += h + f.indentBy + G + h : y += G,
                y += `</${A}>`),
                I = !0
            }
            return y
        }
        function r(l) {
            const f = Object.keys(l);
            for (let d = 0; d < f.length; d++) {
                const h = f[d];
                if (l.hasOwnProperty(h) && h !== ":@")
                    return h
            }
        }
        function s(l, f) {
            let d = "";
            if (l && !f.ignoreAttributes)
                for (let h in l) {
                    if (!l.hasOwnProperty(h))
                        continue;
                    let y = f.attributeValueProcessor(h, l[h]);
                    y = c(y, f),
                    y === !0 && f.suppressBooleanAttributes ? d += ` ${h.substr(f.attributeNamePrefix.length)}` : d += ` ${h.substr(f.attributeNamePrefix.length)}="${y}"`
                }
            return d
        }
        function o(l, f) {
            l = l.substr(0, l.length - f.textNodeName.length - 1);
            let d = l.substr(l.lastIndexOf(".") + 1);
            for (let h in f.stopNodes)
                if (f.stopNodes[h] === l || f.stopNodes[h] === "*." + d)
                    return !0;
            return !1
        }
        function c(l, f) {
            if (l && l.length > 0 && f.processEntities)
                for (let d = 0; d < f.entities.length; d++) {
                    const h = f.entities[d];
                    l = l.replace(h.regex, h.val)
                }
            return l
        }
        return Wp = t,
        Wp
    }
    var zp, a1;
    function w6() {
        if (a1)
            return zp;
        a1 = 1;
        const e = v6()
          , t = iS()
          , n = {
            attributeNamePrefix: "@_",
            attributesGroupName: !1,
            textNodeName: "#text",
            ignoreAttributes: !0,
            cdataPropName: !1,
            format: !1,
            indentBy: "  ",
            suppressEmptyNode: !1,
            suppressUnpairedNode: !0,
            suppressBooleanAttributes: !0,
            tagValueProcessor: function(l, f) {
                return f
            },
            attributeValueProcessor: function(l, f) {
                return f
            },
            preserveOrder: !1,
            commentPropName: !1,
            unpairedTags: [],
            entities: [{
                regex: new RegExp("&","g"),
                val: "&amp;"
            }, {
                regex: new RegExp(">","g"),
                val: "&gt;"
            }, {
                regex: new RegExp("<","g"),
                val: "&lt;"
            }, {
                regex: new RegExp("'","g"),
                val: "&apos;"
            }, {
                regex: new RegExp('"',"g"),
                val: "&quot;"
            }],
            processEntities: !0,
            stopNodes: [],
            oneListGroup: !1
        };
        function r(l) {
            this.options = Object.assign({}, n, l),
            this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
                return !1
            }
            : (this.ignoreAttributesFn = t(this.options.ignoreAttributes),
            this.attrPrefixLen = this.options.attributeNamePrefix.length,
            this.isAttribute = c),
            this.processTextOrObjNode = s,
            this.options.format ? (this.indentate = o,
            this.tagEndChar = `>
`,
            this.newLine = `
`) : (this.indentate = function() {
                return ""
            }
            ,
            this.tagEndChar = ">",
            this.newLine = "")
        }
        r.prototype.build = function(l) {
            return this.options.preserveOrder ? e(l, this.options) : (Array.isArray(l) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (l = {
                [this.options.arrayNodeName]: l
            }),
            this.j2x(l, 0, []).val)
        }
        ,
        r.prototype.j2x = function(l, f, d) {
            let h = ""
              , y = "";
            const I = d.join(".");
            for (let $ in l)
                if (Object.prototype.hasOwnProperty.call(l, $))
                    if (typeof l[$] > "u")
                        this.isAttribute($) && (y += "");
                    else if (l[$] === null)
                        this.isAttribute($) || $ === this.options.cdataPropName ? y += "" : $[0] === "?" ? y += this.indentate(f) + "<" + $ + "?" + this.tagEndChar : y += this.indentate(f) + "<" + $ + "/" + this.tagEndChar;
                    else if (l[$]instanceof Date)
                        y += this.buildTextValNode(l[$], $, "", f);
                    else if (typeof l[$] != "object") {
                        const O = this.isAttribute($);
                        if (O && !this.ignoreAttributesFn(O, I))
                            h += this.buildAttrPairStr(O, "" + l[$]);
                        else if (!O)
                            if ($ === this.options.textNodeName) {
                                let A = this.options.tagValueProcessor($, "" + l[$]);
                                y += this.replaceEntitiesValue(A)
                            } else
                                y += this.buildTextValNode(l[$], $, "", f)
                    } else if (Array.isArray(l[$])) {
                        const O = l[$].length;
                        let A = ""
                          , N = "";
                        for (let m = 0; m < O; m++) {
                            const g = l[$][m];
                            if (!(typeof g > "u"))
                                if (g === null)
                                    $[0] === "?" ? y += this.indentate(f) + "<" + $ + "?" + this.tagEndChar : y += this.indentate(f) + "<" + $ + "/" + this.tagEndChar;
                                else if (typeof g == "object")
                                    if (this.options.oneListGroup) {
                                        const M = this.j2x(g, f + 1, d.concat($));
                                        A += M.val,
                                        this.options.attributesGroupName && g.hasOwnProperty(this.options.attributesGroupName) && (N += M.attrStr)
                                    } else
                                        A += this.processTextOrObjNode(g, $, f, d);
                                else if (this.options.oneListGroup) {
                                    let M = this.options.tagValueProcessor($, g);
                                    M = this.replaceEntitiesValue(M),
                                    A += M
                                } else
                                    A += this.buildTextValNode(g, $, "", f)
                        }
                        this.options.oneListGroup && (A = this.buildObjectNode(A, $, N, f)),
                        y += A
                    } else if (this.options.attributesGroupName && $ === this.options.attributesGroupName) {
                        const O = Object.keys(l[$])
                          , A = O.length;
                        for (let N = 0; N < A; N++)
                            h += this.buildAttrPairStr(O[N], "" + l[$][O[N]])
                    } else
                        y += this.processTextOrObjNode(l[$], $, f, d);
            return {
                attrStr: h,
                val: y
            }
        }
        ,
        r.prototype.buildAttrPairStr = function(l, f) {
            return f = this.options.attributeValueProcessor(l, "" + f),
            f = this.replaceEntitiesValue(f),
            this.options.suppressBooleanAttributes && f === "true" ? " " + l : " " + l + '="' + f + '"'
        }
        ;
        function s(l, f, d, h) {
            const y = this.j2x(l, d + 1, h.concat(f));
            return l[this.options.textNodeName] !== void 0 && Object.keys(l).length === 1 ? this.buildTextValNode(l[this.options.textNodeName], f, y.attrStr, d) : this.buildObjectNode(y.val, f, y.attrStr, d)
        }
        r.prototype.buildObjectNode = function(l, f, d, h) {
            if (l === "")
                return f[0] === "?" ? this.indentate(h) + "<" + f + d + "?" + this.tagEndChar : this.indentate(h) + "<" + f + d + this.closeTag(f) + this.tagEndChar;
            {
                let y = "</" + f + this.tagEndChar
                  , I = "";
                return f[0] === "?" && (I = "?",
                y = ""),
                (d || d === "") && l.indexOf("<") === -1 ? this.indentate(h) + "<" + f + d + I + ">" + l + y : this.options.commentPropName !== !1 && f === this.options.commentPropName && I.length === 0 ? this.indentate(h) + `<!--${l}-->` + this.newLine : this.indentate(h) + "<" + f + d + I + this.tagEndChar + l + this.indentate(h) + y
            }
        }
        ,
        r.prototype.closeTag = function(l) {
            let f = "";
            return this.options.unpairedTags.indexOf(l) !== -1 ? this.options.suppressUnpairedNode || (f = "/") : this.options.suppressEmptyNode ? f = "/" : f = `></${l}`,
            f
        }
        ,
        r.prototype.buildTextValNode = function(l, f, d, h) {
            if (this.options.cdataPropName !== !1 && f === this.options.cdataPropName)
                return this.indentate(h) + `<![CDATA[${l}]]>` + this.newLine;
            if (this.options.commentPropName !== !1 && f === this.options.commentPropName)
                return this.indentate(h) + `<!--${l}-->` + this.newLine;
            if (f[0] === "?")
                return this.indentate(h) + "<" + f + d + "?" + this.tagEndChar;
            {
                let y = this.options.tagValueProcessor(f, l);
                return y = this.replaceEntitiesValue(y),
                y === "" ? this.indentate(h) + "<" + f + d + this.closeTag(f) + this.tagEndChar : this.indentate(h) + "<" + f + d + ">" + y + "</" + f + this.tagEndChar
            }
        }
        ,
        r.prototype.replaceEntitiesValue = function(l) {
            if (l && l.length > 0 && this.options.processEntities)
                for (let f = 0; f < this.options.entities.length; f++) {
                    const d = this.options.entities[f];
                    l = l.replace(d.regex, d.val)
                }
            return l
        }
        ;
        function o(l) {
            return this.options.indentBy.repeat(l)
        }
        function c(l) {
            return l.startsWith(this.options.attributeNamePrefix) && l !== this.options.textNodeName ? l.substr(this.attrPrefixLen) : !1
        }
        return zp = r,
        zp
    }
    var Gp, o1;
    function b6() {
        if (o1)
            return Gp;
        o1 = 1;
        const e = rS()
          , t = _6()
          , n = w6();
        return Gp = {
            XMLParser: t,
            XMLValidator: e,
            XMLBuilder: n
        },
        Gp
    }
    (function(e) {
        ( () => {
            var t = {
                306: (l, f, d) => {
                    Object.defineProperty(f, "__esModule", {
                        value: !0
                    });
                    const h = d(861)
                      , y = d(167);
                    f.default = async (I, $) => {
                        var O, A;
                        if (!/(^http(s?):\/\/[^\s$.?#].[^\s]*)/i.test(I))
                            return null;
                        const {data: N} = await (0,
                        y.default)(I, $)
                          , m = new h.XMLParser({
                            attributeNamePrefix: "",
                            textNodeName: "$text",
                            ignoreAttributes: !1
                        }).parse(N);
                        let g = m.rss && m.rss.channel ? m.rss.channel : m.feed;
                        Array.isArray(g) && (g = g[0]);
                        const M = {
                            title: (O = g.title) !== null && O !== void 0 ? O : "",
                            description: (A = g.description) !== null && A !== void 0 ? A : "",
                            link: g.link && g.link.href ? g.link.href : g.link,
                            image: g.image ? g.image.url : g["itunes:image"] ? g["itunes:image"].href : "",
                            category: g.category || [],
                            items: []
                        };
                        let G = g.item || g.entry || [];
                        G && !Array.isArray(G) && (G = [G]);
                        for (let U = 0; U < G.length; U++) {
                            const D = G[U]
                              , K = {}
                              , _ = {
                                id: D.guid && D.guid.$text ? D.guid.$text : D.id,
                                title: D.title && D.title.$text ? D.title.$text : D.title,
                                description: D.summary && D.summary.$text ? D.summary.$text : D.description,
                                link: D.link && D.link.href ? D.link.href : D.link,
                                author: D.author && D.author.name ? D.author.name : D["dc:creator"],
                                published: D.created ? Date.parse(D.created) : D.pubDate ? Date.parse(D.pubDate) : Date.now(),
                                created: D.updated ? Date.parse(D.updated) : D.pubDate ? Date.parse(D.pubDate) : D.created ? Date.parse(D.created) : Date.now(),
                                category: D.category || [],
                                content: D.content && D.content.$text ? D.content.$text : D["content:encoded"],
                                enclosures: D.enclosure ? Array.isArray(D.enclosure) ? D.enclosure : [D.enclosure] : []
                            };
                            ["content:encoded", "podcast:transcript", "itunes:summary", "itunes:author", "itunes:explicit", "itunes:duration", "itunes:season", "itunes:episode", "itunes:episodeType", "itunes:image"].forEach(T => {
                                D[T] && (_[T.replace(":", "_")] = D[T])
                            }
                            ),
                            D["media:thumbnail"] && (Object.assign(K, {
                                thumbnail: D["media:thumbnail"]
                            }),
                            _.enclosures.push(D["media:thumbnail"])),
                            D["media:content"] && (Object.assign(K, {
                                thumbnail: D["media:content"]
                            }),
                            _.enclosures.push(D["media:content"])),
                            D["media:group"] && (D["media:group"]["media:title"] && (_.title = D["media:group"]["media:title"]),
                            D["media:group"]["media:description"] && (_.description = D["media:group"]["media:description"]),
                            D["media:group"]["media:thumbnail"] && _.enclosures.push(D["media:group"]["media:thumbnail"].url)),
                            Object.assign(_, {
                                media: K
                            }),
                            M.items.push(_)
                        }
                        return M
                    }
                }
                ,
                167: l => {
                    l.exports = ME()
                }
                ,
                861: l => {
                    l.exports = b6()
                }
            }
              , n = {};
            function r(l) {
                var f = n[l];
                if (f !== void 0)
                    return f.exports;
                var d = n[l] = {
                    exports: {}
                };
                return t[l](d, d.exports, r),
                d.exports
            }
            var s = {};
            ( () => {
                var l = s;
                Object.defineProperty(l, "__esModule", {
                    value: !0
                }),
                l.Parse = l.parse = void 0;
                const f = r(306);
                l.parse = f.default;
                const d = f.default;
                l.Parse = d,
                l.default = f.default
            }
            )();
            var o = e;
            for (var c in s)
                o[c] = s[c];
            s.__esModule && Object.defineProperty(o, "__esModule", {
                value: !0
            })
        }
        )()
    }
    )(nS);
    class E6 extends zi {
        isActivated;
        async setupSection() {
            this.populateNewsSection()
        }
        async populateNewsSection() {
            const t = "https://api.paragraph.com/blogs/rss/@pareto";
            try {
                const n = await nS.parse(t)
                  , r = document.querySelectorAll(".news-section__list__item");
                n.items.slice(0, r.length).forEach( (s, o) => {
                    const c = r[o]
                      , l = c.querySelector("a.news-section__list__item__link")
                      , f = c.querySelector(".news-section__list__item__img img")
                      , d = c.querySelector("h4.title-h3")
                      , h = c.querySelector("p.desc-2")
                      , y = c.querySelector(".btn-secondary .nav");
                    l.href = s.link,
                    d.textContent = s.title || "No title",
                    h.textContent = s.description || "No description";
                    let I = "";
                    if (s.enclosures?.length)
                        I = s.enclosures[0].url;
                    else {
                        const $ = s.content?.match(/<img[^>]+src="([^">]+)"/);
                        $ && (I = $[1])
                    }
                    I && (f.src = I,
                    f.setAttribute("data-src", I),
                    f.alt = s.title || "Blog image"),
                    y.textContent = "Read more"
                }
                )
            } catch (n) {
                console.error("Error loading RSS feed:", n)
            }
        }
        async _activate() {
            this.isActivated
        }
        _deactivate() {}
        resize(t, n) {
            super.resize(t, n)
        }
    }
    let md;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.News);
        e && (md = new E6({
            el: e
        }),
        md.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        md && md.unmount()
    }
    );
    class S6 extends zi {
        isActivated;
        async setupSection() {
            new T6,
            await this.loadData()
        }
        _activate() {
            this.isActivated
        }
        _deactivate() {}
        async loadData() {
            const n = await tS().vaultLatestBlocks.readOne({
                vaultId: "68026ee6905992e056c85a75"
            });
            if (n) {
                const r = document.querySelectorAll('[data-id="SUSP-apy"] .info-item__value > p');
                r.length && r.forEach(f => f.innerHTML = Number(n.APYs.NET).toFixed(2) + "%");
                const s = document.querySelectorAll('[data-id="USP-tvl"] .info-item__value > p');
                if (s.length) {
                    const f = {
                        maximumFractionDigits: 1,
                        notation: "compact",
                        currency: "USD",
                        style: "currency",
                        compactDisplay: "short"
                    }
                      , d = new Intl.NumberFormat("en-US",f);
                    s.forEach(h => h.innerHTML = d.format(Number(n.totalSupply) / 1e18))
                }
                const o = document.querySelectorAll('[data-id="SUSP-tvl"] .info-item__value > p');
                if (o.length) {
                    const f = {
                        maximumFractionDigits: 1,
                        notation: "compact",
                        currency: "USD",
                        style: "currency",
                        compactDisplay: "short"
                    }
                      , d = new Intl.NumberFormat("en-US",f);
                    o.forEach(h => h.innerHTML = d.format(Number(n.paretoDollar.staking.totalAssets) / 1e18))
                }
                const c = document.querySelectorAll('[data-id="USP-price"] .info-item__value > p');
                if (c.length) {
                    const f = {
                        maximumFractionDigits: 2,
                        currency: "USD",
                        style: "currency"
                    }
                      , d = new Intl.NumberFormat("en-US",f);
                    c.forEach(h => h.innerHTML = d.format(1))
                }
                const l = document.querySelectorAll('[data-id="SUSP-price"] .info-item__value > p');
                if (l.length) {
                    const f = {
                        maximumFractionDigits: 2,
                        currency: "USD",
                        style: "currency"
                    }
                      , d = new Intl.NumberFormat("en-US",f);
                    l.forEach(h => h.innerHTML = d.format(Number(n.price) / 1e18))
                }
            }
        }
    }
    let gd;
    document.addEventListener("astro:page-load", () => {
        const e = document.getElementById(ci.OurProducts);
        e && (gd = new S6({
            el: e
        }),
        gd.setup())
    }
    );
    document.addEventListener("astro:before-preparation", () => {
        gd && gd.unmount()
    }
    );
    class T6 {
        buttons;
        slider;
        contents;
        constructor() {
            this.buttons = document.querySelectorAll(".toggle-button"),
            this.slider = document.querySelector(".toggle-slider"),
            this.contents = document.querySelectorAll('[class*="content-item-"]'),
            this.init()
        }
        init() {
            this.buttons.forEach(t => {
                t.addEventListener("click", () => this.handleToggle(t))
            }
            ),
            this.contents.forEach(t => {
                t.classList.contains("content-item-0") ? t.classList.remove("hidden") : t.classList.add("hidden")
            }
            )
        }
        handleToggle(t) {
            const n = t.dataset.id;
            this.buttons.forEach(r => {
                r.classList.remove("active")
            }
            ),
            t.classList.add("active"),
            this.slider && n === "1" ? this.slider.classList.add("slide") : this.slider && this.slider.classList.remove("slide"),
            this.contents.forEach(r => {
                r.classList.contains(`content-item-${n}`) ? r.classList.remove("hidden") : r.classList.add("hidden")
            }
            )
        }
    }
}
);
export default A6();
